<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>GAMES102</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="The note of GAMES102">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/pagetoc.css">
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">GAMES102</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">1.</strong> Introduction 介绍</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="Introduction/3DData.html"><strong aria-hidden="true">1.1.</strong> 三维数据</a></li><li class="chapter-item expanded "><a href="Introduction/MathBasic.html"><strong aria-hidden="true">1.2.</strong> 数学基础</a></li><li class="chapter-item expanded "><a href="Introduction/MLBaic.html"><strong aria-hidden="true">1.3.</strong> ML基础</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.</strong> 数据拟合</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="DataFitting/DataFitting.html"><strong aria-hidden="true">2.1.</strong> 数据拟合</a></li><li class="chapter-item expanded "><a href="DataFitting/PolynomialInterpolation.html"><strong aria-hidden="true">2.2.</strong> 1. 多项式插值</a></li><li class="chapter-item expanded "><a href="DataFitting/PolynomialApproximation.html"><strong aria-hidden="true">2.3.</strong> 2. 多项式逼近</a></li><li class="chapter-item expanded "><a href="DataFitting/Funtion.html"><strong aria-hidden="true">2.4.</strong> 3. 函数空间及基函数</a></li><li class="chapter-item expanded "><a href="DataFitting/RBF.html"><strong aria-hidden="true">2.5.</strong> 4. RBF函数插值/逼近</a></li><li class="chapter-item expanded "><a href="DataFitting/NewView.html"><strong aria-hidden="true">2.6.</strong> 5. 从另一个角度来看拟合函数</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.</strong> 参数拟合</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="ParametricFitting/Review.html"><strong aria-hidden="true">3.1.</strong> 回顾</a></li><li class="chapter-item expanded "><a href="ParametricFitting/Multi.html"><strong aria-hidden="true">3.2.</strong> 多元函数</a></li><li class="chapter-item expanded "><a href="ParametricFitting/VectorValue.html"><strong aria-hidden="true">3.3.</strong> 向量值函数</a></li><li class="chapter-item expanded "><a href="ParametricFitting/CurveFitting.html"><strong aria-hidden="true">3.4.</strong> 曲线拟合</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> 三次样条函数</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="CubicSplines/CubicSplineFunction.html"><strong aria-hidden="true">4.1.</strong> 三次样条函数</a></li><li class="chapter-item expanded "><a href="CubicSplines/CubicBasisSpline.html"><strong aria-hidden="true">4.2.</strong> 三次基样条</a></li><li class="chapter-item expanded "><a href="CubicSplines/CubicSplineCurve.html"><strong aria-hidden="true">4.3.</strong> 三次样条曲线</a></li><li class="chapter-item expanded "><a href="CubicSplines/GeometricContinuity.html"><strong aria-hidden="true">4.4.</strong> 几何连续性</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> Bezier曲线</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="BezierCurve/Review.html"><strong aria-hidden="true">5.1.</strong> 回顾</a></li><li class="chapter-item expanded "><a href="BezierCurve/BernsteinBasisFunction.html"><strong aria-hidden="true">5.2.</strong> Bernstein基函数</a></li><li class="chapter-item expanded "><a href="BezierCurve/BezierCurve.html"><strong aria-hidden="true">5.3.</strong> Bezier曲线</a></li><li class="chapter-item expanded "><a href="BezierCurve/Property.html"><strong aria-hidden="true">5.4.</strong> Bernstein基函数及Bezier曲线的性质</a></li><li class="chapter-item expanded "><a href="BezierCurve/DeCasteljau算法.html"><strong aria-hidden="true">5.5.</strong> de Casteljau算法</a></li><li class="chapter-item expanded "><a href="BezierCurve/GeometricSpline.html"><strong aria-hidden="true">5.6.</strong> 几何样条曲线</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> B样条曲线</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="BsplineCurve/Why.html"><strong aria-hidden="true">6.1.</strong> 为什么引入B样条曲线</a></li><li class="chapter-item expanded "><a href="BsplineCurve/BuildBSpline.html"><strong aria-hidden="true">6.2.</strong> 构造B样条基函数</a></li><li class="chapter-item expanded "><a href="BsplineCurve/BsplineCurve.html"><strong aria-hidden="true">6.3.</strong> B样条曲线</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.</strong> NURBS曲线</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="NURBS/Review.html"><strong aria-hidden="true">7.1.</strong> 回顾</a></li><li class="chapter-item expanded "><a href="NURBS/RationalCurve.html"><strong aria-hidden="true">7.2.</strong> 有理曲线</a></li><li class="chapter-item expanded "><a href="NURBS/NURBS.html"><strong aria-hidden="true">7.3.</strong> NURBS曲线</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.</strong> 细分曲线</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="SubdivisionCurves/Review.html"><strong aria-hidden="true">8.1.</strong> 回顾</a></li><li class="chapter-item expanded "><a href="SubdivisionCurves/Chaikin.html"><strong aria-hidden="true">8.2.</strong> Chaikin细分方法</a></li><li class="chapter-item expanded "><a href="SubdivisionCurves/Property.html"><strong aria-hidden="true">8.3.</strong> 细分曲线的性质证明</a></li><li class="chapter-item expanded "><a href="SubdivisionCurves/interpolate.html"><strong aria-hidden="true">8.4.</strong> 插值型细分方法</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.</strong> 隐式曲线</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="ImplicitCurves/Review.html"><strong aria-hidden="true">9.1.</strong> 回顾</a></li><li class="chapter-item expanded "><a href="ImplicitCurves/ImplicitCurves.html"><strong aria-hidden="true">9.2.</strong> 隐式曲线</a></li><li class="chapter-item expanded "><a href="ImplicitCurves/Draw.html"><strong aria-hidden="true">9.3.</strong> 隐式曲线的绘制</a></li><li class="chapter-item expanded "><a href="ImplicitCurves/Fitting.html"><strong aria-hidden="true">9.4.</strong> 隐式曲线的拟合</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">10.</strong> NURBS曲面</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="SplineSurfaces/Review.html"><strong aria-hidden="true">10.1.</strong> 回顾</a></li><li class="chapter-item expanded "><a href="SplineSurfaces/TrimmedNurbs.html"><strong aria-hidden="true">10.2.</strong> Trimmed Nurbs</a></li><li class="chapter-item expanded "><a href="SplineSurfaces/SplineSurfaces.html"><strong aria-hidden="true">10.3.</strong> 三角域上的Bezier曲面片</a></li></ol></li><li class="chapter-item expanded "><a href="CurveFairing/CurveFairing.html"><strong aria-hidden="true">11.</strong> 曲线光顺</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="CurveFairing/What.html"><strong aria-hidden="true">11.1.</strong> 曲线的光顺定义</a></li><li class="chapter-item expanded "><a href="CurveFairing/How.html"><strong aria-hidden="true">11.2.</strong> 曲线的光顺方法</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">12.</strong> 离散曲线处理</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="DiscreteCurves/Review.html"><strong aria-hidden="true">12.1.</strong> 回顾</a></li><li class="chapter-item expanded "><a href="DiscreteCurves/Discretization.html"><strong aria-hidden="true">12.2.</strong> 曲线的离散</a></li><li class="chapter-item expanded "><a href="DiscreteCurves/BarycentricCoordinate.html"><strong aria-hidden="true">12.3.</strong> 重心坐标</a></li><li class="chapter-item expanded "><a href="DiscreteCurves/2D.html"><strong aria-hidden="true">12.4.</strong> 2D形状（离散曲线）处理</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">13.</strong> 离散微分几何</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="DiscreteDifferential/Review.html"><strong aria-hidden="true">13.1.</strong> 回顾</a></li><li class="chapter-item expanded "><a href="DiscreteDifferential/Curves.html"><strong aria-hidden="true">13.2.</strong> 曲线的微分几何</a></li><li class="chapter-item expanded "><a href="DiscreteDifferential/Surfaces.html"><strong aria-hidden="true">13.3.</strong> 曲面的微分几何</a></li><li class="chapter-item expanded "><a href="DiscreteDifferential/DiscreteDifferential.html"><strong aria-hidden="true">13.4.</strong> 离散微分几何</a></li><li class="chapter-item expanded "><a href="DiscreteDifferential/MinimaSurface.html"><strong aria-hidden="true">13.5.</strong> 极小曲面</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">14.</strong> 三角网格：曲面的离散表达</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="TriangularMeshes/TriangularMeshes.html"><strong aria-hidden="true">14.1.</strong> 曲面的离散表达</a></li><li class="chapter-item expanded "><a href="TriangularMeshes/DataStructure.html"><strong aria-hidden="true">14.2.</strong> 网格曲面的数据结构</a></li><li class="chapter-item expanded "><a href="LaplacianCoordinates/LaplacianCoordinates.html"><strong aria-hidden="true">14.3.</strong> 局部特征度量</a></li><li class="chapter-item expanded "><a href="LaplacianCoordinates/LocalLaplacianSmoothing.html"><strong aria-hidden="true">14.4.</strong> 局部Laplace平滑</a></li><li class="chapter-item expanded "><a href="LaplacianCoordinates/GlobalLaplacianSmoothing.html"><strong aria-hidden="true">14.5.</strong> 全局Laplace平滑</a></li><li class="chapter-item expanded "><a href="LaplacianCoordinates/MeshParameterization.html"><strong aria-hidden="true">14.6.</strong> 曲面参数化</a></li><li class="chapter-item expanded "><a href="LaplacianCoordinates/Constrained.html"><strong aria-hidden="true">14.7.</strong> 约束</a></li><li class="chapter-item expanded "><a href="LaplacianCoordinates/LaplacianEditing.html"><strong aria-hidden="true">14.8.</strong> 编辑</a></li></ol></li><li class="chapter-item expanded "><a href="MeshTessellation/MeshTessellation.html"><strong aria-hidden="true">15.</strong> 曲面细分</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="MeshTessellation/Loop.html"><strong aria-hidden="true">15.1.</strong> Loop细分</a></li><li class="chapter-item expanded "><a href="MeshTessellation/CatmullClark.html"><strong aria-hidden="true">15.2.</strong> Catmull-Clark 细分</a></li></ol></li><li class="chapter-item expanded "><a href="MeshRegularization/MeshRegularization.html"><strong aria-hidden="true">16.</strong> 曲面正则化</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">17.</strong> 曲面去噪</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="Smoothing/Smoothing.html"><strong aria-hidden="true">17.1.</strong> 去噪</a></li><li class="chapter-item expanded "><a href="Smoothing/1VertexFiltering.html"><strong aria-hidden="true">17.2.</strong> 顶点去噪</a></li><li class="chapter-item expanded "><a href="Smoothing/2NormalFiltering.html"><strong aria-hidden="true">17.3.</strong> 法向去噪</a></li><li class="chapter-item expanded "><a href="Smoothing/3GlobalSmoothing.html"><strong aria-hidden="true">17.4.</strong> 全局去噪</a></li><li class="chapter-item expanded "><a href="Smoothing/4MeshImprovement.html"><strong aria-hidden="true">17.5.</strong> mesh提升</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">18.</strong> 采样与剖分</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="SamplingTessellation/Sampling.html"><strong aria-hidden="true">18.1.</strong> 采样</a></li><li class="chapter-item expanded "><a href="SamplingTessellation/Triangular.html"><strong aria-hidden="true">18.2.</strong> 平面三角形网络</a></li><li class="chapter-item expanded "><a href="SamplingTessellation/Delaunay.html"><strong aria-hidden="true">18.3.</strong> Delaunay</a></li><li class="chapter-item expanded "><a href="SamplingTessellation/MeshGeneration.html"><strong aria-hidden="true">18.4.</strong> Mesh Generation</a></li><li class="chapter-item expanded "><a href="SamplingTessellation/SamplingTessellation.html"><strong aria-hidden="true">18.5.</strong> 高维几何对象的采样与剖分</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">19.</strong> 曲面参数化</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="Parameterization/Parameterization.html"><strong aria-hidden="true">19.1.</strong> 曲面参数化</a></li><li class="chapter-item expanded "><a href="Parameterization/Bijective.html"><strong aria-hidden="true">19.2.</strong> Bijective Parameterization</a></li><li class="chapter-item expanded "><a href="Parameterization/Cut.html"><strong aria-hidden="true">19.3.</strong> 封闭曲面的割缝问题</a></li><li class="chapter-item expanded "><a href="Parameterization/TextureAtlas.html"><strong aria-hidden="true">19.4.</strong> 纹理地图：多片参数化</a></li><li class="chapter-item expanded "><a href="Parameterization/ball.html"><strong aria-hidden="true">19.5.</strong> 球面参数化</a></li></ol></li><li class="chapter-item expanded "><a href="Simplification/Simplification.html"><strong aria-hidden="true">20.</strong> 面片简化</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Simplification/1Local.html"><strong aria-hidden="true">20.1.</strong> Local</a></li><li class="chapter-item expanded "><a href="Simplification/2Global.html"><strong aria-hidden="true">20.2.</strong> Global</a></li><li class="chapter-item expanded "><a href="Simplification/LOD.html"><strong aria-hidden="true">20.3.</strong> LOD</a></li></ol></li><li class="chapter-item expanded "><a href="Mapping/Mapping.html"><strong aria-hidden="true">21.</strong> 几何映射</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">22.</strong> 几何优化</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="Optimization/Review.html"><strong aria-hidden="true">22.1.</strong> 回顾</a></li><li class="chapter-item expanded "><a href="Optimization/Fundamentals.html"><strong aria-hidden="true">22.2.</strong> Fundamentals</a></li><li class="chapter-item expanded "><a href="Optimization/UnconstrainedOptimization.html"><strong aria-hidden="true">22.3.</strong> 无约束的优化问题</a></li><li class="chapter-item expanded "><a href="Optimization/等式约束的优化问题.html"><strong aria-hidden="true">22.4.</strong> 等式约束的优化问题</a></li><li class="chapter-item expanded "><a href="Optimization/不等式约束的优化问题.html"><strong aria-hidden="true">22.5.</strong> 不等式约束的优化问题</a></li><li class="chapter-item expanded "><a href="Optimization/ConvexOptimization.html"><strong aria-hidden="true">22.6.</strong> Convex Optimization</a></li><li class="chapter-item expanded "><a href="Optimization/其他优化问题.html"><strong aria-hidden="true">22.7.</strong> 其他优化问题</a></li></ol></li><li class="chapter-item expanded "><a href="Reconstruct/Reconstruct.html"><strong aria-hidden="true">23.</strong> 曲面重建</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Reconstruct/1Acquisition.html"><strong aria-hidden="true">23.1.</strong> 1. Acquisition</a></li><li class="chapter-item expanded "><a href="Reconstruct/2Registration.html"><strong aria-hidden="true">23.2.</strong> 2. Registration</a></li><li class="chapter-item expanded "><a href="Reconstruct/3Consolidation.html"><strong aria-hidden="true">23.3.</strong> 3. Consolidation</a></li><li class="chapter-item expanded "><a href="Reconstruct/4Reconstruction.html"><strong aria-hidden="true">23.4.</strong> 4. Reconstruction</a></li><li class="chapter-item expanded "><a href="Reconstruct/5Post‐processing.html"><strong aria-hidden="true">23.5.</strong> 5. Post‐processing</a></li><li class="chapter-item expanded "><a href="Reconstruct/动态物体的3D重建.html"><strong aria-hidden="true">23.6.</strong> 动态物体的3D重建</a></li></ol></li><li class="chapter-item expanded "><a href="Modeling/Modeling.html"><strong aria-hidden="true">24.</strong> 几何建模</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Modeling/1_PointProxy.html"><strong aria-hidden="true">24.1.</strong> 1 Point Proxy</a></li><li class="chapter-item expanded "><a href="Modeling/2_CurveProxy.html"><strong aria-hidden="true">24.2.</strong> 2 Curve Proxy</a></li><li class="chapter-item expanded "><a href="Modeling/3_MeshProxy.html"><strong aria-hidden="true">24.3.</strong> 3 Mesh Proxy</a></li><li class="chapter-item expanded "><a href="Modeling/4_DeformationTransfer.html"><strong aria-hidden="true">24.4.</strong> 4 Deformation Transfer</a></li><li class="chapter-item expanded "><a href="Modeling/5_Sketch‐basedModeling.html"><strong aria-hidden="true">24.5.</strong> 5 Sketch‐based Modeling</a></li><li class="chapter-item expanded "><a href="Modeling/6_SculpturingModeling.html"><strong aria-hidden="true">24.6.</strong> 6 Sculpturing Modeling</a></li></ol></li><li class="chapter-item expanded "><a href="DataDrivenModeling/DataDrivenModeling.html"><strong aria-hidden="true">25.</strong> Data‐Driven Modeling</a></li><li class="chapter-item expanded "><a href="ShapeMorphing/ShapeMorphing.html"><strong aria-hidden="true">26.</strong> Shape Morphing</a></li><li class="chapter-item expanded "><a href="TextureSynthesis/TextureSynthesis.html"><strong aria-hidden="true">27.</strong> 纹理合成</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="TextureSynthesis/1Textures.html"><strong aria-hidden="true">27.1.</strong> Textures</a></li><li class="chapter-item expanded "><a href="TextureSynthesis/22DTextureSynthesis.html"><strong aria-hidden="true">27.2.</strong> 2D Texture Synthesis</a></li><li class="chapter-item expanded "><a href="TextureSynthesis/33DTextureSynthesis.html"><strong aria-hidden="true">27.3.</strong> 3D Texture Synthesis</a></li></ol></li><li class="chapter-item expanded "><a href="ShapeAnalysis/ShapeAnalysis.html"><strong aria-hidden="true">28.</strong> 形状分析与理解</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">GAMES102</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/CaterpillarStudyGroup/GAMES102_mdbook" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main><div class="sidetoc"><nav class="pagetoc"></nav></div>
                        <h1 id="games-102-几何建模与处理"><a class="header" href="#games-102-几何建模与处理">GAMES 102 几何建模与处理</a></h1>
<p><a href="https://www.bilibili.com/video/BV1NA411E7Yr?spm_id_from=333.337.search-card.all.click">原始课程链接</a></p>
<p>如有侵权，请联系删除</p>
<h1 id="说明"><a class="header" href="#说明">说明</a></h1>
<p>这个是GAMES-Webinar提供的一个课程系列。<br />
如果说课程GAMES101的闫神像平易近人的师兄，把所有的算法的细节娓娓道来。那么课程GAMES102的刘老师则像的高深莫测的师傅俯瞰着眼前的知识点。也许他不能像
GAMES101那样照顾到听众的每个细节，但他能带来高屋建瓴的视野。<br />
因此，如果遇到困难就多看几遍，坚持下来，必定“更上一层楼，修得千里目”。</p>
<p>课程PPT中已经列出了所有关键知识点。因此把PPT的内容也贴进了笔记中。在这门课的笔记中，正常字体代表原文。引文及特殊字体代表笔记。且对原PPT内容有做删改，去掉不关心的内容，合并重复的内容。</p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。<br />
https://caterpillarstudygroup.github.io/GAMES102_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="几何的表达方式"><a class="header" href="#几何的表达方式">几何的表达方式</a></h1>
<p>几何的表达方式分为隐式表达和显式表达。</p>
<p>隐式表达[46:35]是指，不提供点的具体位置，只提供点应满足的约束f(x,y,z)=0。<br />
隐式表达可以快速判断一个点在不在物体表面上。但是难以列举所有在表面上的点。</p>
<p>显式表达有两种方式：</p>
<ol>
<li>直接给出所有点的具体位置</li>
<li>给出一些点，以及这些点到另一些点的映射关系，例如\(f:R^2 \rightarrow R^3\)
显式表达可以快速地列出所有在表面上的点，但难以判断一个点在不在表面上。</li>
</ol>
<p>实际场景中，会根据需要使用不同的表达方式</p>
<h1 id="隐式表达举例"><a class="header" href="#隐式表达举例">隐式表达举例</a></h1>
<p>【P10，1:02:05】</p>
<table><thead><tr><th>类型</th><th>举例</th><th>表达方式</th></tr></thead><tbody>
<tr><td>Algebraic Surface</td><td><img src="Introduction/../assets/Intro_49.PNG" alt="" /></td><td>\(x^2 + y^2 + z^2 = 1\)</td></tr>
<tr><td>Constructive solid Geometry</td><td><img src="Introduction/../assets/Intro_50.PNG" alt="" /></td><td>通过基本几何之间的运算来定义新的几何</td></tr>
<tr><td>Distinct Function</td><td>[1:01:23]<img src="Introduction/../assets/Intro_51.PNG" alt="" /></td><td>定将一个函数，来描述任意一个点到物体表面的最近的距离。距离为0的点就是边界。</td></tr>
<tr><td>Distinct Function</td><td>[1:02:20]<img src="Introduction/../assets/Intro_52.PNG" alt="" /></td><td>可对距离函数做blending</td></tr>
<tr><td>Fractals 分形</td><td>[1：12：44]<img src="Introduction/../assets/Intro_56.PNG" alt="" /></td><td>自相似。容易引入走样</td></tr>
</tbody></table>
<p>距离函数blend相关的补充：</p>
<ol>
<li>距离函数blend可以用于物体运动过程的插值。<br />
<img src="Introduction/../assets/Intro_53.PNG" alt="" /><br />
图中A和B代表模型在两个动态状态的效果，如果用非SDF(signed distance field)的方式表达，对A和B做线性混合之后会得到这样的效果：<br />
<img src="Introduction/../assets/Intro_54.PNG" alt="" /><br />
我们实际想到的是物体从A状态运动到B状态的效果。这个效果与我们预期的不一致。<br />
如果用SDF来描述A和B，对两个SDF做blend就能够达到目的了。</li>
<li>两个SDF做blend得到新的SDF，怎么再根据SDF恢复出物体的表面？<br />
答：marching cube。在格子上找出f(x)=0的点，然后把点连起来。<br />
<img src="Introduction/../assets/Intro_55.PNG" alt="" /></li>
</ol>
<blockquote>
<p>💡 基于骨骼动作的mesh blending也能达到这个效果。因此重要的不是隐式或显式，而是有没有抓住运动的来源。</p>
</blockquote>
<p>优点：</p>
<ul>
<li>容易描述</li>
<li>compact 表达</li>
<li>容易判断一个点是否在模型的内部/外部</li>
<li>容易计算离表面的距离</li>
<li>容易计算光线与表面的夹角<br />
缺点：</li>
<li>难以描述复杂对象</li>
</ul>
<h1 id="显式几何"><a class="header" href="#显式几何">显式几何</a></h1>
<h2 id="映射p10"><a class="header" href="#映射p10">映射[P10]</a></h2>
<p><img src="Introduction/../assets/Intro_57.PNG" alt="" /></p>
<h2 id="点云-point-cloud"><a class="header" href="#点云-point-cloud">点云 point cloud</a></h2>
<p>list of points</p>
<p>足够可以表示任意的几何形状</p>
<p>常用于扫描输出</p>
<p>常被转换为其它表达方式再使用</p>
<h2 id="polygon-mesh"><a class="header" href="#polygon-mesh">Polygon Mesh</a></h2>
<p>应用最广泛。</p>
<p>以三角形、四边形为主</p>
<p><strong>obj 文件格式</strong>：</p>
<ul>
<li>v：顶点坐标</li>
<li>vn:顶点法向量，数量同v</li>
<li>vt：纹理坐标，最多为（顶点数 * 面片数）个</li>
<li>f：面片，v/vt/vn</li>
</ul>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。<br />
https://caterpillarstudygroup.github.io/GAMES101_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="从数学开始"><a class="header" href="#从数学开始">从数学开始</a></h1>
<p>数学是一种语言。用数学语言进行建模的过程：问题→模型-&gt;算法-&gt;代码。<strong>使用数学语言要擅长抽象。</strong></p>
<p><img src="Introduction/../assets/1.PNG" alt="" /></p>
<blockquote>
<p>👆 科学研究的过程</p>
</blockquote>
<blockquote>
<p>✅ 其中，<strong>对问题建模</strong>的能力是最重要的</p>
</blockquote>
<p><em>集合内容跳过。</em><br />
<em>线性空间内容跳过。</em><br />
<em>映射内容跳过。</em><br />
<em>函数内容跳过。</em></p>
<h1 id="函数的集合函数空间"><a class="header" href="#函数的集合函数空间">函数的集合（函数空间）</a></h1>
<p>用若干简单函数（“基函数”）线性组合张成一个函数空间</p>
<p>$$
-L=span\left (f_1,f_2,\dots ,f_n \right ) =({\textstyle \sum_{i=1}^{n}} a_if_i(x)|a_i\in R)
$$</p>
<p>每个函数就表达（对应）为\(n\)个实数，即系数向量\((a_1,a_2,\dots ,a_n)\)</p>
<p>例如：
幂基</p>
<p>$$
( x^{k},k=0,1,\dots ,n )
$$ </p>
<p>构成的函数空间</p>
<p>$$
f(x)=\sum_{k=0}^{n} w_{k} x^{k}
$$</p>
<p>称为多项式函数空间。</p>
<p>三角函数基构成的函数空间</p>
<p>$$
f(x)=a_{0}+\sum_{k=1}^{n}\left(a_{k} \cos k x+b_{k} \sin k x\right)
$$</p>
<p>称为三角函数空间</p>
<p><strong>空间的完备性：这个函数空间是否可以表示（逼近）任意函数？</strong></p>
<blockquote>
<p>❗ 函数空间几乎是后面课程整个连续几何部分的基础，理解函数空间对理解后面的课程非常重要。</p>
</blockquote>
<h2 id="万能逼近定理"><a class="header" href="#万能逼近定理">万能逼近定理</a></h2>
<p>Weierstrass逼近定理：<br />
• 定理1：闭区间上的连续函数可用多项式级数一致逼近<br />
• 定理2：闭区间上周期为\(2π\)的连续函数可用三角函数级数一致逼近<br />
对 \( [a, b]  \)上的任意连续函数\(g\), 及任意给定的\(\varepsilon&gt;0 \), 必存在\(n\) 次代数多项式\(f(x)=\sum_{k=0}^{n} w_{k} x^{k} \), 使得
$$
\min _{x \in[a, b]}|f(x)-g(x)|&lt;\varepsilon.
$$</p>
<h2 id="傅里叶级数"><a class="header" href="#傅里叶级数">傅里叶级数</a></h2>
<p>$$
f(t)=A_{0}+\sum_{n=1}^{\infty}\left[a_{n} \cos (n \omega t)+b_{n} \sin (n \omega t)\right]
$$</p>
<p>$$
f(t)=A_{0}+\sum_{n=1}^{\infty} A_{n} \sin n \omega t+\psi_{n}
$$</p>
<blockquote>
<p>[47:46] 两个\(f(t)\)是等价的。\(n\)代表对sin的缩放，\(\phi_t\) 代表对 sin 的平移，用一个函数sin通过对它的伸缩和左右平移，就能表达一个任意复杂的周期函数。</p>
</blockquote>
<p><img src="Introduction/../assets/47-1.png" alt="" /></p>
<h1 id="更复杂的函数函数复合"><a class="header" href="#更复杂的函数函数复合">更复杂的函数：函数复合</a></h1>
<p><img src="Introduction/../assets/48-1.png" alt="" /></p>
<p>$$
f=f_{k}{ }^{\circ} f_{k-1}{ }^{\circ} \ldots{ }^{\circ} f_{0}
$$ </p>
<h1 id="问题如何求满足要求的函数"><a class="header" href="#问题如何求满足要求的函数">问题：如何求满足要求的函数？</a></h1>
<blockquote>
<p>🔎 [51：11]</p>
</blockquote>
<p>大部分的实际应用问题</p>
<ul>
<li>还需要根据实际问题设计输入输出</li>
<li>可建模为：找一个映射/变换/函数</li>
<li>输入不一样、变量不一样、维数不一样</li>
</ul>
<p>如何找函数的三步曲：</p>
<ul>
<li><em><strong>到哪找</strong></em>，即确定某个函数集合/空间<br />
①各种网络模型(CNN，RNN)都是在解决“到哪找”的问题</li>
<li><em><strong>找哪个</strong></em>，即<strong>度量</strong>哪个函数是好的/“最好”的<br />
②各种Loss定义(L2,交叉熵)都是在解决“找哪个”的问题</li>
<li><em><strong>怎么找</strong></em>，即求解或优化。可以选择不同的优化方法与技巧，目标是既要快、又要好…<br />
③各种优化方法(牛顿下降、Adam)都是在解决“怎么找”的问题</li>
</ul>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。
https://caterpillarstudygroup.github.io/GAMES102_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="数据拟合fitting问题"><a class="header" href="#数据拟合fitting问题">数据拟合(Fitting)问题</a></h1>
<p>输入：一些观察的数据点<br />
输出：<strong>反映这些数据规律的函数</strong>\(y=f(x)\)</p>
<p><img src="Introduction/../assets/2.PNG" alt="" /></p>
<blockquote>
<p>🔎 [55：12]</p>
</blockquote>
<h2 id="1-到哪找"><a class="header" href="#1-到哪找">1. 到哪找？</a></h2>
<p><strong>选择一个函数空间</strong>，通过函数空间来构造线性函数空间：</p>
<p>$$
A=span(B_{0}(x), \ldots, B_{n}(x))
$$</p>
<p>可以选择的函数空间有：</p>
<ul>
<li>多项式函数 \(span  (1, x, x^{2}, \ldots, x^{n})\)</li>
<li>\(RBF\)函数</li>
<li>三角函数</li>
</ul>
<blockquote>
<p>✅ 选定一组基函数。<br />
如果目标是周期函数，选择三角函数会比较合适</p>
</blockquote>
<p>于是<strong>函数表达为</strong></p>
<p>$$
f(x)=\sum_{k=0}^{n} a_{k} B_{k}(x) 
$$</p>
<blockquote>
<p>把\(f(x)\)为表达基函数 \(\times\) 系数，那么一组系数能确定一个\(f(x)\)</p>
</blockquote>
<p>求\(n+1\)个系数\((a_{0}, \ldots, a_{n})\)</p>
<blockquote>
<p>✅ 把待定系数\((a_{0}, \ldots, a_{n})\)求解出来，这个函数就算是找到了。</p>
</blockquote>
<h2 id="2-找哪个--怎么找-目标1"><a class="header" href="#2-找哪个--怎么找-目标1">2. 找哪个？ &amp;&amp; 怎么找？ 目标1</a></h2>
<h3 id="目标"><a class="header" href="#目标">目标</a></h3>
<p>目标: 函数经过每个数据点（<strong>插值</strong>） </p>
<p><img src="Introduction/../assets/ML%E6%8B%9F%E5%90%88-1.png" alt="" /></p>
<p>$$
y_{i}=f\left(x_{i}\right),i=0,1,\ldots,n
$$</p>
<h3 id="联立方程组"><a class="header" href="#联立方程组">联立方程组</a></h3>
<p>[57:18]把\(x_i\)和\(y_i\)代入公式。联立, 可得线性方程组</p>
<p>$$ 
\sum_{k=0}^{n} a_{k} B_{k}\left(x_{i}\right)=y_{i}, i=0,1, \ldots, n 
$$</p>
<p>简化写法为：</p>
<p>$$
Aa = b
$$</p>
<p>其中，\(A 是 x_i 代入 B_k (x_i)得到的矩阵。a 是系数组成的向量。b 是 y_i\) 组成的向量。 </p>
<h3 id="langrange方法求解"><a class="header" href="#langrange方法求解">Langrange方法求解</a></h3>
<p>求解\((n+1) \times(n+1)\)线性方程组，可使用\(n\)次Langrange插值多项式方法。</p>
<p>插值\(n+1\)个点、次数不超过\(n\)的多项式是存在而且是唯一的</p>
<p>$$
p_{k}(x)=\prod_{i \in B_{k}} \frac{x-x_{i}}{x_{k}-x_{i}}
$$</p>
<blockquote>
<p>✅ 插值函数的<strong>自由度</strong> = <strong>未知量</strong>个数 - <strong>已知量</strong>个数<br />
条件数描述了解的稳定性，它与解的个数、自由度无关</p>
</blockquote>
<h3 id="问题"><a class="header" href="#问题">问题</a></h3>
<p>病态问题: 系数矩阵条件数高时, 求解不稳定</p>
<blockquote>
<p>系数矩阵即上面的 A。<br />
条件数指矩阵的奇异值中最大的与最小的之间的比例。</p>
</blockquote>
<h2 id="3-找哪个怎么找目标2"><a class="header" href="#3-找哪个怎么找目标2">3 找哪个？&amp;&amp;怎么找？目标2</a></h2>
<h3 id="目标-1"><a class="header" href="#目标-1">目标</a></h3>
<p>目标：函数尽量靠近数据点（<strong>逼近</strong>）</p>
<p><img src="Introduction/../assets/ML%E6%8B%9F%E5%90%88-2.png" alt="" /> </p>
<blockquote>
<p>✅ 由于设备误差、存储误差，导致数据不精确。<br />
因此曲线不必要一定经过点，而是靠近就可以。<br />
逼近是指，不要求\(y_i\)与\(f(x_i)\)严格相等，但希望误差尽量。</p>
</blockquote>
<p>$$
\min \sum_{i=0}^{n}\left(y_{i}-f\left(x_{i}\right)\right)^{2} 
$$</p>
<blockquote>
<p>✅ \((\cdot )^2\)是度量距离的一种方式。可替换。<br />
除了考虑距离是否合理，还要考虑是否好优化。<br />
因此\((\cdot )^2\)最常用。   　 </p>
</blockquote>
<h3 id="目标函数"><a class="header" href="#目标函数">目标函数</a></h3>
<p>把目标函数看作是以系数为参数的函数 G</p>
<p>$$
G (a_o, a_1,\dots, a_n) = {\textstyle \sum_{i=0}^{n}} (y_i-f(x_i))^2
$$</p>
<p>求 G 的极小值，即求它的拐点。</p>
<h3 id="最小二乘法求解"><a class="header" href="#最小二乘法求解">最小二乘法求解</a></h3>
<p>对各系数求导，得法方程(Normal Equation)<br />
$$
\frac{\partial G}{\partial a_1} = 0 \\
\frac{\partial G}{\partial a_2} = 0 \\
\cdots \\
\frac{\partial G}{\partial a_n} = 0 \\
$$</p>
<p>此方法称为<strong>最小二乘法</strong></p>
<h3 id="问题-1"><a class="header" href="#问题-1">问题</a></h3>
<ul>
<li>点多，系数少？</li>
</ul>
<blockquote>
<p>✅ 表达能力不够，欠拟合</p>
</blockquote>
<ul>
<li>点少， 系数多？</li>
</ul>
<blockquote>
<p>✅ 过拟合</p>
</blockquote>
<h2 id="recap插值-vs-逼近"><a class="header" href="#recap插值-vs-逼近">Recap：插值 VS. 逼近</a></h2>
<p><img src="Introduction/../assets/ML%E6%8B%9F%E5%90%88-3.png" alt="" /></p>
<blockquote>
<p>✅ 通常使用逼近而不插值</p>
</blockquote>
<h1 id="overfitting过拟合"><a class="header" href="#overfitting过拟合">Overfitting（过拟合）</a></h1>
<h2 id="欠拟合--过拟合"><a class="header" href="#欠拟合--过拟合">欠拟合 &amp; 过拟合</a></h2>
<p><img src="Introduction/../assets/3.PNG" alt="" /></p>
<p>过拟合可以达到误差为0，但是拟合的函数并无使用价值！</p>
<p>问：如何选择<strong>合适的基函数</strong>？<br />
答：需要根据不同的应用与需求，不断尝试（不断“<strong>调参</strong>”）</p>
<h2 id="避免过拟合的常用方法"><a class="header" href="#避免过拟合的常用方法">避免过拟合的常用方法</a></h2>
<blockquote>
<p>🔎 [1：08：47]</p>
</blockquote>
<p>• 数据去噪：剔除训练样本中噪声<br />
• 数据增广：增加样本数，或者增加样本的代表性和多样性<br />
• 模型简化：预测模型过于复杂，拟合了训练样本中的噪声。可选用更简单的模型，或者对模型进行裁剪<br />
• 正则约束：适当的<strong>正则项</strong>，比如方差正则项、稀疏正则项</p>
<blockquote>
<p>✅ 后面列举了常用正则项</p>
</blockquote>
<h3 id="正则项约束"><a class="header" href="#正则项约束">正则项约束</a></h3>
<p>选择一个函数空间，基函数的线性表达为：</p>
<p>$$
W=\left(w_{0}, w_{1}, \ldots, w_{n}\right)
$$</p>
<p>$$
y=f(x)=\sum_{i=0}^{n} w_{i} B_{i}(x)
$$</p>
<p>最小二乘拟合 </p>
<p>$$
\min _{W}||Y-X W||^{2}
$$</p>
<h4 id="ridge-regression岭回归"><a class="header" href="#ridge-regression岭回归"><strong>Ridge regression</strong>（<strong>岭回归</strong>）</a></h4>
<p>$$ 
\min_{W}||Y -XW\left |  \right | ^2+\mu|| W|| ^2_2
$$</p>
<h4 id="稀疏学习稀疏正则化"><a class="header" href="#稀疏学习稀疏正则化">稀疏学习：稀疏正则化</a></h4>
<p>已知冗余基函数（过完备），通过优化来选择合适的基函数，即让系数向量的\( L_0 \)模（ <strong>非0元素个数</strong>）尽量小，以此<strong>挑选</strong>（“<strong>学习</strong>”）出合适的基函数</p>
<blockquote>
<p>[1:10:14]过完备：基函数过冗余或线性相关。</p>
</blockquote>
<p>$$
\min_{a} \left |  \right |Y -XW\left |  \right | ^2+\mu|| W|| _0
$$</p>
<p>$$
\min_{a}\left |  \right | Y -XW\left |  \right | ^2,s.t|| W || _0\le \beta<br />
$$</p>
<blockquote>
<p>✅ \(||W||_0\)表示 W 中的非零元素个数<br />
最小化\(||W||_0\)（优化问题）或把它限制在可接受范围内（约束问题）<br />
公式一是优化问题、公式二是约束问题。</p>
</blockquote>
<h3 id="压缩感知"><a class="header" href="#压缩感知">压缩感知</a></h3>
<p><img src="Introduction/../assets/ML%E5%8E%8B%E7%BC%A9-1.png" alt="" /></p>
<p>已知\(y\)和\(Φ \)，有无穷多解\(x\)<br />
在一定条件下 (on Φ)，对于<strong>稀疏</strong>信号\(x\)，可通过优化能完全<strong>重建</strong>\(x\)</p>
<blockquote>
<p>🔎 [Candes and Tao 2005]</p>
</blockquote>
<p>\(L_0 \)优化：</p>
<p>$$
\min ||x||_0\\
s.t. Φx=y
$$</p>
<blockquote>
<p>🔎 [1：13：20]<br />
✅ 已知信号 \(x\) 是高维稀疏的,通过采样矩阵\(\phi\)作用于\(x \)可得到低维向 \(y\),且根据y和\(\phi\)中恢复出\(x\)。<br />
压缩感知常用于信号采集。</p>
</blockquote>
<h1 id="思考非函数型的曲线拟合"><a class="header" href="#思考非函数型的曲线拟合">思考：非函数型的曲线拟合？</a></h1>
<blockquote>
<p>🔎 [1：15：40]</p>
</blockquote>
<p><img src="Introduction/../assets/4.PNG" alt="" /></p>
<blockquote>
<p>✅ 一个 \(x\) 对应多个 \(y\) ,因此不是函数。 </p>
</blockquote>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。
https://caterpillarstudygroup.github.io/GAMES102_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="假定仅函数形式"><a class="header" href="#假定仅函数形式">假定：仅函数形式</a></h1>
<p>假定：仅函数形式，一般曲线（非函数形式）后面再学习</p>
<p>函数形式是指：</p>
<p>$$
f:R^1 \rightarrow R^1
$$</p>
<p>或</p>
<p>$$
y=f(x)
$$</p>
<blockquote>
<p>🔎 [03：55]<br />
✅ 曲线中每个x都对应一个\(y\)值，是函数函数形式的曲线。上面的公式是函数形式曲线的两种表达方式。</p>
</blockquote>
<p><img src="DataFitting/../assets/6.PNG" alt="" /></p>
<blockquote>
<p>✅ 这三个曲线是一般曲线</p>
</blockquote>
<h1 id="函数拟合问题"><a class="header" href="#函数拟合问题">函数拟合问题</a></h1>
<p>输入: 一些观察 (采样) 的数据点\((x_i,y_i)\)<br />
输出: 拟合数据点的函数\(y=f(x)\), 并用于<strong>预测</strong></p>
<p><img src="DataFitting/../assets/%E6%95%B0%E6%8D%AE-1.png" alt="" /></p>
<blockquote>
<p>函数拟合的目的：</p>
<ol>
<li>压缩：把大量采样点压缩成函数</li>
<li>预测：预测未采样的点</li>
</ol>
</blockquote>
<p>这种拟合函数有多少个？怎样判断拟合函数的“好坏”？</p>
<blockquote>
<p>🔎 [06：01]</p>
</blockquote>
<h2 id="方式一分段线性"><a class="header" href="#方式一分段线性">方式一：分段线性</a></h2>
<blockquote>
<p>🔎 [06：12]</p>
</blockquote>
<p><img src="DataFitting/../assets/7.PNG" alt="" /> </p>
<p>数据误差为\(0\)，但函数性质不够好：只有\(C^0\)连续，不光滑（数值计算）</p>
<blockquote>
<p>✅ \(C^0\)连续不可求导，会给后面的使用带来难度。<br />
离散几何研究这种函数，以目前的角度来看函数不好。</p>
</blockquote>
<h2 id="方式二光滑插值"><a class="header" href="#方式二光滑插值">方式二：光滑插值</a></h2>
<blockquote>
<p>🔎 [08：06]</p>
</blockquote>
<p><img src="DataFitting/../assets/8.PNG" alt="" /></p>
<p>数据误差为\(0\)，但可能被 “差数据” (噪声、<strong>outliers</strong>) 带歪, 导致函数性质不好、预测不可靠</p>
<h2 id="方式三逼近拟合"><a class="header" href="#方式三逼近拟合">方式三：逼近拟合</a></h2>
<p><img src="DataFitting/../assets/%E6%95%B0%E6%8D%AE-3.png" alt="" /></p>
<blockquote>
<p>🔎 [09：48]</p>
</blockquote>
<p>允许误差不为\(0\)，但要足够小，这样能抵抗噪声</p>
<h1 id="求拟合函数的应用驱动"><a class="header" href="#求拟合函数的应用驱动">求拟合函数的应用驱动</a></h1>
<p>大部分的实际应用问题 </p>
<ul>
<li>可建模为：找一个映射/变换/函数</li>
<li>输入不一样、变量不一样、维数不一样</li>
</ul>
<blockquote>
<p>求函数拟合一定要考虑应用背景，要有针对性地设计函数空间，否则只能靠试，就会很难了。</p>
</blockquote>
<h1 id="三步曲方法论"><a class="header" href="#三步曲方法论">三步曲方法论</a></h1>
<blockquote>
<p>🔎 [12：50]</p>
</blockquote>
<h2 id="到哪找"><a class="header" href="#到哪找"><strong>到哪找?</strong></a></h2>
<p>确定函数的表达形式 (函数集、空间)，一般是由基函数所张成的线性空间</p>
<blockquote>
<p>(1)确定某个函数集合（“池子”）<br />
(2)具有某种结构容易表达（比如线性函数空间）<br />
(3)尽量广泛（表达能力强）</p>
</blockquote>
<p>$$
L=span(b_0(x),\dots b_n(x))
$$</p>
<p>待定基函数的组合系数 (求解变量) </p>
<p>$$
f_\lambda (x)=\sum_{k=0}^{n} \lambda_ib_i(x)
$$</p>
<p>\(f\)由待定系数\(\lambda=\left
(\begin{array}{c}
\lambda_{1} \\
\ldots \\
\lambda_{n}
\end{array}\right) \)确定</p>
<blockquote>
<p>通常把求一个函数转化为一组系数的求解。<br />
基函数的选择决定了函数空间能拟合怎样的函数。</p>
</blockquote>
<h2 id="找哪个"><a class="header" href="#找哪个"><strong>找哪个</strong>?</a></h2>
<p>度量哪个函数是好的/“最好”的<br />
定义损失函数，包括数据误差项（逼近数据的度量）与正则项（对函数性质的度量）<br />
能量项 = 误差项 - 正则项</p>
<blockquote>
<p>正则项：对系数加约束就相当于对函数加约束。</p>
</blockquote>
<p>统计模型、规划模型...</p>
<h2 id="怎么找"><a class="header" href="#怎么找"><strong>怎么找</strong>?</a></h2>
<ul>
<li>
<p>线性问题<br />
线性问题，可转化为解线性方程或线性方程组的问题，例如：<br />
求解误差函数的驻点 (导数为 \(0 \)之处)，并转化为系数的方程组<br />
如果是欠定的 (有无穷多解)，则修正模型，例如改进/增加各种正则项:Lasso、岭回归、稀疏正则项…</p>
</li>
<li>
<p>非线性问题：</p>
<ul>
<li>凸问题：有理论保证</li>
<li>非凸问题：难！数值求解（ 梯度下降法、牛顿法、拟牛顿法、L‐BFGS, … ），须选择合适初值、步长等；一般要根据具体的优化问题形式及特点来设计合适的优化方法！</li>
</ul>
</li>
</ul>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。
https://caterpillarstudygroup.github.io/GAMES102_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="多项式插值定理"><a class="header" href="#多项式插值定理">多项式插值定理</a></h1>
<blockquote>
<p>🔎 [16：46]</p>
</blockquote>
<p>定理：若\(x_i\)两两不同，则对任意给定的\(y_i\)，存在唯一的次数至多是\(n\)次的多项式\(p_n\)，使得\(p_n(x)=y_i,i=0,\cdots,x^n\)。</p>
<blockquote>
<p>✅ 唯一的多项式p的意思是唯一的一组系数\(a_0, \cdots, a_n\)</p>
</blockquote>
<p>证明：在幂基\((1,x,\cdots,x^n)\)下待定多项式\(p\)的形式为：<br />
$$
p(x)=a_0+a_1x+a_2x^2+\cdots+a_nx^n
$$<br />
定理不限于幂基，下面证时过程只是以幂基为例<br />
由插值条件\(p(x_i)=y_i,i=0,\cdots,n\)得到如下方程组:</p>
<p><img src="DataFitting/../assets/10.PNG" alt="" /></p>
<blockquote>
<p>👆 如果基函数选取不一样,方程组的系数矩阵不同</p>
</blockquote>
<p>系数矩阵为Vandermonde矩阵，其行列式非零，因此方程组有唯一解。</p>
<blockquote>
<p>✅ 如果不使用幂基而是别的基函数，也能得到上述方程组并解出唯一解，只是矩阵的内容不同。<br />
要求解的系数是\(a_1,a_2, \cdots, a_n\),此处系数a是未知数，而不是通常理解的\(x\), \(x\) 代表输入，因此是已知量。</p>
</blockquote>
<h2 id="技巧1构造插值问题的通用解"><a class="header" href="#技巧1构造插值问题的通用解">技巧1：构造插值问题的通用解</a></h2>
<blockquote>
<p>🔎 [17：44] 
✅ 上一页方法中的问题：每次x或y变化都要构造一个公式来解。本页的目的是，只变y而x不变时不需要构造矩阵和解方程。</p>
</blockquote>
<p>给定  \(n+1\)个点  {\((x_0,y_0),\cdots,(x_n,y_n)\)}, 寻找一组次数为\(n\)的多项式基函数\(l_i\)使得</p>
<p>$$
l_i(x_j) = \begin{cases}
1, &amp; \text{ if } i=j \\
0, &amp; \text{ if } i\neq j
\end{cases}
$$</p>
<p>那么，插值问题的解为:<br />
$$
P(x)=y_{0} l_{0}(x)+y_{1} l_{1}(x)+\cdots+y_{n} l_{n}(x)=\sum_{i=0}^{n} y_{i} l_{i}(x)
$$</p>
<blockquote>
<p>✅ 这样做的好处是，即使y变化，也不用重新解方程组。\(l_i(x)\)可以通过上述方程组提前解出来，以\(y\)为系数对\(l_i(x)\)做线性组合，就可以得到\(P(x)\)<br />
多项式\(l_i(x)\)被称为拉格朗日多项式，即拉格朗日插值问题的通用解。<br />
该方法称为拉格朗日插值。<br />
给定\(n+1\)个点，通过上面的方法解方程组，可以解出\(l_i(x)\)系数，从而得到拟合函数。<br />
但 \(n+1\) 个点有任何一点改变，都要重新&quot;构造方程组→解系数→得拟合函数&quot;。<br />
该技巧对以上过程做简化。在 \(n+1\) 个定点的\(x\)不变而只有\(y\)的变­化的情况下，无须解方程而快速得到拟合函数。<br />
具体步骤为：<br />
2.先求拟合函数 \(l_i(x)\). 用上一页的方法。<br />
构造用于拟合\(l_i(x)\)的数据点。其中\(x_i\)为原给定的\(n+1\)个时,\(x_i\),\(y_i\)为公式(1)中的\(l_i(x_j)\)，这样给每个\(l_i(x)\)构造了\(n+1\)个用于拟合点。例如:<br />
\(n+1\)个点{\((x_0,1),(x_1,0)\dots ,(x_n,0)\)}导拟合函数\(l_0(x)\)<br />
这样就得到了\(n+1\)个函数\(l_i(x)\)<br />
在拟合\(l_i(x)\)的过程中只用到了原给定数据点的\(x\)而没有用 \(y\)。因此，只要x不变，\(l_i(x)\)函数就一直适用。<br />
要拟合的函数\(P(x)\)就成了\(l_i(x)\)的线性组合，\(y_i\)是系数。</p>
</blockquote>
<blockquote>
<p>💡 <strong>我的思考</strong>：<br />
根据 \(Aa=y\) 解出\(a\),得到拟合函数\(f(x)= A(x)\cdot a\)<br />
现在，先算出 \(A{a}' = E,根据Ey=y可知：A{a}'y=Aa\).<br />
因此得到拟合函数\(f(x)=A(x)a=A(x){a}' y\).<br />
<strong>结论</strong>：把计算的过程或目标分解，分析每一部分计算的依赖项。根据依赖项决定是否能提前算好。</p>
</blockquote>
<h3 id="怎么计算多项式l_ix"><a class="header" href="#怎么计算多项式l_ix">怎么计算多项式\(l_i(x)\)?</a></h3>
<p>\(n\)阶多项式,且有以下\(n\)个根 </p>
<p>$$
x_0,x_1,x_2,\cdots,x_{i-1} ,x_{i+1} ,\cdots,x_n
$$</p>
<p>故可表示为</p>
<p>$$
l_i(x) \\<br />
=C_{i}\left(x-x_{0}\right)\left(x-x_{1}\right) \ldots\left(x-x_{i-1}\right)\left(x-x_{i+1}\right) \ldots\left(x-x_{n}\right) \\
=C_{i} \prod_{j \neq i}\left(x-x_{j}\right) 
$$</p>
<p>由\(l_i(x_i)=1\)可得<br />
$$
1=c_{i} \prod_{j \neq i}\left(x_{i}-x_{j}\right) \Rightarrow c_{i}=\frac{1}{\prod_{j \neq i}\left(x_{i}-x_{j}\right)} 
$$</p>
<p>最终多项式基函数为<br />
$$
l_{i}(x)=\frac{\prod_{j \neq i}\left(x-x_{j}\right)}{\prod_{j \neq i}\left(x_{i}-x_{j}\right)}
$$</p>
<p>多项式\(l_i(x)\)被称为<strong>拉格朗日多项式</strong></p>
<h2 id="技巧2更方便的求解表达"><a class="header" href="#技巧2更方便的求解表达">技巧2：更方便的求解表达</a></h2>
<p>Newton插值：具有相同“导数”（差商）的多项式构造（\(n\)阶Taylor展开）</p>
<p><strong>定义：</strong><br />
一阶差商：</p>
<p>$$
f\left[x_{0}, x_{1}\right]=\frac{f\left(x_{1}\right)-f\left(x_{0}\right)}{x_{1}-x_{0}}<br />
$$</p>
<p>\(k\)阶差商:</p>
<p>设{\(x_0,x_1,\cdots,x_k\)}互不相同,\(f(x)\)关于{\(x_0,x_1,\cdots,x_k\)}的\(k\)阶差商为:</p>
<p>$$
f\left[x_{0}, x_{1}, \cdots, x_{k}\right]=\frac{f\left[x_{1}, \cdots, x_{k}\right]-f\left[x_{0}, x_{1}, \cdots, x_{k-1}\right]}{x_{k}-x_{0}}<br />
$$</p>
<p>所以<strong>Newton插值多项式</strong>表示为： 
$$
N_{n}(x)=f\left(x_{0}\right)+f\left[x_{0}, x_{1}\right]\left(x-x_{0}\right)+\cdots+f\left[x_{0}, x_{1}, \cdots, x_{n}\right]\left(x-x_{0}\right) \cdots\left(x-x_{n-1}\right)
$$</p>
<blockquote>
<p>🔎 [19：23]<br />
❓ 这里也没听懂？意思是预算出的有阶的差商？</p>
</blockquote>
<h1 id="多项式插值存在的问题"><a class="header" href="#多项式插值存在的问题">多项式插值存在的问题</a></h1>
<h2 id="系统矩阵稠密"><a class="header" href="#系统矩阵稠密">系统矩阵稠密</a></h2>
<p>例如Vandermonde矩阵，处处非零元素</p>
<blockquote>
<p>✅ 稀疏矩阵的优势：有好的迭代方法，计算很快.<br />
eigen库：非常有名的数学库</p>
</blockquote>
<h2 id="病态问题"><a class="header" href="#病态问题">病态问题</a></h2>
<p>依赖于基函数选取，矩阵可能病态，导致难于求解（求逆）</p>
<h3 id="病态矩阵示例"><a class="header" href="#病态矩阵示例">病态矩阵示例</a></h3>
<p>考虑二元方程组，解为\((1,1)\)<br />
$$<br />
x_{1}+0.5 x_{2}=1.5 
$$</p>
<p>$$
0.667 x_{1}+0.333 x_{2}=1 
$$</p>
<p>对第二个方程右边项扰动0.001，解为  (0,3) 
$$<br />
x_{1}+0.5 x_{2}=1.5 
$$</p>
<p>$$
0.667 x_{1}+0.333 x_{2}=0.999
$$</p>
<p>对矩阵系数进行扰动，解为(2,-1)<br />
$$
x_{1}+0.5 x_{2}=1.5
$$</p>
<p>$$
0.667 x_{1}+0.334 x_{2}=1 
$$</p>
<blockquote>
<p>✅ 对系数矩阵或\(y\)向量做微小的扰动，其解的变化会非常大。</p>
</blockquote>
<p><strong>输入数据的细微变化导致输出（解）的剧烈变化</strong></p>
<p>将线性方程看成直线（超平面），当系统病态时，直线变为近似平行，求解（即直线求交）变得困难、不精确</p>
<h3 id="矩阵条件数"><a class="header" href="#矩阵条件数">矩阵条件数</a></h3>
<p>$$
\kappa_{2}(A)=\frac{\max _{x \neq 0} \frac{|A x|}{|x|}}{\min _{x \neq 0} \frac{|A x|}{|x|}}
$$</p>
<p>矩阵条件数等于矩阵最大特征值和最小特征值之间比例，条件数大意味着基元之间有太多相关性，造成不稳定。</p>
<h3 id="范德蒙矩阵的条件数"><a class="header" href="#范德蒙矩阵的条件数">范德蒙矩阵的条件数</a></h3>
<p>多项式插值问题是病态的，因为对于等距分布的数据点\(x_i\),<strong>范德蒙矩阵的条件数随着数据点数\(n\)呈指数级增长</strong>（多项式的最高次数为\(n-1\)）</p>
<blockquote>
<p>✅ 多项式插值如果使用了高阶的基函数，就容易出现病态问题</p>
</blockquote>
<p>因为幂（单项式）函数基的特点是，幂函数之间差别随着次数增加而减小，不同幂函数之间唯一差别为增长速度（\(x^i\)比 \(x^{i-1}\)增长快）</p>
<blockquote>
<p>🔎 [26：31]<br />
✅ 幂函数基，高阶后函数变化非常快，那么结果就会被幂底严重挠动</p>
</blockquote>
<h3 id="解决方法"><a class="header" href="#解决方法">解决方法</a></h3>
<p>好的基函数一般需要系数交替，且互相抵消问题，例如：<br />
<img src="DataFitting/../assets/%E6%8F%92%E5%80%BC-4.png" alt="" /></p>
<blockquote>
<p>基之间互相抵消，函数就不会一直增长。<br />
[?] 秦九韶算法</p>
</blockquote>
<p>可使用正交多项式基。可通过Gram‐Schmidt正交化获得正交多项式基。</p>
<h2 id="振荡runge现象"><a class="header" href="#振荡runge现象">振荡(Runge)现象</a></h2>
<p><img src="DataFitting/../assets/%E6%8F%92%E5%80%BC-5.png" alt="" /></p>
<h1 id="结论"><a class="header" href="#结论">结论</a></h1>
<p>多项式插值存在以下问题：</p>
<ul>
<li>多项式插值不稳定，控制点的微小变化可导致完全不同的结果</li>
<li>振荡(Runge)现象，多项式随着插值点数(可以是细微)增加而摆动</li>
</ul>
<p>因此需要更好的基函数来做插值，例如Bernstein基函数、分片多项式</p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。
https://caterpillarstudygroup.github.io/GAMES102_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="为什么逼近"><a class="header" href="#为什么逼近">为什么逼近？</a></h1>
<p>用逼近代替插值的优点：<br />
• 数据点含噪声、outliers等<br />
• 更紧凑的表达<br />
• 计算简单、更稳定</p>
<p><img src="DataFitting/../assets/%E6%8F%92%E5%80%BC-7.png" alt="" /></p>
<h1 id="逼近问题"><a class="header" href="#逼近问题">逼近问题</a></h1>
<p>给定一组线性无关的连续函数集合\(B\)={\(b_1, \ldots b_n\)}和一组结点{\((x_1, y_1)\), ...,\((x_m, y_m)\)}, 其中\(m&gt;n\)。<br />
在\(B\)张成空间中哪个函数\(f\in\operatorname{span}(B)\)对结点逼近最好?</p>
<blockquote>
<p>🔎 [31：38]</p>
</blockquote>
<h2 id="最佳逼近"><a class="header" href="#最佳逼近">最佳逼近</a></h2>
<p>最小二乘逼近</p>
<p>$$
\underset{f \in \operatorname{span}(B)}{\operatorname{argmin}} \sum_{j=1}^{m}\left(f\left(x_{j}\right)-y_{j}\right)^{2}
$$</p>
<blockquote>
<p>公式是关于系数\((\lambda _1,\lambda _2,\dots ,\lambda _n,)\)的函数，直接求极小值的闭式解。</p>
</blockquote>
<p>$$
\sum_{j=1}^{m}\left(f\left(x_{j}\right)-y_{j}\right)^{2}=\sum_{j=1}^{m}\left(\sum_{i=1}^{n} \lambda_{i} b_{i}\left(x_{j}\right)-y_{j}\right)^{2}
$$</p>
<p>$$
=(M \lambda-y)^{T}(M \lambda-y)
$$</p>
<p>$$
=\lambda^{T} M^{T} M \lambda-y^{T} M \lambda-\lambda^{T} M^{T} y+y^{T} y
$$</p>
<p>$$
=\lambda^{T} M^{T} M \lambda-2y^{T} M\lambda +y^{T} y
$$</p>
<p>$$
M=\left(\begin{array}{ccc}
b_{1}\left(x_{1}\right) &amp; \ldots &amp; b_{n}\left(x_{1}\right) \\
\ldots &amp; \ldots &amp; \ldots \\
b_{1}\left(x_{m}\right) &amp; \ldots &amp; b_{n}\left(x_{m}\right)
\end{array}\right)
$$</p>
<h2 id="求解"><a class="header" href="#求解">求解</a></h2>
<p>上页公式可转化为关于\(\lambda\)的二次多项式<br />
$$
\lambda^{T} M^{T} M \lambda-2 y^{T} M \lambda+y^{T} y 
$$</p>
<p>求公式的法方程，可得使公式达到最小值，其解应满足：</p>
<p>$$
M^{T} M \lambda=M^{T} \mathrm{y}<br />
$$</p>
<p>提示<br />
－ 最小化二次目标函数\(x^TAx+b^Tx+c \)<br />
－ 充分必要条件:\(2Ax=-b\)</p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。
https://caterpillarstudygroup.github.io/GAMES102_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="多项式的优点与缺点"><a class="header" href="#多项式的优点与缺点">多项式的优点与缺点</a></h1>
<blockquote>
<p>这种类似于\(\sum a_if_i(x)\)的形式都叫多项式，根据\(f_i(x)\)的不同的定义，会成为不同的多项。例如以幂函数为基的是幂基多项式，比Berstein为基的是Bertein多项式。</p>
</blockquote>
<h2 id="优点"><a class="header" href="#优点">优点</a></h2>
<ol>
<li>易于计算, 表现良好, 光滑, ...</li>
<li><strong>表达能力足够!</strong><br />
魏尔斯特拉斯Weierstrass定理:令\(f\)为闭区间\([a, b]\)上任意连续函数, 则对任意给\(\varepsilon\), 存在\(n\)和<strong>多项式</strong>\(P_n\)使得</li>
</ol>
<p>$$
\left|f(x)-P_{n}(x)\right|&lt;\varepsilon, \forall x \in[a, b]
$$</p>
<blockquote>
<p>翻译成人话是：\(Pn(x)\)可以在一定误差内拟合任意\(f(x)\)。只要n足够大。<br />
这里\(x的范围区间是[a,b]，通常考虑[0,1]\)</p>
</blockquote>
<p><em>Weierstrass只证明了存在性,未给出多项式</em></p>
<h1 id="bernstein多项式"><a class="header" href="#bernstein多项式">Bernstein多项式</a></h1>
<h2 id="完备性"><a class="header" href="#完备性">完备性</a></h2>
<p>伯恩斯坦Bernstein给出了Bernstein的完备性证明：<br />
对\([0,1]\)区间上任意连续函数\(f(x)\)和任意正整数\(n\), 以下不等式对所有\(x\in[0,1]\)成立</p>
<p>$$
|f(x)-B_n(f,x)|&lt;\frac{9}{4} m_{f,n}
$$</p>
<p>\(m_{f,n}\)=lower upper bound of |\(f(y_1)-f(y_2)\)|</p>
<p>\(y_1, y_2\in[0,1] \)  且|\(y_1-y_2\)|&lt;\(\frac{1}{\sqrt{n}} \)</p>
<p>$$
B_n(f, x)=\sum_{j=0}^{n} f(x_j) b_{n, j}(x)
$$</p>
<p>其中\(x_j\) 为[\(0,1\)]上等距采样点，\(b_{n,j}\)为Bernstein基</p>
<p>$$
b_{n,j} = \binom{n}{j} x^j (1-x)^{n-j}
$$</p>
<blockquote>
<p>\(\binom{n}{j}相当于{\textstyle C_{n}^{j}} \),排列组合的意思。 </p>
</blockquote>
<h2 id="bernstein基"><a class="header" href="#bernstein基">Bernstein基</a></h2>
<p><img src="DataFitting/../assets/%E5%A4%9A%E9%A1%B9%E5%BC%8F-1.png" alt="" /></p>
<ul>
<li>\(b_{0,0}(x)=1\)</li>
<li>\(b_{0,1}(x)=1-x, b_{1,1}=x\)</li>
<li>\(b_{0,2}(x)=(1-x)^2, b_{1,2}=2x(1-x),b_{2,2}=x^2\)</li>
<li>\(b_{0,3}(x)=(1-x)^3,b_{1,3}=3x(1-x)^2, b_{2,3}=3x^2(1-x),b_{3,3}=x^3\)</li>
<li>\(b_{0,4}(x)=(1-x)^4,b_{1,4}=4x(1-x)^3,b_{2,4}=6x^2(1-x)^2, b_{3,4}=4x^3(1-x),b_{4,4}=x^4\)</li>
</ul>
<blockquote>
<p>🔎 [36：40]<br />
✅ 矩阵的本质：在不同的基函数空间做变换<br />
6张图分别是0-5次的 Bernstein 基。</p>
</blockquote>
<h2 id="bernstein多项式的优点"><a class="header" href="#bernstein多项式的优点">Bernstein多项式的优点</a></h2>
<p>Bernstein基函数的良好性质：</p>
<ul>
<li>非常好的几何意义！</li>
<li>正性、权性（和为1）\(\Rightarrow \)凸包性</li>
</ul>
<blockquote>
<p>权性。上面图中，任意画一条竖线，线上点的\(y\)值和为1<br />
[?] 什么是凸包性？为什么有权性就有凸包性？<br />
为什么凸包性就计算稳定？ </p>
</blockquote>
<ul>
<li>变差缩减性</li>
<li>递归线性求解方法</li>
<li>细分性</li>
<li>…</li>
</ul>
<blockquote>
<p>🔎 丰富的理论：CAGD 课程</p>
</blockquote>
<h1 id="关于bernstein函数的两种观点"><a class="header" href="#关于bernstein函数的两种观点">关于Bernstein函数的两种观点</a></h1>
<blockquote>
<p>🔎 [46：17]</p>
</blockquote>
<p><img src="DataFitting/../assets/13.PNG" alt="" /></p>
<p>$$
B_{n}(f, x)=\sum_{j=0}^{n} f\left(\frac{i}{n}\right) b_{n, j}(x)
$$ </p>
<blockquote>
<p>\(f(x)\)是一个离散函数， \(f(\frac{i }{n} )\)为\(x\)为第i个采样点时\(f(x)\)的值，因此 \(f(\frac{i}{n} )\)代表能有采样点。</p>
</blockquote>
<p>红色实际上是基于蓝点画的 Bezier 曲线。</p>
<h2 id="代数观点"><a class="header" href="#代数观点">代数观点</a></h2>
<p>蓝色为采样点\(f(\frac{i}{n} )\)，\(b_{n,j}(x) \)是系数，用系组来组合采样点。 红色为拟合曲线\(B_n (f,x)\)。当采样点足够多时\(n\to \infty\)，得到\(f(x)逼近 B_n (f,x)\)    红线逼近蓝点。</p>
<h2 id="几何观点"><a class="header" href="#几何观点">几何观点</a></h2>
<p>\(f(\frac{i}{n})\)是系数，\(bn_1,j(x)\)是基函数，用系数来组合基函数，得到新的函数。</p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。
https://caterpillarstudygroup.github.io/GAMES102_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gauss函数"><a class="header" href="#gauss函数">Gauss函数</a></h1>
<blockquote>
<p>✅ 一维 RBF 称为 Gauss 函数</p>
</blockquote>
<p>$$
g_{\mu ,\sigma } = \frac{1}{\sqrt{2\pi } } e^{-\frac{(x-\mu )^{2} }{2\sigma ^{2} } } 
$$</p>
<p><img src="DataFitting/../assets/20.PNG" alt="" /></p>
<p>几何意义：<br />
• 均值\(\mu\):位置<br />
• 方差\(\sigma\)：宽度</p>
<p><strong>不同µ和\(\sigma\)的 Gauss 函数都线性无关.</strong> 有什么启发？</p>
<blockquote>
<p>各个线性无关的 Gauss 函数，可以张成一个空间。用 Gauss 函数作为基函数</p>
</blockquote>
<h1 id="rbf函数拟合"><a class="header" href="#rbf函数拟合">RBF函数拟合</a></h1>
<p>$$
f(x) = b_0 + \sum b_ig_i(x)
$$</p>
<p><img src="DataFitting/../assets/14.PNG" alt="" /></p>
<blockquote>
<p>🔎 [47：44]<br />
有\(n\)个采样点，分别以每个点的x值为µ.生成Gauss函数作为 RBF基。<br />
\(b_0\)为上下偏移，可以来自先验，也可以是某种约束。 </p>
</blockquote>
<h1 id="思考"><a class="header" href="#思考">思考：</a></h1>
<p>\(\sigma \) 取什么值能得到比较好的结果？<br />
均值\(\mu\)和方差\(\sigma\)是否可以一起来优化？</p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。
https://caterpillarstudygroup.github.io/GAMES102_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="标准gauss函数的变换"><a class="header" href="#标准gauss函数的变换">标准Gauss函数的变换</a></h1>
<p>一般Gauss函数表达为标准Gauss函数的形式，即</p>
<p>$$
g_{0,1}(x) = \frac{1}{\sqrt{2\pi } } e^{-\frac{x^{2} }{2} }
$$</p>
<p>把任意 Gauss 函数 \(g_{\mu,\sigma}(x)\)中的x做平移与缩放，使之成为 std Gauss 函数，即：
$$
g_{\mu,\sigma}(x) \Rightarrow g_{0,1}(x') 
$$</p>
<p>$$
g_{\mu ,\sigma } (x)= \frac{1}{\sqrt{2\pi } } e^{-\frac{(x-\mu )^{2} }{2\sigma ^{2} } } =\frac{1}{\sqrt{2\pi } } e^{-\frac{1}{2}(\frac{x}{\sigma } -\frac{\mu }{\sigma } )^2} =g_{0,1 } (ax+b)
$$</p>
<p>通过以上推导得：<br />
$$
x'=ax+b
$$</p>
<p>$$
a=\frac{1}{\sigma },b=\frac{\mu }{\sigma }<br />
$$</p>
<p>RBF由各种不同的Gauss函数线性组合而成，
用这种变换形式来描述RBF函数：</p>
<p>$$
f(x)=b_{0}+\sum_{i=1}^{n} b_{i} g_{i}(x)
$$</p>
<p><strong>各种不同的Gauss基函数是由一个标准Gauss函数通过平移和伸缩变换而来的</strong>，因此RBF就可以写成这样：</p>
<p>$$
f(x)=\omega_{0}+\sum_{i=1}^{n} \omega_{i} g_{0,1}\left(a_{i} x+b_{i}\right)
$$</p>
<h1 id="换个方式看函数"><a class="header" href="#换个方式看函数">换个方式看函数</a></h1>
<h2 id="神经网络"><a class="header" href="#神经网络">神经网络</a></h2>
<p>将Gauss函数看成网络</p>
<p>$$
f(x)=\omega_{0}+\sum_{i=1}^{n} \omega_{i} g_{0,1}\left(a_{i} x+b_{i}\right)
$$</p>
<p>RBF函数可以画成这样：</p>
<p><img src="DataFitting/../assets/2-5-22.png" alt="" /></p>
<blockquote>
<p>👆 [58:00] 用神经网络来描述RBF公式<br />
✅ 其中\(\omega_0, \omega_i, a_i, b_i\)都是待优化的函数。 
当n足够多时，f(x)可以逼近任何函数。<br />
\(x\) 本身一维，考虑到平移，再升一维。隐层的1是指基函数线性组合后整体增加一个平移。<br />
在这里， std gauss 相当于激活函数。连接线上的数值 \((a_i,b_i,\omega _i)\)是网络参数。\(n\)对应网络隐层的结点个数，需要手调。</p>
</blockquote>
<h2 id="神经元"><a class="header" href="#神经元">神经元</a></h2>
<p><img src="DataFitting/../assets/15.PNG" alt="" /></p>
<p><strong>一个神经网络就是一个函数</strong></p>
<blockquote>
<p>💡 从传统机器学习到神经网络，这是我见过的最好的解释。<br />
✅ 参数的初值很重要，最好能根据物理意义找到初值。</p>
</blockquote>
<h2 id="rbf-神经网络"><a class="header" href="#rbf-神经网络">RBF 神经网络</a></h2>
<p>RBF (Radial Basis Function)，径向基函数，是高维的高斯函数。</p>
<blockquote>
<p>RBF 神经网络的问题是，关于 \(a,b\) 的导数难求，高阶且非凸，
难以优化。只能找局部最小，因此初值很重要。</p>
</blockquote>
<p>核函数思想</p>
<blockquote>
<p>没解释</p>
</blockquote>
<p>Gauss函数的特性：拟局部性</p>
<blockquote>
<p>没解释</p>
</blockquote>
<h1 id="guass拟合函数的进化"><a class="header" href="#guass拟合函数的进化">Guass拟合函数的进化</a></h1>
<h2 id="激活函数的选择"><a class="header" href="#激活函数的选择">激活函数的选择？</a></h2>
<p>启发：<strong>由一个简单的函数通过（仿射）变换构造出一组基函数，张成一个函数空间</strong></p>
<p>关键是基函数的表达能力是否足够强：是否完备/稠密的？</p>
<p><img src="DataFitting/../assets/2-5-5.png" alt="" /></p>
<blockquote>
<p>机器学习的本质是在做拟合。</p>
</blockquote>
<h2 id="高维情形多元函数"><a class="header" href="#高维情形多元函数">高维情形：多元函数</a></h2>
<blockquote>
<p>🔎 见【多元函数】，<a href="https://caterpillarstudygroup.github.io/GAMES102_mdbook/ParametricFitting/Multi.html">link</a></p>
</blockquote>
<p>变量的多个分量的线性组合</p>
<p>$$
(x_1,x_2,...,x_n)\longrightarrow g_{0,1}(a^i_1x_1+a^i_2x_2+...+a^i_nx_n+b_i)
$$</p>
<p>单隐层神经网络函数： </p>
<p>$$
f(x_1,x_2,...,x_n) = \omega_{0}+\sum_{i=1}^{n} \omega_{i} g_{0,1}(a^i_1x_1+a^i_2x_2+...+a^i_nx_n+b_i)
$$</p>
<blockquote>
<p>高维只是在输入层，输出层纵向多加几个圈<br />
共享基函数，使用不同的系数</p>
</blockquote>
<h2 id="多层神经网络多重复合的函数"><a class="header" href="#多层神经网络多重复合的函数">多层神经网络：多重复合的函数</a></h2>
<p>线性函数和非线性函数的多重复合</p>
<p><img src="DataFitting/../assets/2-5-8.png" alt="" /></p>
<p>$$
a_1^{(2)}=f(W_{11}^{(1)} x_1+W_{12}^{(1)}x_2+W_{13}^{(1)} x_3+b_1^{(1)})
$$</p>
<p>$$
a_2^{(2)}=f(W_{21}^{(1)} x_1+W_{22}^{(1)} x_2+W_{23}^{(1)} x_{3}+b_{2}^{(1)})
$$</p>
<p>$$
a_{3}^{(2)}=f(W_{31}^{(1)} x_{1}+W_{32}^{(1)} x_{2}+W_{33}^{(1)} x_{3}+b_{3}^{(1)}) 
$$</p>
<p>$$
h_{W, b}(x) =a_{1}^{(3)}=f(W_{11}^{(2)} a_{1}^{(2)}+W_{12}^{(2)} a_{2}^{(2)}+W_{13}^{(2)} a_{3}^{(2)}+b_{1}^{(2)})
$$</p>
<blockquote>
<p>通常每层使用相同的激活函数，方便优化<br />
增加网络的深度和宽度，都会极大膨胀参数个数<br />
同样参数量级下，通常深的比宽的好，因为深的自由度更高</p>
</blockquote>
<h1 id="用神经网络函数来拟合数据"><a class="header" href="#用神经网络函数来拟合数据">用神经网络函数来拟合数据</a></h1>
<p><img src="DataFitting/../assets/2-5-9.png" alt="" /></p>
<p>Regression problem<br />
Input: Given training set \((x_1,y_1), (x_2,y_2),(x_3, y_3)\),….<br />
Output: Adjust <strong>parameters</strong> \(0\)(for every node)to make:
$$
h(x_i)\approx y_i
$$</p>
<p>$$
F(X)=\sum_{i=1}^{N} v_i\varphi (W^T_iX+b_i)
$$</p>
<blockquote>
<p>❓ Why it works?<br />
答：只要网络足够大，参数足够大，就能逼近任意函数。</p>
</blockquote>
<blockquote>
<p>❗ 存在的问题
<strong>与传统拟合一样存在同样的问题：</strong> 函数个数如何选？!<br />
调参！</p>
</blockquote>
<h1 id="使用深度学习的方法"><a class="header" href="#使用深度学习的方法">使用深度学习的方法</a></h1>
<p>问题建模：理解问题、问题分解（多个映射级联）…</p>
<ul>
<li>找哪个？<br />
• 损失函数、各种Penalty、正则项…</li>
<li>到哪找？<br />
• 神经网络函数、网络简化…</li>
<li>怎么找？<br />
• 优化方法（BP方法）<br />
• 初始值、参数…</li>
</ul>
<p><strong>调参：有耐心、有直觉…</strong></p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。
https://caterpillarstudygroup.github.io/GAMES102_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="回顾"><a class="header" href="#回顾">回顾</a></h1>
<p>数据拟合：<a href="https://caterpillarstudygroup.github.io/GAMES102_mdbook/DataFitting/DataFitting.html">link</a></p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。
https://caterpillarstudygroup.github.io/GAMES102_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="多元函数多变量"><a class="header" href="#多元函数多变量">多元函数（多变量）</a></h1>
<p>$$
f: R^n \rightarrow R^1
$$</p>
<p>$$
\begin{pmatrix}x_1
\\\vdots 
\\x_n
\end{pmatrix}
\rightarrow y
$$</p>
<p>$$
y = f(x_1,x_2, \cdots, x_n)
$$</p>
<p>例子：通过升级实现二元函数的可视化
$$
z=f(x,y),(x,y)\in[0,1]\times[0,1]
$$</p>
<p><img src="ParametricFitting/../assets/%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0-1.png" alt="" /></p>
<h1 id="二元函数的基函数构造"><a class="header" href="#二元函数的基函数构造">二元函数的基函数构造</a></h1>
<p><strong>张量积</strong>，即用两个一元函数的基函数的相互乘积来定义，</p>
<p>例1：二次二元多项式函数\(z=f(x,y)\)的基函数{\(1,x,y,x^2,xy,y^2\)}</p>
<blockquote>
<p>✅ [10:23] 例子中幂基最高为二次，因此只取不超过二次的项。</p>
</blockquote>
<p>例2： 以任意函数为基函数</p>
<p><img src="ParametricFitting/../assets/18.PNG" alt="" /></p>
<blockquote>
<p>👆 [11:22] 例子：任意基。横轴和竖轴可以用不同的函数，但很少这样做。</p>
</blockquote>
<h1 id="多元函数的基函数构造"><a class="header" href="#多元函数的基函数构造">多元函数的基函数构造</a></h1>
<h2 id="多元函数的张量积定义"><a class="header" href="#多元函数的张量积定义">多元函数的张量积定义</a></h2>
<p>优点：<strong>定义简单，多个一元基函数的乘积形式</strong><br />
不足：随着维数增加，基函数个数急剧增加，导致<strong>变量急据增加</strong></p>
<blockquote>
<p>求解系统规模急剧增加、求解代价大、占用内存空间大</p>
</blockquote>
<h2 id="多元函数的神经网络表达"><a class="header" href="#多元函数的神经网络表达">多元函数的神经网络表达</a></h2>
<p>用一个单变量函数\(\sigma (x)\)（称为激活函数）的不同仿射变换来构造 “基函数”：<strong>基函数数目可控</strong><br />
$$
y=f(x_1,x_2,...,x_n)
$$
$$
=w_0+\sum_{j-1}^{m} w_j\sigma (a_j^1x_1+...a_j^ix_i+...+a_j^nx_n+b_j)
$$</p>
<p><img src="ParametricFitting/../assets/%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0-4.png" alt="" /></p>
<blockquote>
<p>🔎 [16:12]<br />
✅ 神网络方式的优点：<br />
（1）可以解决张量积方式的维数膨胀问题，因为张量积的维度是指数级增长，而神经网络的\(m\)可以控制。<br />
（2）有统一的优化方法和优化框架<br />
❗ 存在的问题：仍需要调参</p>
</blockquote>
<blockquote>
<p>💡 <strong>我的思考</strong><br />
能用低维的神经网络代替高维的张量积，是因为，虽然张量积的各维­度独立，但它对于要拟合的数据来说是有冗余的。<br />
神经网络 hidden layer 的本质，把\(n\)维空间的点映射到m维空间的点，网络学习点在不同维度空间中的性质。</p>
</blockquote>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。
https://caterpillarstudygroup.github.io/GAMES102_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="向量值函数"><a class="header" href="#向量值函数">向量值函数</a></h1>
<h2 id="定义"><a class="header" href="#定义">定义</a></h2>
<blockquote>
<p>🔎 [24:41]</p>
</blockquote>
<p>函数的\(x\)称为变量，\(y\)称为值。如果函数的值是一个高维空间的点，或者说y是一个向量，则称为向量值函数。<br />
x和y又分别称为自变量和应变量，因此向量值函数是多个应变量的函数。<br />
\(m\) 维向量值函数可以看作最是\(m\)个相互无关的普通函数</p>
<h2 id="拟合方法"><a class="header" href="#拟合方法">拟合方法</a></h2>
<p>看成多个单变量函数，各个函数<strong>独立无关</strong>，一般会用同样的基函数（<strong>共享基函数</strong>）</p>
<p>$$
\begin{cases}
y_1=f_1(x)\\
\vdots  \\
y_m=f_m(x)
\end{cases}
$$</p>
<blockquote>
<p>✅ f1, f2, ..., fm是基于同一基函数但具有不同系数的函数。</p>
</blockquote>
<h1 id="向量值函数举例"><a class="header" href="#向量值函数举例">向量值函数举例</a></h1>
<h2 id="平面空间参数曲线"><a class="header" href="#平面空间参数曲线">平面/空间参数曲线</a></h2>
<h3 id="单变量"><a class="header" href="#单变量">单变量</a></h3>
<p>$$
f:R^1 → R^m 
$$ </p>
<p>$$
x →\begin{pmatrix}y_1
\\\vdots 
\\y_m
\end{pmatrix}
$$</p>
<p>几何解释：一个实数\(𝑥∈𝑅^1\)映射到𝑚维空\(𝑅^m\)的一个点，轨迹构成\(𝑅^m\)的一条“曲线” ，但本质维度为1</p>
<blockquote>
<p>🔎 [26:37]图</p>
</blockquote>
<p><img src="ParametricFitting/../assets/%E5%90%91%E9%87%8F-1.png" alt="" /></p>
<blockquote>
<p>曲线的嵌入空间是高维，本质维度为1
把\(x\)的取值范围归一化到 [0，1]，那么任意一个\(x\)值对应[0，1]上的一个点。
\(x 从 0 走到 1，y\)在高维空间中画出一条弧线。</p>
</blockquote>
<h3 id="特例平面参数曲线"><a class="header" href="#特例平面参数曲线">特例：平面参数曲线</a></h3>
<p>$$
f:R^1 → R^2 
$$ </p>
<p>$$
\begin{cases}
x=x(t)\\
y=y(t)
\end{cases}
$$</p>
<p>$$
t\in [0,1]
$$</p>
<p><img src="ParametricFitting/../assets/%E5%90%91%E9%87%8F-2.png" alt="" /> </p>
<blockquote>
<p>在这一页中， \(t 是变量，(x,y)\)是值　　</p>
</blockquote>
<h3 id="特例空间参数曲线"><a class="header" href="#特例空间参数曲线">特例：空间参数曲线</a></h3>
<p>$$
f:R^1 → R^3 
$$ </p>
<p>$$
\begin{cases}
x=x(t) \\
y=y(t)  \\
z=z(t)
\end{cases}
$$</p>
<p>$$
t\in [0,1]
$$</p>
<p><img src="ParametricFitting/../assets/%E5%90%91%E9%87%8F-3.png" alt="" /></p>
<h2 id="参数曲面"><a class="header" href="#参数曲面">参数曲面</a></h2>
<p>$$
f:R^2 → R^3 
$$ </p>
<p>$$
\begin{cases}
x=x(u,v) \\
y=y(u,v)  \\
z=z(u,v)
\end{cases}
$$</p>
<p>$$
(u,v)\in [0,1]\times [0,1]
$$</p>
<p>几何解释：<br />
• 一张曲面由两个参数\((u,v)\)决定，也称为双参数曲面<br />
• 可灵活表达非函数型的任意曲面</p>
<p><img src="ParametricFitting/../assets/%E5%90%91%E9%87%8F-4.png" alt="" /></p>
<blockquote>
<p><strong>流形</strong>：任意一个点的无穷小区域，等价于二维平面的圆盘<br />
[32:28] 三维流形曲面，本质上是二维。</p>
</blockquote>
<h2 id="二维映射"><a class="header" href="#二维映射">二维映射</a></h2>
<p>$$
f:R^2 → R^2 
$$ </p>
<p>$$
\begin{cases}
x=x(u,v) \\
y=y(u,v)
\end{cases}
$$</p>
<p>$$
(u,v)\in [0,1]\times [0,1]
$$</p>
<p>几何解释：二维区域之间的映射，可看成特殊的曲面（第三个维度始终为\(0\)）<br />
应用：图像变形(warping)</p>
<p><img src="ParametricFitting/../assets/%E5%90%91%E9%87%8F-05.png" alt="" /></p>
<h2 id="三维映射"><a class="header" href="#三维映射">三维映射</a></h2>
<p>$$
f:R^3 → R^3 
$$ </p>
<p>$$
\begin{cases}
x=x(u,v,w)\\
y=y(u,v,w)  \\
z=z(u,v,w)
\end{cases}
$$</p>
<p>$$
(u,v,w)\in [0,1]^3
$$</p>
<p>几何解释：三维体区域之间的映射<br />
应用：体形变、体参数化、有限元</p>
<p><img src="ParametricFitting/../assets/%E5%90%91%E9%87%8F-6.png" alt="" /></p>
<h2 id="降维映射低维投影"><a class="header" href="#降维映射低维投影">降维映射（低维投影）</a></h2>
<p><img src="ParametricFitting/../assets/%E5%90%91%E9%87%8F-7.png" alt="" /></p>
<p>降维映射<strong>一般有信息丢失</strong>，丢失的信息<strong>大部分情况下不可逆</strong>，即无法恢复</p>
<blockquote>
<p>高维到低维，如果多个点映射到一个点，就会发生信息丢失，不可恢复。  　　　</p>
</blockquote>
<blockquote>
<p>💡 <strong>我的思考</strong><br />
信息丢失不定是坏事，有可能本身就是一个点，由于躁声的原因表现为多个点，也有可能是次要信息，不希望提取出­来。</p>
</blockquote>
<h2 id="一般映射"><a class="header" href="#一般映射">一般映射</a></h2>
<p>$$
f:R^n → R^m 
$$ </p>
<ul>
<li>\(n&lt;m\)<br />
为低维到高维的映射（高维的超曲面，\(n\)维流形曲面），<strong>本征维度</strong>为\(n\)</li>
<li>\(n&gt;m\)<br />
为降维映射，一般信息有损失<br />
（1）如果\(𝑅^n\)中的点集刚好位于一个\(𝑚\)维（或小于\(𝑚\)）的流形上，则映射可能是无损的，即可以被恢复的<br />
（2）如果值维度低于变量的本质维度，则必定不可恢复。</li>
</ul>
<p><img src="ParametricFitting/../assets/%E5%90%91%E9%87%8F-8.png" alt="" /></p>
<blockquote>
<p>[42：00] 其中黄色为参数学习曲面</p>
</blockquote>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。
https://caterpillarstudygroup.github.io/GAMES102_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="曲线拟合问题"><a class="header" href="#曲线拟合问题">曲线拟合问题</a></h1>
<h2 id="问题描述"><a class="header" href="#问题描述">问题描述</a></h2>
<blockquote>
<p>[42:43]</p>
</blockquote>
<p>输入：给定平面上系列点\((x_i,y_i),i=1,2,...,n\)</p>
<p>输出：一条参数曲线，拟合这些点</p>
<p><img src="ParametricFitting/../assets/%E6%9B%B2%E7%BA%BF-1.png" alt="" /></p>
<blockquote>
<p>👆 [42：50]非函数型曲线</p>
</blockquote>
<h2 id="解决方法-1"><a class="header" href="#解决方法-1">解决方法</a></h2>
<p>$$
f:R^1 → R^2 
$$ </p>
<p>$$
\begin{cases}
x=x(t)\\
y=y(t) 
\end{cases}
$$</p>
<p>$$
t\in [0,1]
$$</p>
<h2 id="存在的问题"><a class="header" href="#存在的问题">存在的问题</a></h2>
<blockquote>
<p>❓ \(x=x(t)\)，用\(x(t)\)拟合数据点\(x_i\)，但\(x_i\)与\(t\)没有关系，如何拟合？<br />
答：需要人为构造这个关系。即构造\((t_i,x_i)\)，这个过程称为参数化，\(t_i\)是参数。</p>
</blockquote>
<p>即，\(x(t)\)拟合点\((t_i,x_i)\)，\(y(t)\)拟合点\((t_i,y_i)\)</p>
<h2 id="基于曲线参数化的曲线拟合问题"><a class="header" href="#基于曲线参数化的曲线拟合问题">基于曲线参数化的曲线拟合问题</a></h2>
<p><img src="ParametricFitting/../assets/%E6%9B%B2%E7%BA%BF-2.png" alt="" /></p>
<p>$$
\begin{cases}
x=x(t)\\
y=y(t) 
\end{cases}
$$</p>
<p>$$
t\in [0,1]
$$</p>
<p>矢量符号化表达：
$$
p=p(t)=\binom{x(t)}{y(t)} 
$$</p>
<p>然后极小化误差度量：</p>
<p>$$
E= {\textstyle \sum_{i=1}^{n}} ||\binom{x(t_i)}{ y(t_i)}-\binom{x_i}{y_i} ||^2= {\textstyle \sum_{i=1}^{n}}||p(t_i)-p_i||^2
$$</p>
<h1 id="曲线参数化"><a class="header" href="#曲线参数化">曲线参数化</a></h1>
<p>构造\((t_i,x_i)\)和\((t_i,y_i)\)主要是如何取\(t_i\)<br />
通常\(t_0=0,t_n=1\)</p>
<blockquote>
<p>❓ 对数据点\((x_i,y_i)\)，对应哪个参数\(𝑡_i\)？<br />
答：求数据点所对应的参数（点列的参数化）：一个降维的问题！</p>
</blockquote>
<p>下面的参数化方法以二维为例。</p>
<h2 id="均匀参数化-equidistant-uniform-parameterization"><a class="header" href="#均匀参数化-equidistant-uniform-parameterization">均匀参数化 Equidistant (uniform) parameterization</a></h2>
<p>\(𝑡_{i+1}-𝑡_i=const\)<br />
例如：\(𝑡_i=i\)，得到的点对为{(1,x1),(2,x2),...,(n,xn)}和{(1,y1),(2,y2),...,(n,yn)}<br />
缺点：Geometry of the data points is not considered</p>
<p><img src="ParametricFitting/../assets/%E6%9B%B2%E7%BA%BF-3.png" alt="" /> </p>
<blockquote>
<p>👆 用 uniform 角处比较尖锐，更好的参数化方法会得到更平滑的曲线。</p>
</blockquote>
<h2 id="弦长参数化-chordal-parameterization"><a class="header" href="#弦长参数化-chordal-parameterization">弦长参数化 Chordal parameterization</a></h2>
<p>\(𝑡_{i+1}-𝑡_i=||k_{i+1}-k_i||\)</p>
<p>Chordal 参数的距离与邻居点的距离成正比</p>
<p><img src="ParametricFitting/../assets/%E6%9B%B2%E7%BA%BF-9.png" alt="" /></p>
<h2 id="中心参数化-centripetal-parameterization"><a class="header" href="#中心参数化-centripetal-parameterization">中心参数化 Centripetal parameterization</a></h2>
<p>\(𝑡_{i+1}-𝑡_i=\sqrt{||k_{i+1}-k_i||} \)</p>
<p><img src="ParametricFitting/../assets/%E6%9B%B2%E7%BA%BF-4.png" alt="" /></p>
<blockquote>
<p>老师没有解释这种方法</p>
</blockquote>
<h2 id="foley-parameterization"><a class="header" href="#foley-parameterization">Foley parameterization</a></h2>
<blockquote>
<p>老师没有解释这种方法</p>
</blockquote>
<p>Involvement of angles in the control polygon</p>
<p>$$
t_{i+1}-t_i = ||k_{i+1}-k_i|| \cdot \left(1+\frac{3}{2} \frac{\hat\alpha_i ||k_{i} - k_{i-1}||}{||k_{i}-k_{i-1}||+||k_{i+1}-k_i||}+\frac{3}{2} \frac{\hat\alpha_{i+1}||k_{i+1}-k_i||}{||k_{i+1}-k_i||+||k_{i+2}-k{i+1}||} \right)
$$</p>
<p>with</p>
<p>$$
\hat{\alpha } _i=\min (\pi -\alpha _i,\frac{\pi }{2} )
$$</p>
<p>and</p>
<p>$$
\alpha_{i}=angle(k_{i-1},k_i,k_{i+1})
$$</p>
<p><img src="ParametricFitting/../assets/%E6%9B%B2%E7%BA%BF-5.png" alt="" /></p>
<h2 id="四种方法的比较"><a class="header" href="#四种方法的比较">四种方法的比较</a></h2>
<p><img src="ParametricFitting/../assets/%E6%9B%B2%E7%BA%BF-6.png" alt="" /></p>
<p>点的参数化对曲线拟合的影响很大，需要<strong>好的参数化</strong>！</p>
<blockquote>
<p>按照老师的意思，似乎得到的曲线越光滑，说明参数化越好。<br />
参数化的本质是降维。即把曲线原本所在的空间，嵌入到参数空间。<br />
如果降维的维度不对，或维度对了但分布不好，都会导致降维结果不好。[58:40]</p>
</blockquote>
<h1 id="曲面参数化"><a class="header" href="#曲面参数化">曲面参数化</a></h1>
<p>三维的点找二维的参数：一个降维的问题！</p>
<p><img src="ParametricFitting/../assets/%E6%9B%B2%E7%BA%BF-7.png" alt="" /></p>
<blockquote>
<p>参数化约束：保持边长、网格面积、角度，就能得到比较好的参数结果。</p>
</blockquote>
<h2 id="曲面参数化的应用"><a class="header" href="#曲面参数化的应用">曲面参数化的应用</a></h2>
<ul>
<li>纹理映射</li>
</ul>
<p><img src="ParametricFitting/../assets/%E6%9B%B2%E7%BA%BF-8.png" alt="" /></p>
<ul>
<li>地图绘制</li>
</ul>
<p><img src="ParametricFitting/../assets/%E7%BD%91%E6%A0%BC30.png" alt="" /><br />
可展曲面展成平面不会扭曲。<br />
球面不可展，展开必定扭曲。</p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。
https://caterpillarstudygroup.github.io/GAMES102_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="三次样条函数的来源"><a class="header" href="#三次样条函数的来源">三次样条函数的来源</a></h1>
<blockquote>
<p>[14:00]</p>
</blockquote>
<p><img src="CubicSplines/../assets/%E5%87%A0%E4%BD%95-15.png" alt="" /></p>
<blockquote>
<p>👆 每个三角形代表一个压铁。</p>
</blockquote>
<p>物理推理过程省略，最后结论是两压铁间\(y(x)\)<strong>为三次函数</strong>，即样条曲线为分段三次函数。</p>
<blockquote>
<p>❓ 问：为什么是3次？<br />
答：2次多项式无法表达拐点，不够自由。高次（4次及以上）多项式拐点多，次数若较高计算易出现较大误差。3次正好</p>
</blockquote>
<h1 id="三次样条曲线的求解"><a class="header" href="#三次样条曲线的求解">三次样条曲线的求解</a></h1>
<p>已知每个压铁的位置，求压铁之间的三次函数。思考：<br />
• 每段多项式函数之间满足什么条件？<br />
• 如何求解？</p>
<h2 id="求解思路"><a class="header" href="#求解思路">求解思路</a></h2>
<h3 id="根据已知条件来定义变量"><a class="header" href="#根据已知条件来定义变量">根据已知条件来定义变量</a></h3>
<p>每段为3次多项式，因此每一段函数的形式如下，且有4个变量（待定系数）</p>
<p>$$
y_i(x)=a_i+b_ix+c_ix^2+d_ix^3
$$</p>
<p>假设有\(n+1\)个型值点（\(n\)段），则总共有个\(4n\)变量。</p>
<h3 id="根据已知条件来设置约束"><a class="header" href="#根据已知条件来设置约束">根据已知条件来设置约束</a></h3>
<ul>
<li>首先，曲线要插值型值点，有\(n+1\)个约束条件；</li>
<li>其次，假设曲线整体为\(C^2\)连续，则相邻两段在拼接点要满足3个条件（\(C^0\)连续、\(C^1\)连续、\(C^2\)连续）；则有\(3n-3\)个约束条件；</li>
</ul>
<p>到目前为止共有\(4n-2\)个约束条件；因此，再加2个额外条件，即可唯一确定整条曲线。</p>
<h3 id="根据边界条件来设置约束"><a class="header" href="#根据边界条件来设置约束">根据边界条件来设置约束</a></h3>
<p>在首尾的控制点上各增加一条约束，见[23:36]的边界条件。例如：</p>
<ul>
<li>
<p>自由端：指定曲线在两个端点处的二阶导数值<br />
特别地，两个端点的二阶导数值指定为0时称为自然三次样条</p>
</li>
<li>
<p>夹持端： 指定曲线在两个端点处的一阶导数值</p>
</li>
<li>
<p>抛物端：首末两段为抛物线</p>
</li>
<li>
<p>周期端</p>
</li>
<li>
<p>混合边界条件</p>
</li>
</ul>
<h2 id="方法1"><a class="header" href="#方法1">方法1</a></h2>
<ol>
<li>引入中间变量：节点处的2阶导数值\(M_i\)（弯矩）</li>
<li>每段\({y}''(x)\)表达为\(M_i\)和\(M_{i+1}\)的线性插值，则\(y_i(x)\)为包含待定值\(M_i\)的3次多项式</li>
<li>再根据拼接条件（\(C^0\)、\(C^1\)、\(C^2\)连续），列出等式</li>
<li>最后加上2个边界条件，构成关于{\((M_i,i=1,...,n-1)\)}的\((n-1)\times (n-1)\)阶的线性方程组<br />
方程组为对称的、三对角的、对角占优的，称为<strong>三弯矩方程组</strong>。方程组系数矩阵满秩，有唯一解。可用<strong>追赶法</strong>求解三弯矩方程组。</li>
</ol>
<h2 id="方法2"><a class="header" href="#方法2">方法2</a></h2>
<ol>
<li>引入中间变量：节点处的<strong>1阶导数值</strong>\(M_i\)（转角）</li>
<li>…（推导过程类似）</li>
<li>最后加上2个边界条件，构成关于{\(M_i,i=1,...,n-1\)}的\((n-1)\times(n-1)\)阶的线性方程组<br />
方程组为<strong>对称的</strong>、<strong>三对角的</strong>、<strong>对角占优</strong>的，称为<strong>三转角方程组</strong>。方程组系数矩阵满秩，有唯一解。同样可用<strong>追赶法</strong>求解三转角方程组。</li>
</ol>
<h2 id="简化的计算技巧"><a class="header" href="#简化的计算技巧">简化的计算技巧</a></h2>
<h3 id="hermite型插值多项式"><a class="header" href="#hermite型插值多项式">Hermite型插值多项式</a></h3>
<p>如果已知两个压点的位置及一阶导，则可以快速求出三次曲线(Hermite)。</p>
<p>假设</p>
<p>$$
\begin{cases}
S(x_{i-1})=f_{i-1}\\
S(x_i)=y_i
\end{cases}
$$</p>
<p>$$
\begin{cases}
{s}' (x_{i-1})=m_{i-1} \\
{s}' (x_i)=m_i
\end{cases}
$$</p>
<blockquote>
<p>预先求出一组满足性质的四条曲线，分别是（1）经过x0且其它点都为0（2）经过x1且其它点都为0（3）x0的导数满足要求，其它都为0（4）x1的导数满足要求，其它都为0<br />
其它曲线都可以通过这四条曲线组合出来。</p>
</blockquote>
<p>当\(x=\in [x_{i-1},x_i]\)时，有<br />
$$
S(x)=y_{i-1}h_0(x)+y_ih_1(x)+m_{i-1}H_0(x)+m_iH_1(x)
$$</p>
<p><img src="CubicSplines/../assets/%E5%87%A0%E4%BD%95-30.png" alt="" /></p>
<blockquote>
<p>对函数有4个约束：<br />
分别针对每个约束得到4个函数，即 \(h_0,h_c,H_0,H_1\)。<br />
\(s(x)\)为这4个函数的线性组合。</p>
</blockquote>
<h3 id="lidstone型插值多项式"><a class="header" href="#lidstone型插值多项式">Lidstone型插值多项式</a></h3>
<p>已知两个压点的位置和二阶导，也能快速求出曲线。</p>
<blockquote>
<p>具体过程没讲，跟上面的方法类似</p>
</blockquote>
<p>好处：在给定两个端点及其导数情况下，可直接写出函数的表达形式，这是<strong>数学上的一个通用技巧</strong></p>
<blockquote>
<p>❓ 虽然没怎么听懂，但感觉是类似【技巧1构造插值问题的通用解】(<a href="https://caterpillarstudygroup.github.io/GAMES102_mdbook/DataFitting/PolynomialInterpolation.html#%E6%8A%80%E5%B7%A71%E6%9E%84%E9%80%A0%E6%8F%92%E5%80%BC%E9%97%AE%E9%A2%98%E7%9A%84%E9%80%9A%E7%94%A8%E8%A7%A3">link</a>)的一种方法。</p>
</blockquote>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。
https://caterpillarstudygroup.github.io/GAMES102_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="三次基样条"><a class="header" href="#三次基样条">三次基样条</a></h1>
<blockquote>
<p>这一节没讲，用Hermit基组成样条叫基样条。</p>
</blockquote>
<p>$$
S(x)=\sum_{i=0}^{n}y_i \varphi _i(x)+{y}'_0 \varphi _{n+1}(x)+{y}'_n \varphi _{n+2}(x)
$$</p>
<p>其中\(\varphi _i(x)\)均为三次样条函数，且满足<br />
<img src="CubicSplines/../assets/%E5%85%AC%E5%BC%8F1.png" alt="" /></p>
<p>任一\(\varphi _i(x)\)可由三次样条函数方法求得。</p>
<blockquote>
<p>[29:35] # ？不知道在干什么.大概是用 Hermit 类似的方法简化求三次基样条的过程。<br />
[&gt;]这个简化方法有点像拉格朗日优化。</p>
</blockquote>
<h2 id="基样条特征"><a class="header" href="#基样条特征">基样条特征</a></h2>
<p>• 考虑定义在所有整数节点上的基样条<br />
即满足\(\varphi (j)=\delta _{0j}\),\((j=0,\pm1,\pm2,...)\)</p>
<p><img src="CubicSplines/../assets/%E5%87%A0%E4%BD%95-32.png" alt="" /></p>
<p>$$
\lambda =\sqrt{3} -2\approx - 0.268
$$</p>
<p><img src="CubicSplines/../assets/%E5%87%A0%E4%BD%95-20.png" alt="" /></p>
<p><img src="CubicSplines/../assets/%E5%87%A0%E4%BD%95-21.png" alt="" /></p>
<p>(a) 相邻两端异号；<br />
(b) 每段有一个极值点，\(j+1\)段极值点是j段极值点的\(\lambda\)倍;<br />
(c) 节点处导数满足\(m_{j+1}=\lambda m_j\)</p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。
https://caterpillarstudygroup.github.io/GAMES102_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="三次样条曲线"><a class="header" href="#三次样条曲线">三次样条曲线</a></h1>
<blockquote>
<p>这一节也没细讲，大概意思是，用上一节讲了基函数，上上节讲了带参数化的多元函数拟合方法。输入一些点，用这种基函数以及这种拟合方法拟合这些点，得到的曲线就叫三次样条曲线。</p>
</blockquote>
<h2 id="样条函数的局限性"><a class="header" href="#样条函数的局限性">样条函数的局限性</a></h2>
<p>• 须有小扰度假定<br />
• 不能处理多值问题<br />
• 不能很好表达空间曲线<br />
• 不具有坐标不变性（几何不变性）</p>
<h2 id="三次参数样条曲线"><a class="header" href="#三次参数样条曲线">三次参数样条曲线</a></h2>
<p>• 3个坐标分量\(x,y,z\)分别是参数\(t\)的三次样条函数<br />
• 对型值点做参数化<br />
• 对3个坐标分量分别处理</p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。
https://caterpillarstudygroup.github.io/GAMES102_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="曲线的几何连续性"><a class="header" href="#曲线的几何连续性">曲线的几何连续性</a></h1>
<h2 id="参数连续性"><a class="header" href="#参数连续性">参数连续性</a></h2>
<h3 id="定义-1"><a class="header" href="#定义-1">定义</a></h3>
<p>在数学分析/高等数学中，我们所说的“连续性”（光滑性）是指“参数连续性”：</p>
<p>给定两条曲线\(x_1(t)\)和\(x_2(t)\)，其中\(x_1(t)\)定义在\([t_0,t_1]\)，\(x_2(t)\)定义在\([t_1,t_2]\)</p>
<p>曲线\(𝒙_1\)和\(𝒙_2\)在\(t_1\)称为\(C^r\)<strong>连续</strong>的，如果它们的从\(0^{th}\)（\(0\)阶） 至\(r^{th}\)（\(𝑟\)阶）的导数向量在\(𝑡_1\)处完全相同。</p>
<ul>
<li>\(C^{-1}\)：表示不连续</li>
<li>\(C^0\): position varies continuously</li>
<li>\(C^1\): First derivative is continuous across junction。即 the velocity vector remains the same</li>
<li>\(C^2\): Second derivative is continuous across junction 即 The acceleration vector remains the same</li>
</ul>
<p><img src="CubicSplines/../assets/%E5%87%A0%E4%BD%95-23.png" alt="" /></p>
<h3 id="参数连续性的不足"><a class="header" href="#参数连续性的不足">参数连续性的不足</a></h3>
<p>参数连续性过于严格，在几何设计中不太直观</p>
<p>• 例子1：一条线段v0v1</p>
<p><img src="CubicSplines/../assets/%E5%87%A0%E4%BD%95-24.png" alt="" /></p>
<p>表示为分段函数：</p>
<p>$$
\varphi(t)=\begin{cases}
v_{0}+\frac{v_{1}-v_{0}}{3} t, 0 \leq t \leq 1\\
v_{0}+\frac{v_{1}-v_{0}}{3}+\frac{2\left(v_{1}-v_{0}\right)}{3}(t-1), 1 \leq t \leq 2
\end{cases}
$$</p>
<p>线段上的任意点应该是处处连续的。但是，
$$
{\varphi }'(1-)=\frac{v_{1}-v_{0}}{3},{\varphi }' (1+)=\frac{2(v_{1}-v_{0})}{3}
$$</p>
<p>\(\varphi (t)\)在\(t=1\)的左右导数不相等，因此，\(\varphi(t)\)在\([0,2]\)中<strong>不是</strong>\(C^1\)的，与直线的连续性应是\(C^\propto\)的矛盾。</p>
<blockquote>
<p>❓ 问：为什么此时在\(t=1处 C^{1}\)不连续<br />
答：导数反应的是对变量的变化率，而图中两段的\(t\)是不同的变量。<br />
因此，参数连续性<strong>依赖于参数</strong>的选择，同一条曲线，参数不同，连续阶也不同。 </p>
</blockquote>
<p>• 例子2：同一条线段，但对参数化方法做一些改造：</p>
<p><img src="CubicSplines/../assets/%E5%87%A0%E4%BD%95-25-1.png" alt="" /></p>
<p>表示为分段函数：</p>
<p>$$
\varphi(t)=\begin{cases}
v_{0}+\frac{v_{1}-v_{0}}{3} t, 0 \leq t \leq \frac{2}{3}\\
v_{0}+\frac{v_{1}-v_{0}}{3}+\frac{\left(v_{1}-v_{0}\right)}{3}(t-\frac{2}{3}), \frac{2}{3} \leq t \leq 2
\end{cases}
$$</p>
<p>则\({\varphi }' (\frac{2}{3}- )={\varphi }' (\frac{2}{3}+ ),\varphi (t)\)在\([0,2]\)就是\(C^\infty \)了。</p>
<p>这个参数化方法的改造，本质是引入了<strong>参数的一个变换</strong></p>
<p>$$
t=\begin{cases}
\frac{2}{3}s,0\le s\le \frac{2}{3},\\
\frac{3}{4}(s-\frac{2}{3})+1,\frac{2}{3}\le s\le 2.
\end{cases}
$$</p>
<p>使得原来不是\(C^1 \)的曲线变为\(C^1 \)的了。</p>
<p><strong>参数连续性依赖于参数定义，无法刻画曲线本征的特性</strong>。因此引入几何连续性。</p>
<h2 id="几何连续性"><a class="header" href="#几何连续性">几何连续性</a></h2>
<h3 id="定义-2"><a class="header" href="#定义-2">定义</a></h3>
<p>设\(\varphi (t)(a\le t\le b)\)是给定的曲线。若存在一个参数变换\( t=p(s)(a_1\le s\le b_1)\),
使得\(\varphi (p(s))\in C^n[a_1,b_1]\),且\(\frac{d\varphi (p(s))}{ds} \ne 0\),
则称曲线\(\varphi (t)(a\le t\le b)\)是\(n\)阶几何连续的曲线，记为
$$
\varphi (t)\in GC^n[a,b]
$$</p>
<p>或</p>
<p>$$
\varphi (t)\in G^n[a,b]
$$</p>
<blockquote>
<p>把线段\(C^1\)不连续变成\(C^\infty \)连续的过程就是参数变换的例子。这里只是给出定义，不提供参数变换的方法。</p>
</blockquote>
<h3 id="性质"><a class="header" href="#性质">性质</a></h3>
<ol>
<li>条件 \(\frac{d\varphi (p(s))}{ds} \ne 0\)保证了曲线上无奇点；</li>
</ol>
<blockquote>
<p>一般不考虑有奇点的情况</p>
</blockquote>
<ol start="2">
<li>几何连续性与参数选取无关，是曲线本身固有的几何性质； </li>
</ol>
<blockquote>
<p>本征特征：<strong>不会由于曲的旋转、平移而改变的特征</strong>，例如曲率。</p>
</blockquote>
<ol start="3">
<li>\(𝐺^n\) 的条件比\(𝐺^n\)的宽，曲线类型更多；</li>
</ol>
<h3 id="具体形式"><a class="header" href="#具体形式">具体形式</a></h3>
<p>• \(𝐺^0\)：表示两曲线有公共的连接端点，\(C^0\)与的条件一致<br />
• \(𝐺^1\)：两曲线在连接点处有公共的<strong>切线方向</strong>，即切线方向连续，切线长度可以不同。<br />
• \(𝐺^2\)：两曲线在连接点处有公共的<strong>曲率圆</strong>，即曲率连续</p>
<p><img src="CubicSplines/../assets/%E5%87%A0%E4%BD%95-26.png" alt="" /></p>
<blockquote>
<p>曲线编辑工具。跳过</p>
</blockquote>
<h2 id="两种连续性的比较"><a class="header" href="#两种连续性的比较">两种连续性的比较</a></h2>
<p>C连续适合于动画。G连续适合于设计建模。</p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。
https://caterpillarstudygroup.github.io/GAMES102_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="函数曲线拟合"><a class="header" href="#函数曲线拟合">函数/曲线拟合</a></h1>
<ul>
<li>
<p>从<strong>代数观点</strong>来看：从一组基函数所张成的函数空间中，找一个“好”的函数来拟合给定的采样点。<br />
比如幂基{\(1,x,x^2,\cdots ,x^n\)}<br />
\((n=2) \)二次多项式：\(𝑓(t)=at^2+bt+c\)</p>
</li>
<li>
<p>参数曲线形式：\(f(t)=\binom{x(t)}{y(t)} \)</p>
</li>
</ul>
<h1 id="建模的两种形式"><a class="header" href="#建模的两种形式">建模的两种形式</a></h1>
<p>$$
𝑓(t)=at^2+bt+c
$$</p>
<ol>
<li>
<p>重建（Reconstruction/Fitting）<br />
• 逆向工程：形状已有，要将其“猜”出来<br />
• 采样\(\to \)拟合：需要函数空间足够丰富（表达能力够）<br />
• 代数观点：{\(a,b,c\)}作为基函数的组合权系数<br />
• 输入：采样点{\(S_j,j=0\sim m\)} 及基函数{\(b_i(t),i=0\sim n\)}<br />
• 输出：拟合函数的系数{\(p_i,i=0\sim n\)}</p>
</li>
<li>
<p>设计（Design）<br />
• 自由设计：凭空产生，或从一个简单的形状编辑得到<br />
• 交互式编辑：几何直观性要好，具有好性质的基函数使得交互设计更直观<br />
• <strong>几何观点</strong>：基函数{\(t^2,t,1\)}作为控制点的组合权系数<br />
• 输入：交互输入（或者反求）控制顶点{\(p_i,i=0\sim n\)}<br />
• 输出：曲线\(f(t)\)</p>
</li>
</ol>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。
https://caterpillarstudygroup.github.io/GAMES102_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="两种观点两种表达方式"><a class="header" href="#两种观点两种表达方式">两种观点，两种表达方式</a></h1>
<h2 id="使用幂基来表达曲线"><a class="header" href="#使用幂基来表达曲线">使用幂基来表达曲线</a></h2>
<p>二次多项式曲线（抛物线）:</p>
<p>$$
𝑓(t)=at^2+bt+c
$$</p>
<p><img src="BezierCurve/../assets/B%E6%9B%B2-3.png" alt="" /></p>
<p>几何观点：基函数为这些顶点的组合权系数。</p>
<p><img src="BezierCurve/../assets/B%E6%9B%B2-7.png" alt="" /> </p>
<p>从几何观点来看，系数顶点与曲线本身无直观的联系，因此无几何意义！ 
不利于用户来交互修改曲线：<strong>适用于重建，但不适用于设计</strong></p>
<h2 id="使用bernstein基函数表达"><a class="header" href="#使用bernstein基函数表达">使用Bernstein基函数表达</a></h2>
<p>使用Bernstein基函数来改写</p>
<p>$$
f(t)=\binom{1}{1} t^2+\binom{-2}{0} t+\binom{1}{0} 
$$</p>
<p>$$
\downarrow 
$$</p>
<p>$$
f(t)=\binom{1}{0} (1-t)^2+\binom{0}{0} 2t(1-t)+\binom{0}{1} t^2
$$</p>
<p>系数顶点与曲线关联性强，具有很好的几何意义。对于交互式曲线设计更观</p>
<p><img src="BezierCurve/../assets/B%E6%9B%B2-4.png" alt="" /></p>
<p><strong>用Bernstein基函数所表达的曲线具有非常好的几何意义！</strong> </p>
<h1 id="bernstein基函数"><a class="header" href="#bernstein基函数">Bernstein基函数</a></h1>
<p>\(n\)次Bernstein基函数:\(B=\){\(B_0^{(n)},B_1^{(n)},\cdots ,B_n^{(n)}\)}</p>
<p>$$
B_i^{(n)}(t)=\binom{n}{i}t^i(1-t)^{n-i}=B_{i-th basis function}^{(degree)} 
$$</p>
<p>where the binomial coefficients are given by:
$$
\binom{n}{i}=
\begin{cases}
\frac{n!}{(n-i)!i!} &amp;&amp; for \quad 0\le i\le n \\
0  &amp;&amp;        otherwise
\end{cases}
$$</p>
<p><img src="BezierCurve/../assets/B%E6%9B%B2-5.png" alt="" /></p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。
https://caterpillarstudygroup.github.io/GAMES102_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bezier曲线"><a class="header" href="#bezier曲线">Bezier曲线</a></h1>
<h2 id="定义-3"><a class="header" href="#定义-3">定义</a></h2>
<p>\(n\)次Bezier曲线有\(n+1\)个控制顶点</p>
<p>$$
x(t)=\sum_{i=0}^{n} B^n_i(t)\cdot b_i
$$</p>
<p>\(b_i\)称为控制顶点，所有\(b_i\)按顺序连起来得到的多边形为<br />
控制多边形</p>
<p><img src="BezierCurve/../assets/B%E6%9B%B2-8.png" alt="" /></p>
<p>Bezier曲线的性质来源于Bernstein<strong>基函数</strong>的性质
（<strong>曲线是控制顶点的线性组合构成的，基函数提供了组合系数</strong>）</p>
<h2 id="属性"><a class="header" href="#属性">属性</a></h2>
<p><img src="BezierCurve/../assets/Bezier_58.PNG" alt="" /></p>
<ul>
<li>起始点同p0位置</li>
<li>起点处的切线方向同\(\vec{p_0p_1}\)</li>
<li>终点同为p3位置</li>
<li>终点处的切线方向同\(\vec{p_2p_3}\)</li>
</ul>
<h2 id="例子"><a class="header" href="#例子">例子</a></h2>
<h3 id="3次bezier曲线"><a class="header" href="#3次bezier曲线">3次Bezier曲线</a></h3>
<p>$$
f(t)=\sum_{i=1}^{3} B^3_ip_i, \quad t\in [0,1]
$$</p>
<p><img src="BezierCurve/../assets/B%E6%9B%B2-10.png" alt="" /> </p>
<h3 id="更复杂的bezier曲线"><a class="header" href="#更复杂的bezier曲线">更复杂的Bezier曲线</a></h3>
<p><img src="BezierCurve/../assets/B%E6%9B%B2-11.png" alt="" /> </p>
<h3 id="3d空间的bezier曲线单参数"><a class="header" href="#3d空间的bezier曲线单参数">3D空间的Bezier曲线（单参数）</a></h3>
<p>$$
f(t)=\sum_{i=1}^{n} B^n_ip_i,t\in [0,1]
$$</p>
<p><img src="BezierCurve/../assets/B%E6%9B%B2-12.png" alt="" /> </p>
<h2 id="piece-wise-bezier曲线"><a class="header" href="#piece-wise-bezier曲线">Piece-wise Bezier曲线</a></h2>
<p><img src="BezierCurve/../assets/Bezier_60.PNG" alt="" /></p>
<p>[38:23] 当控制点比较多时，Bezier曲线不利于控制</p>
<ul>
<li>How</li>
</ul>
<p>把多个点分段，每4个点画一条曲线，例如photoshop中的钢笔功能。</p>
<ul>
<li>What</li>
</ul>
<p><img src="BezierCurve/../assets/Bezier_61.PNG" alt="" /></p>
<h2 id="光滑的piece-wise-bezier曲线"><a class="header" href="#光滑的piece-wise-bezier曲线">光滑的Piece-wise Bezier曲线</a></h2>
<p>C0连续：数值上连续</p>
<p>C1连续：切线连续（<strong>方向和大小都要一致</strong>），即光滑</p>
<p>C2连续：曲率连续</p>
<p>要使分段的Bezier曲线光滑（C1连续），需要让上一段的终点和下一段的起点切线一致。这可以通过控制点的位置来实现。</p>
<p><img src="BezierCurve/../assets/Bezier_62.PNG" alt="" /></p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。
https://caterpillarstudygroup.github.io/GAMES102_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bernstein基函数的性质"><a class="header" href="#bernstein基函数的性质">Bernstein基函数的性质</a></h1>
<blockquote>
<p>🔎 定义见上一页</p>
</blockquote>
<h2 id="对称性"><a class="header" href="#对称性">对称性</a></h2>
<p>$$
B_i^{(n)}(t)=B_{n-i}^{n}(1-t)
$$</p>
<p>且</p>
<p>\(B^{(n)}_i(t)\)   在\(t= \frac{i}{n} \)达到最大值</p>
<p><img src="BezierCurve/../assets/B%E6%9B%B2-13.png" alt="" /> </p>
<h2 id="正权性"><a class="header" href="#正权性">正权性</a></h2>
<p>正性（非负性）+ 权性 = 凸包性</p>
<p>$$
B_i^{(n)}(t)\ge 0,\forall t\in [0,1]
$$</p>
<p>$$
\sum_{i=1}^{n}B_i^{(n)}(t)=1, \forall t\in [0,1]
$$</p>
<h2 id="基性"><a class="header" href="#基性">基性</a></h2>
<p>\(B=\){\(B_0^{(n)},B_1^{(n)},...,B_N^{(n)}\)}是次数不高于n的多项式集合（空间）的一组基</p>
<p>且与幂基可以相互线性表达：</p>
<p><img src="BezierCurve/../assets/B%E6%9B%B2-35.png" alt="" /> </p>
<h2 id="递推公式"><a class="header" href="#递推公式">递推公式</a></h2>
<p>基函数的递推公式</p>
<p>$$
B_i^{(n)}(t)=（1-t）B_i^{(n-1)}(t)+tB_{i-1}^{(n-1)}(1-t)
$$</p>
<p>with \( \quad B_0^{(0)}(t)=1，B_i^n(t)=0\) for \(i\notin \){\(0\cdots n\)}</p>
<blockquote>
<p>由 \(\binom{n-1}{i} +\binom{n-1}{i-1}=\binom{n}{i}  \)可推导得到</p>
</blockquote>
<p>\(n\)阶的基函数由2个\(n-1\)阶的基函数加权得到，利于保持一些良好的性质</p>
<h2 id="导数"><a class="header" href="#导数">导数</a></h2>
<p>$$
\frac{d}{dt}B_i^{(n)}(t)=n[B_{i-1}^{(n-1)}(t)-B_i^{(n-1)}(t)] 
$$</p>
<p>$$
\frac{d^2}{dt^2}B_i^{(n)}(t)=n(n-1)[B_{i-2}^{(n-2)}(t)-2B_{i-1}^{(n-2)}(t)+B_i^{(n-2)}(t)] 
$$</p>
<h2 id="升阶"><a class="header" href="#升阶">升阶</a></h2>
<p>$$
(1-t)B^n_i(t)=(1-\frac{i}{n+1})B^{(n+1)}_i (t)
$$</p>
<p>$$
tB^n_i(t)=\frac{i+1}{n+1}B^{n+1}_i (t)
$$</p>
<h1 id="bezier曲线的性质"><a class="header" href="#bezier曲线的性质">Bezier曲线的性质</a></h1>
<h2 id="凸包性"><a class="header" href="#凸包性">凸包性</a></h2>
<p>凸包性：曲线在控制点组成的多边形内部。</p>
<p><img src="BezierCurve/../assets/B%E6%9B%B2-15.png" alt="" /></p>
<blockquote>
<p>系数满足性和权性的线性组合称为凸组合。</p>
</blockquote>
<h2 id="端点插值性"><a class="header" href="#端点插值性">端点插值性</a></h2>
<p><img src="BezierCurve/../assets/B%E6%9B%B2-16.png" alt="" /> </p>
<p>$$
B_0^0(0)=1,B_1^n(0)= \dots B_n^n(0)=0
$$</p>
<p>$$
B_0^n(1)= \dots =B_{n-1}^n(1)=0,B_n^n(0)=1
$$</p>
<p>$$
\downarrow 
$$</p>
<p>Bezier曲线经过首末两个控制顶点\(p_0,p_n\)</p>
<p><img src="BezierCurve/../assets/B%E6%9B%B2-17.png" alt="" /> </p>
<h2 id="导数-1"><a class="header" href="#导数-1">导数</a></h2>
<p>Bezier曲线的导数（切线）<br />
已知\(p_0,\dots ,p_n,f(t)=\sum_{i=0}^{n} B_i^n(t)p_i\)，可得：</p>
<p>$$
{f}' (t)=n\sum_{i=0}^{n-1} B_i^{n-1}(t)(p_{i+1}-p_i)
$$</p>
<p>$$
f^{[r]} (t)=\frac{n!}{(n-r)!} \cdot  \sum_{i=0}^{n-r}B_i^{n-r}(t)\cdot \Delta ^r p_i
$$</p>
<h2 id="bezier曲线的端点性质"><a class="header" href="#bezier曲线的端点性质">Bezier曲线的端点性质</a></h2>
<p>端点插值：<br />
$$
f(0)=p_0
$$</p>
<p>$$
f(1)=p_n
$$</p>
<p>端点的切线方向与边相同：</p>
<p>$$
(f)'(0)=n[p_1-p_0]
$$</p>
<p>$$
(f)'(1)=n[p_{n-1}-p_n]
$$</p>
<p>端点的2阶(k)切线与3点(k+1)相关：</p>
<p>$$
(f)''(0)=n(n-1)[p_2-2p_1+p_0]
$$</p>
<p>$$
(f)''(1)=n(n-1)[p_n-2p_{n-1}+p_{n-2}]
$$</p>
<blockquote>
<p><strong>结合几何意义来理解</strong></p>
</blockquote>
<h2 id="升阶-1"><a class="header" href="#升阶-1">升阶</a></h2>
<p>根据Bernstein基的升阶公式可得出Bezier曲线的升阶性质： </p>
<p>$$
f(t)=\sum_{i=0}^{n+1} B_i^{n+1}(t)[\frac{n+1-i}{n+1} p_i+\frac{i}{n+1} p_{i-1}]
$$</p>
<p><img src="BezierCurve/../assets/B%E6%9B%B2-18.png" alt="" /> </p>
<blockquote>
<p>系数为4个控制点，黑色为5个控制点，但它们生成的曲线相同。
所生成的桔色曲线本质阶数是3阶。</p>
</blockquote>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。
https://caterpillarstudygroup.github.io/GAMES102_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="算法描述"><a class="header" href="#算法描述">算法描述</a></h1>
<p>Input: points  \(𝒃_0,𝒃_1,\dots 𝒃_n∈ \mathbb{R} ^3\)<br />
Output: curve \(x(t),t∈ [0,1]\)</p>
<h1 id="过程示例"><a class="header" href="#过程示例">过程示例</a></h1>
<p>Repeated convex combination of control points</p>
<p>$$
b_i^{(r)}=(1-t)b_i^{(r-1)}+tb_{i+1}^{(r-1)}
$$</p>
<p><img src="BezierCurve/../assets/B%E6%9B%B22-2.png" alt="" /> </p>
<blockquote>
<p>点 \(b_0^{(0)},b_0^{(1)},b_0^{(2)},b_0^{(3)}是曲线 b_0^{(0)},b_0^{(3)}\)的控制点。</p>
</blockquote>
<p><img src="BezierCurve/../assets/B%E6%9B%B2-23-1.png" alt="" /></p>
<h1 id="例子-1"><a class="header" href="#例子-1">例子</a></h1>
<h2 id="给定3个点画bezier曲线"><a class="header" href="#给定3个点画bezier曲线">给定3个点，画Bezier曲线</a></h2>
<p>把起点看作是t=0时刻，终点看作是t=1时刻，画Bezier曲线，相当于求t=[0,1]区间时pt所在的位置。把范围所有时刻的pt连起来就是Bezier曲线。</p>
<p><img src="BezierCurve/../assets/DeCastelijau_2.PNG" alt="" /></p>
<ol>
<li>算出b0b1中的t位置的点为\(b^1_0\)</li>
<li>算出b1b2中的t位置的点为\(b^1_1\)</li>
<li>ab连成一条线，算是ab中的t位置的点为\(b^2_0\)</li>
<li>\(b^2_0\)是 Pt 的位置，</li>
</ol>
<h2 id="给定4个点画bezier曲线"><a class="header" href="#给定4个点画bezier曲线">给定4个点，画Bezier曲线</a></h2>
<p><img src="BezierCurve/../assets/DeCastelijau_1.PNG" alt="" /></p>
<p>[23:24]</p>
<h1 id="总结"><a class="header" href="#总结">总结</a></h1>
<p><img src="BezierCurve/../assets/B%E6%9B%B2-27.png" alt="" /></p>
<ul>
<li>给定\(t\)，计算Bezier曲线\(x(t)\)上参数为\(t\)的点</li>
</ul>
<blockquote>
<p>[30:18]局限性：一次只能针对一个\(t\)值计算。</p>
</blockquote>
<ul>
<li>良好的几何意义：该点将曲线一分两条子Bezier 曲线，其控制顶点是中间生成的点</li>
<li>可用于Bezier曲线的离散及求根等许多应用</li>
</ul>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。
https://caterpillarstudygroup.github.io/GAMES102_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="几何样条曲线"><a class="header" href="#几何样条曲线">几何样条曲线</a></h1>
<blockquote>
<p>样条就是分段曲线的意思。</p>
</blockquote>
<h2 id="用分段bezier曲线来插值型值点"><a class="header" href="#用分段bezier曲线来插值型值点">用分段Bezier曲线来插值型值点</a></h2>
<p>给定型值点:<br />
$$
k_0, \dots ,k_n\in \mathbb{R} ^3
$$</p>
<p>每两点间生成一段Bezier曲线，使得整体曲线满足一定的连续性\((𝐶^0,C^1,C^2)\)</p>
<p><img src="BezierCurve/../assets/B%E6%9B%B2-28.png" alt="" /></p>
<blockquote>
<p>蓝点是型值点。黑色是为了控制生成的曲线额外添加的点。</p>
</blockquote>
<h2 id="两bezier曲线的拼接条件"><a class="header" href="#两bezier曲线的拼接条件">两Bezier曲线的拼接条件</a></h2>
<p><img src="BezierCurve/../assets/B%E6%9B%B2-29.png" alt="" /></p>
<p>回顾：Bezier曲线的端点性质<a href="BezierCurve/Property.html">link</a></p>
<ul>
<li>
<p>C0连续与G0连续的条件：默认满足</p>
</li>
<li>
<p>\(G^1\)连续：三点共线</p>
</li>
<li>
<p>\(C^1\)连续：三点共线且等长</p>
</li>
</ul>
<p><img src="BezierCurve/../assets/B%E6%9B%B2-31.png" alt="" /></p>
<ul>
<li>
<p>\(C^2\)连续：\(𝑑^2⁄dt^2 \)为 \((p_2-2p_1+p_0),(p_n-2p_{n-1}+p_{n-2})\)，即阴影三角形相似<br />
<img src="BezierCurve/../assets/B%E6%9B%B2-32.png" alt="" /></p>
</li>
<li>
<p>\(G^2\)连续：？</p>
</li>
</ul>
<h1 id="构造3次插值bezier曲线的几何方法"><a class="header" href="#构造3次插值bezier曲线的几何方法">构造3次插值Bezier曲线的几何方法</a></h1>
<p><img src="BezierCurve/../assets/B%E6%9B%B2-33.png" alt="" /></p>
<h2 id="用矩阵计算的方法"><a class="header" href="#用矩阵计算的方法">用矩阵计算的方法</a></h2>
<p>根据基构造矩阵，计算系数。<br />
局限性，任意控制点的改变就要重新构造矩阵和计算</p>
<h2 id="工程中常用的几何方法"><a class="header" href="#工程中常用的几何方法">工程中常用的几何方法</a></h2>
<p>构造曲线的关键是算出辅助控制点的位置。</p>
<blockquote>
<p>[38:48]</p>
</blockquote>
<p><img src="BezierCurve/../assets/B%E6%9B%B2-36.PNG" alt="" /></p>
<p>(1) \(P_o 与P_2\)连线<br />
(2) 过\(P_1点画与P_0P_2\)平行的线段，线段以\(P_1\)为中点，长度为\(P_0P_2的\frac{1}{6} \).<br />
(3) 线段的端点是辅助控制点的位置。</p>
<blockquote>
<p>这种方法能满足C1，不能满足C2</p>
</blockquote>
<h1 id="广义样条曲线"><a class="header" href="#广义样条曲线">广义样条曲线</a></h1>
<p>分段的多项式曲线（Bezier曲线）<br />
<img src="BezierCurve/../assets/B%E6%9B%B2-34.png" alt="" /></p>
<blockquote>
<p>所有的分段连续曲线，曲线可以是直的，曲线之间也可以只有C1连续</p>
</blockquote>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。
https://caterpillarstudygroup.github.io/GAMES102_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="为什么引入b样条曲线"><a class="header" href="#为什么引入b样条曲线">为什么引入B样条曲线</a></h1>
<h2 id="bezier曲线的不足"><a class="header" href="#bezier曲线的不足">Bezier曲线的不足</a></h2>
<p><img src="BsplineCurve/../assets/%E6%9B%B2%E7%BA%BF1.png" alt="" /></p>
<p>$$
x(t)=\sum_{i=0}^{n} B_i^n(t)\cdot b_i
$$</p>
<blockquote>
<p>每个基函数在整平[0，1]作用域上都有值，因此具有全局性。
任意一个点的移动都会影响整条曲线。<br />
<strong>全局性：牵一发而动全身，不利于设计</strong></p>
</blockquote>
<blockquote>
<p>❓ 不是可以通过分段来解决吗？<br />
答：可以，但要分成多个函数来表达。B样条用统一的函数表达分段曲线。</p>
</blockquote>
<h2 id="样条曲线的不足"><a class="header" href="#样条曲线的不足">样条曲线的不足</a></h2>
<p>分段的多项式曲线（Bezier曲线）<br />
优点：分段表达，具有局部性<br />
缺点：要分成多个函数来表达。</p>
<h1 id="思考以统一的方式表达分段函数"><a class="header" href="#思考以统一的方式表达分段函数">思考：以统一的方式表达分段函数</a></h1>
<h2 id="基函数应满足的性质"><a class="header" href="#基函数应满足的性质">基函数应满足的性质</a></h2>
<p>形式类比：每个控制顶点用一个基函数进行组合</p>
<p>$$
x(t)=\sum_{i=0}^{n} N_{i,k}(t)\cdot d_i
$$</p>
<p>其中\(d_i\)为控制顶点，\(N\)为基函数。</p>
<p>基函数性质要求：<br />
• 基函数须局部性（局部支集）<br />
• 基函数要有正性+权性</p>
<h2 id="启发"><a class="header" href="#启发">启发：</a></h2>
<p>【Bernstein基函数的递推公式】：<a href="BsplineCurve/../BezierCurve/Property.html">link</a></p>
<p>思路：</p>
<ul>
<li>局部处处类似定义，由一个基函数平移得到</li>
<li>高阶的基函数由2个低阶的基函数“升阶”得到，利于保持一些良好的性质，比如提高光滑性</li>
</ul>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。
https://caterpillarstudygroup.github.io/GAMES102_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="构造b样条基函数-以三次为例"><a class="header" href="#构造b样条基函数-以三次为例">构造B样条基函数： 以三次为例</a></h1>
<h2 id="1-参数化"><a class="header" href="#1-参数化">1. 参数化</a></h2>
<p>型值点参数，建立 \(d_i 与t_i\)之间的关系。<br />
<img src="BsplineCurve/../assets/%E6%9B%B2%E7%BA%BF6.png" alt="" /></p>
<blockquote>
<p>👆 图中是均匀参数化的例子。 \(i\) 是参数， \(i\) 的取值构成节点向量基函数通过结点向量来定义，每个基函数定义在几个特定的节点上。</p>
</blockquote>
<h2 id="2-构造基函数𝑏𝑡"><a class="header" href="#2-构造基函数𝑏𝑡">2. 构造基函数𝑏(𝑡)</a></h2>
<h3 id="𝑏𝑡应满足以下性质"><a class="header" href="#𝑏𝑡应满足以下性质">𝑏(𝑡)应满足以下性质</a></h3>
<p><img src="BsplineCurve/../assets/%E6%9B%B2%E7%BA%BF5.png" alt="" /></p>
<ul>
<li>𝑏(𝑡) is \(C^2\) continuous</li>
<li>𝑏(𝑡) is piecewise polynomial, degree 3 (cubic)</li>
<li>𝑏(𝑡) is has local support</li>
<li>Overlaying shifted \(𝑏 (𝑡+i)\) forms a partition of unity</li>
<li>\(𝑏(𝑡)\ge 0 \) for all 𝑡<br />
In short:</li>
<li>All desirable properties build into the basis</li>
<li>Linear combinations will inherit these</li>
</ul>
<h3 id="基函数的构造方法"><a class="header" href="#基函数的构造方法">基函数的构造方法</a></h3>
<p>Repeated linear interpolation：从0阶（水平直线）开始，使用\(t\)和\((1-t)\)进行线性组合、即升阶每升一次阶，曲线会更光滑，跨度区间会多覆盖一个结点。</p>
<p><img src="BsplineCurve/../assets/%E6%9B%B2%E7%BA%BF7.png" alt="" /><br />
<img src="BsplineCurve/../assets/%E6%9B%B2%E7%BA%BF8.png" alt="" /><br />
<img src="BsplineCurve/../assets/%E6%9B%B2%E7%BA%BF9.png" alt="" /></p>
<h3 id="基函数的定义"><a class="header" href="#基函数的定义">基函数的定义</a></h3>
<h4 id="de-boor-recursion-uniform-k阶-b样条基函数的定义"><a class="header" href="#de-boor-recursion-uniform-k阶-b样条基函数的定义">De Boor Recursion: uniform k阶 B样条基函数的定义</a></h4>
<blockquote>
<p>Uniform:使用均匀参数化</p>
</blockquote>
<p><img src="BsplineCurve/../assets/%E6%9B%B2%E7%BA%BF10.png" alt="" /></p>
<h4 id="bspline-curves-general-case"><a class="header" href="#bspline-curves-general-case">B‐spline curves: general case</a></h4>
<blockquote>
<p>此页公式定义在非均匀结点上。</p>
</blockquote>
<p>Given: knot sequence \(t_0 &lt; t_1 &lt; \cdots &lt; t_n &lt; \cdots &lt; t_{n+k}\)
\((t_0,t_i,\cdots,t_{n=k})\) is called knot vector</p>
<p>Normalized B‐spline functions \(N_{i,k}\)of the order (degree \(k-1\)) are defined as:</p>
<p>$$
N_{i,1}(t)=\begin{cases}
 1,t_i\le t&lt;t_{i+1}\\
\\
0,otherwise
\end{cases}
$$</p>
<p>$$
N_{i,1}(t)=\frac{t-t_i}{t_{i+k-1}-t_i} N_{i,k-1}(t)+\frac{t_{i+k}-t}{t_{i+k}-t_{i+1}}N_{i+1,k-1}(t)
$$</p>
<p>for  \(k&gt;1\), and \(i=0,...,n\)</p>
<h3 id="基函数的例子"><a class="header" href="#基函数的例子">基函数的例子</a></h3>
<h4 id="example-1"><a class="header" href="#example-1">Example 1</a></h4>
<p><img src="BsplineCurve/../assets/%E6%9B%B2%E7%BA%BF11.png" alt="" /></p>
<p>$$
N_{i,1}(t)=\begin{cases}
 1,t_i\le t&lt;t_{i+1}\\
0,otherwise
\end{cases}
$$</p>
<p>$$
N_{i,1}(t)=\frac{t-t_i}{t_{i+k-1}-t_i} N_{i,k-1}(t)+\frac{t_{i+k}-t}{t_{i+k}-t_{i+1}}N_{i+1,k-1}(t)
$$</p>
<p>for\( k&gt;1,\) and \(i=0,...,n\)</p>
<blockquote>
<p>\(N_{i, k}:K 代表阶数，i代表第i\)个基函数。<br />
\(N_{1, 1}和 N_{2, 1}组合，得到 N_{1, 2}\)<br />
\(N_{1, 2}和 N_{2, 2}组合，得到 N_{1, 3}\)</p>
</blockquote>
<h4 id="example--2"><a class="header" href="#example--2">Example  2</a></h4>
<p><img src="BsplineCurve/../assets/%E6%9B%B2%E7%BA%BF12.png" alt="" /></p>
<h4 id="example--3"><a class="header" href="#example--3">Example  3</a></h4>
<p><img src="BsplineCurve/../assets/%E6%9B%B2%E7%BA%BF13.png" alt="" /></p>
<h2 id="3-基函数的平移和伸缩"><a class="header" href="#3-基函数的平移和伸缩">3. 基函数的平移和伸缩</a></h2>
<p>每个基函数是同一个基函数的平移或伸缩得到，其中第 \(i\) 个基函数是以\(t_i\)为中心的局部函数。</p>
<p><img src="BsplineCurve/../assets/%E6%9B%B2%E7%BA%BF25.png" alt="" /></p>
<h1 id="基函数性质"><a class="header" href="#基函数性质">基函数性质</a></h1>
<h2 id="局部性"><a class="header" href="#局部性">局部性</a></h2>
<p>\(𝑁_{i,k}(t)\) &gt; 0 for \(𝑡_i &lt; 𝑡 &lt; t_{i+k}\)<br />
\(𝑁_{i,k}(t)\) = 0 for \(𝑡_0 &lt; 𝑡 &lt; t_i\) or \(t_{i+k} &lt;t &lt; t_{n+k}\)</p>
<p>The interval \([t_i,t_{i+k}]\), is called support of \(N_{i,k}\)</p>
<h2 id="权性--凸包性"><a class="header" href="#权性--凸包性">权性 + 凸包性</a></h2>
<p>\(\sum_{i=0}^{n} N_{i,k}(t)=1 \)for \(t_{k-1}\le t\le t_{n+1} \)</p>
<h2 id="光滑性"><a class="header" href="#光滑性">光滑性</a></h2>
<p>For \(\quad t_i\le t_j\le t_{i+k}\), the basis functions  \(N_{i,k}(t)\) are \(C^{k-2} \) at the knots \(t_j\)</p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。
https://caterpillarstudygroup.github.io/GAMES102_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bspline-curves-的定义"><a class="header" href="#bspline-curves-的定义">B‐spline curves 的定义</a></h1>
<p>Given:<br />
\(𝑛+1\) control points \(𝒅_0,\dots,d_n∈\mathbb{R} ^3\)<br />
参数化向量 \(𝑇=(t_0,\dots,t_n,\dots,t_{n+k})\)</p>
<blockquote>
<p>\(𝒅_i\) 又称为 de Boor points</p>
</blockquote>
<p>Then：<br />
k阶 B‐spline curve 𝒙(𝑡) 定义为：</p>
<p>$$
x(t)=\sum_{i=0}^{n} N_{i,k}(t)\cdot d_i
$$</p>
<blockquote>
<p>B样条本质是分段曲线、但通过 local basis funchion 的方法，有一个公式统一了所有分段曲线。</p>
</blockquote>
<h1 id="bspline-curves-的例子"><a class="header" href="#bspline-curves-的例子">B‐spline curves 的例子</a></h1>
<h2 id="k4n5"><a class="header" href="#k4n5">\(k=4,n=5\)</a></h2>
<p><img src="BsplineCurve/../assets/%E6%9B%B2%E7%BA%BF14.png" alt="" /></p>
<p>Support intervals of \(𝑁_{i,k}\)</p>
<blockquote>
<p>由于\(n=5\)，\(d_0-d_5\)定义第一条曲线，\(d_1-d_6\)定义第二条曲线。<br />
本质上是分段曲线，在连接点上C3连续。</p>
</blockquote>
<h2 id="multiple-weighted-knot-vectors"><a class="header" href="#multiple-weighted-knot-vectors">Multiple weighted knot vectors</a></h2>
<p>例子中的\(𝑇=(t_0,\dots,t_n,\dots,t_{n+k})\) 满足 \(t_0&lt; t_1&lt; \dots&lt; t_{n+k}\)<br />
但也可以定义为\(t_0\le t_1\le \dots\le t_{n+k}\)，即结点重合。</p>
<blockquote>
<p>结点重合会导致连续性下降，每增加一重、连续性减一。可以以此方法控制曲线的连续性。<br />
可以根据重合度控制结点的光滑性。<br />
• The recursive definition of the B spline function \(𝑁_{i,k}(i=0,\dots,n) \) works nonetheless as long as no more than 𝑘 knots coincide</p>
</blockquote>
<h2 id="首未端点插值"><a class="header" href="#首未端点插值">首未端点插值</a></h2>
<p>set: \(t_0=t_1=\dots=t_{k-1}\) and \(t_{n+1}=t_{n+2}=\dots=t_{n+k}\)</p>
<p>\(𝒅_0\) and \(𝒅_n\) are interpolated</p>
<p><img src="BsplineCurve/../assets/%E6%9B%B2%E7%BA%BF16.png" alt="" /></p>
<blockquote>
<p>要使首未端点被插值，需要把首未端点设置为\(K\)重。把B-spline curve 的两个端点都设成\(n-1\)重，就会退化为 Bezier curve.</p>
</blockquote>
<h1 id="bspline-curves的性质"><a class="header" href="#bspline-curves的性质">B‐spline curves的性质</a></h1>
<h2 id="性质1退化"><a class="header" href="#性质1退化">性质1：退化</a></h2>
<p>要使首未端点被插值，需要把首未端点设置为\(K\)重。把B-spline curve 的两个端点都设成\(n-1\)重，就会退化为 Bezier curve.</p>
<h2 id="性质2连续性"><a class="header" href="#性质2连续性">性质2：连续性</a></h2>
<p>结点重合会reduction of continuity of\(𝑥(𝑡)\)。𝑙重结点 \((1\le 𝑙 &lt; 𝑘)\) means \(𝐶^{k-𝑙-1}\) continuity</p>
<h2 id="性质3局部性"><a class="header" href="#性质3局部性">性质3：局部性</a></h2>
<p>moving of \(𝑑_i\) only changes the curve in the region \([𝑡_i,t_{i+k}]\)<br />
The insertion of new de Boor points does not change the polynomial degree of the curve segments</p>
<p><img src="BsplineCurve/../assets/%E6%9B%B2%E7%BA%BF19.png" alt="" /></p>
<blockquote>
<p>[1:10:41] 💡 在神经网络中把 acfivation 改为 local basis funchion. 这样，只需更新 N N 的部分参数。</p>
</blockquote>
<h1 id="b样条的计算-the-de-boor-algorithm"><a class="header" href="#b样条的计算-the-de-boor-algorithm">B样条的计算 The de Boor algorithm</a></h1>
<h2 id="算法背景"><a class="header" href="#算法背景">算法背景</a></h2>
<p><strong>输入：</strong><br />
de Boor points：\(𝒅_0,…,𝒅_n\) </p>
<p>Knot vector：</p>
<p>$$
(t_0,\cdots ,t_{k-1}=t_0,t_k,t_{k+1},\dots ,t_n,t_{n+1},\dots ,t_{n+k}=t_{n+1})
$$</p>
<p><strong>输出：</strong><br />
Curve point \(𝒙(𝑡)\) of the k 阶B‐spline curve</p>
<h2 id="算法过程"><a class="header" href="#算法过程">算法过程</a></h2>
<blockquote>
<p>不断地插入结点就可以得到B样条曲线</p>
</blockquote>
<ol>
<li>Search index with \(t_r\le  t\le t_{r+1}\)</li>
<li></li>
</ol>
<pre><code>for i=r-k+1,... ,r
    d^0_i=d_i
for j=1, ... ,k-1   
    for i=r-k+1+j,\cdots ,r    
        a_i^j={t-t_i}/{t_{i+k-j}-t_i}
        d_i^j=(1-a^j_i) \cdot  d^{j-1}_{i-1}+a_j^i \cdot  d^{j-1}_i
d^{k-1}_r=x(t)    
</code></pre>
<h1 id="b样条的其他理论知识"><a class="header" href="#b样条的其他理论知识">B样条的其他理论知识</a></h1>
<ul>
<li>B样条的许多性质<br />
• 局部凸包性、变差缩减性、包络性<br />
• B样条的导数、积分递推式、几何作图</li>
<li>重节点的B样条基函数及B样条曲线</li>
<li>Bezier样条曲线转换为B样条曲线</li>
<li><strong>B样条插值方法</strong></li>
<li>…</li>
</ul>
<p><img src="BsplineCurve/../assets/%E6%9B%B2%E7%BA%BF21.png" alt="" /></p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。
https://caterpillarstudygroup.github.io/GAMES102_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bézier曲线"><a class="header" href="#bézier曲线">Bézier曲线</a></h1>
<p>• 类似RBF函数：对每个控制点叠加权函数<br />
• 几何设计观点：给定控制顶点{\(b_i,i=0\sim n\)}，使用一组（随\(t\)变化的）权系数函数{\(B_i^n(t),i=0\sim n\)} 对它们进行线性组合，得到的点的集合</p>
<p>$$
x(t)=\sum_{i=0}^{n} B^n_i(t)\cdot b_t
$$</p>
<p><img src="NURBS/../assets/%E6%9C%89%E7%90%86%E6%9B%B2%E7%BA%BF-1.png" alt="" /></p>
<blockquote>
<p>Bezier曲线的性质来源于Bernstein<strong>基函数</strong>的性质</p>
</blockquote>
<h1 id="b样条曲线"><a class="header" href="#b样条曲线">B样条曲线</a></h1>
<p>• Bézier曲线、RBF函数：每个控制点上的权系数函数都是全局（定义在整个定义域）的<br />
• B样条曲线：每个控制点上的权系数函数是局部定义的（定义在其参数节点附近的支集）</p>
<p><img src="NURBS/../assets/%E6%9C%89%E7%90%86%E6%9B%B2%E7%BA%BF-2.png" alt="" /></p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。
https://caterpillarstudygroup.github.io/GAMES102_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bezier曲线存在的问题"><a class="header" href="#bezier曲线存在的问题">Bezier曲线存在的问题</a></h1>
<p>Bézier曲线无法表示圆弧！</p>
<p><img src="NURBS/../assets/%E6%9C%89%E7%90%86%E6%9B%B2%E7%BA%BF-3.png" alt="" /></p>
<p>Evaluation of \((𝒙^𝟐+𝒚^𝟐)\) for points on the Bezier curve</p>
<p><img src="NURBS/../assets/%E6%9C%89%E7%90%86%E6%9B%B2%E7%BA%BF-4.png" alt="" /></p>
<h1 id="投影几何"><a class="header" href="#投影几何">投影几何</a></h1>
<p>齐次坐标：\(x\longrightarrow \binom{wx}{w} \)</p>
<p>例如：</p>
<ul>
<li>2D case:</li>
</ul>
<p>$$
\binom{x}{y}  →\begin{pmatrix}wx
 \\wy 
 \\w
\end{pmatrix}
$$</p>
<ul>
<li>3D case:</li>
</ul>
<p>$$
\begin{pmatrix}x
 \\y 
 \\z
\end{pmatrix} →\begin{pmatrix}wx
 \\wy 
 \\wz
 \\w
\end{pmatrix}
$$</p>
<p><img src="NURBS/../assets/%E6%9C%89%E7%90%86%E6%9B%B2%E7%BA%BF-5.png" alt="" /></p>
<blockquote>
<p>用欧式坐标表达的空间称为欧氏空间。用齐次坐标表达的空间称为投影空间</p>
</blockquote>
<h1 id="构造有理bezier曲线"><a class="header" href="#构造有理bezier曲线">构造有理Bezier曲线</a></h1>
<h2 id="基本形式"><a class="header" href="#基本形式">基本形式</a></h2>
<p>构造\(\mathbb{R} ^n\)空间中的d阶有理Bezier曲线<br />
（1）在\(n+1\)维空间定义 d阶Bezier 曲线</p>
<p>$$
𝒇^{(hom)}(t)=\sum_{i=0}^{n}B_i^{(d)}(t)P_i,P_i\in \mathbb{R} ^{n+1}
$$</p>
<p>（2）把最后一个维度作为齐次项<br />
（3）再通过除法映射到\(n\)维,得到欧氏空间的曲线n</p>
<p>$$
𝒇^{(eucl)}(t)=\frac{\sum_{i=0}^{n}B_i^{(d)}(t)\begin{pmatrix}p_i^{(1)}
 \\\cdots 
 \\p_i^{(n)}
\end{pmatrix}}{\sum_{i=0}^{n}B_i^{(d)}(t)P_i^{(n+1)}}
$$</p>
<h2 id="一般形式"><a class="header" href="#一般形式">一般形式</a></h2>
<p>每个控制顶点上设置一个权系数</p>
<p>$$
{f}^{(eucl)} (t)=\frac{\sum_{i=0}^{n}B_i^{(d)} (t)w_ip_i}{\sum_{i=0}^{n}B_i^{(d)} (t)w_i } 
$$</p>
<p>$$
p_i=\begin{pmatrix}p_i^{(1)}
 \\\cdots 
 \\p_i^{(n)}
\end{pmatrix}
$$</p>
<h2 id="另一种形式"><a class="header" href="#另一种形式">另一种形式</a></h2>
<p>$$
{f}^{(eucl)} (t)=\sum_{i=0}^{n}p_i =\frac{B_i^{(d)} (t)w_i}{\sum_{i=0}^{n}B_i^{(d)} (t)w_i } =\sum_{i=0}^{n}q_i(t)p_i 
$$</p>
<p>with \(\sum_{i=0}^{n} q_i(t)=1\)</p>
<p>如权系数都相等，则退化为Bezier曲线</p>
<blockquote>
<p>也可以看作是权函数\(q_i(t)\)变成了有理形式的权函数。</p>
</blockquote>
<h1 id="有理bezier曲线的几何解释"><a class="header" href="#有理bezier曲线的几何解释">有理Bezier曲线的几何解释</a></h1>
<h2 id="几何解释"><a class="header" href="#几何解释">几何解释</a></h2>
<p>高维的Bezier曲线的中心投影</p>
<p><img src="NURBS/../assets/%E6%9C%89%E7%90%86%E6%9B%B2%E7%BA%BF-6.png" alt="" /></p>
<blockquote>
<p>3D空间中的多项式曲线投影到2D有可能是圆。因为3D坐标到2D坐标的转换要经过一个除法。<br />
数学上的有理是带分母的意思。</p>
</blockquote>
<h2 id="2次有理bezier曲线表示圆"><a class="header" href="#2次有理bezier曲线表示圆">2次有理Bezier曲线表示圆</a></h2>
<p><img src="NURBS/../assets/%E6%9C%89%E7%90%86%E6%9B%B2%E7%BA%BF-8.png" alt="" /></p>
<h1 id="权系数对曲线形状的影响"><a class="header" href="#权系数对曲线形状的影响">权系数对曲线形状的影响</a></h1>
<p>控制顶点的权系数越大，曲线就越靠近该点</p>
<p><img src="NURBS/../assets/%E6%9C%89%E7%90%86%E6%9B%B2%E7%BA%BF-7.png" alt="" /></p>
<blockquote>
<p>调整控制顶点的位置或权重都能控制曲线。</p>
</blockquote>
<h1 id="有理bezier曲线的性质"><a class="header" href="#有理bezier曲线的性质">有理Bezier曲线的性质</a></h1>
<p>具有Bezier曲线的大部分性质(设\(w_i&gt;0,i=1\sim n\)):<br />
• 端点插值<br />
• 端点切线<br />
• 凸包性<br />
• 导数递推性<br />
• de Casteljau作图算法<br />
• …</p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。
https://caterpillarstudygroup.github.io/GAMES102_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nurbs"><a class="header" href="#nurbs">NURBS</a></h1>
<h2 id="定义-4"><a class="header" href="#定义-4">定义</a></h2>
<p>NURBS = <strong>Non‐Uniform</strong> Rational B‐Spline = 非均匀有理B样条</p>
<p>(\(𝑁^{(d)}_i\) :B‐spline basis function 𝑖 of degree d)</p>
<p>$$
f(t)=\frac{\sum_{i=1}^{n}N_i^{(d)}(t)w_ip_i }{ \sum_{i=1}^{n}N_i^{(d)}(t)w_i} 
$$</p>
<ul>
<li>Uniform：均匀参数化，结点向量均匀</li>
<li>Non‐Uniform：非均匀参数化，结点向量非均匀</li>
</ul>
<blockquote>
<p>非均匀,使用了非均匀的参数化，参数间距不一致，甚至有可能重合。 </p>
</blockquote>
<h2 id="de-boor-algorithm"><a class="header" href="#de-boor-algorithm">De Boor algorithm</a></h2>
<p>similar to rational de Casteljau alg.</p>
<ul>
<li>option 1. – apply separately to numerator, denominator</li>
<li>option 2. – normalize weights in each intermediate result</li>
</ul>
<p>the second option is numerically more stable</p>
<blockquote>
<p>这一部分没讲</p>
</blockquote>
<h1 id="影响nurbs曲线建模的因素"><a class="header" href="#影响nurbs曲线建模的因素">影响NURBS曲线建模的因素</a></h1>
<p>• 控制顶点：用户交互的手段<br />
• 节点向量：决定了B样条基函数<br />
• 权系数：也影响曲线的形状，生成圆锥曲线等</p>
<p><img src="NURBS/../assets/%E6%9C%89%E7%90%86%E6%9B%B2%E7%BA%BF-9.png" alt="" /></p>
<h1 id="nurbs曲线的性质"><a class="header" href="#nurbs曲线的性质">NURBS曲线的性质</a></h1>
<p>大部分与Bezier/B样条曲线类同：具有良好的几何直观性</p>
<blockquote>
<p>[24:18] 变差缩减：曲线与直线相交，其交点数不多于控制顶点的凸包与直线的交点数。<br />
此性质用于曲线与直线求交。</p>
</blockquote>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。
https://caterpillarstudygroup.github.io/GAMES102_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bezier曲线的作图法"><a class="header" href="#bezier曲线的作图法">Bezier曲线的作图法</a></h1>
<p>DeCasteljau算法：<a href="SubdivisionCurves/../BezierCurve/DeCasteljau%E7%AE%97%E6%B3%95.html">link</a></p>
<p>几何直观性：逐步割角、磨光，类似于雕塑雕刻过程</p>
<blockquote>
<p>作图法中每画一条线段，可以看作是对凸包多边形的割角。<br />
对多边形不断地割角可以得到一条光滑细线。 </p>
</blockquote>
<h1 id="要解决的问题"><a class="header" href="#要解决的问题">要解决的问题</a></h1>
<p>输入：一个简单多边形（控制多边形）</p>
<p><img src="SubdivisionCurves/../assets/%E7%BB%86%E6%9B%B23.png" alt="" /></p>
<p>输出：一条与之关联的光滑曲线</p>
<p><img src="SubdivisionCurves/../assets/%E7%BB%86%E6%9B%B24.png" alt="" /></p>
<p>解决方法：通过不断“割角”构造曲线？<br />
（1）给定一个简单多边形<br />
（2）通过一定规则，割角磨光，产生更多边的多边形<br />
（3）不断迭代操作割角磨光，产生（极限）光滑曲线</p>
<p><img src="SubdivisionCurves/../assets/%E7%BB%86%E6%9B%B25.png" alt="" /></p>
<h1 id="细分方法的思想"><a class="header" href="#细分方法的思想">细分方法的思想</a></h1>
<p>两个步骤：</p>
<ul>
<li>拓扑规则：加入新点，组成新多边形 (\(splitting\))</li>
</ul>
<blockquote>
<p>在哪加:在哪两个点之间加新点。</p>
</blockquote>
<ul>
<li>几何规则：移动顶点，局部加权平均 (\(averaging\))<br />
• 对所有顶点都移动：逼近型<br />
• 只对新顶点移动：插值型</li>
</ul>
<blockquote>
<p>加在哪：新点的坐标是多少。通常是旧点的线性组合，因这样算得快。</p>
</blockquote>
<p><img src="SubdivisionCurves/../assets/%E7%BB%86%E6%9B%B26.png" alt="" /></p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。
https://caterpillarstudygroup.github.io/GAMES102_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chaikin割角法1974"><a class="header" href="#chaikin割角法1974">Chaikin割角法[1974]</a></h1>
<h2 id="具体步骤"><a class="header" href="#具体步骤">具体步骤</a></h2>
<p>加在哪：每条边取中点，生成新点</p>
<p><img src="SubdivisionCurves/../assets/%E7%BB%86%E6%9B%B29.png" alt="" /></p>
<p>在哪加：每个点与其相邻点平均（顺时针），点分裂成边（割角），老点被抛弃（逼近型）</p>
<p>$$
{\nu }' _{2i}=\frac{1}{4} \nu _{i-1}+\frac{3}{4} \nu _i
$$</p>
<p>$$
{\nu }' _{2i+1}=\frac{3}{4} \nu _{i}+\frac{1}{4} \nu _{i+1}
$$</p>
<p>迭代生成曲线</p>
<p><img src="SubdivisionCurves/../assets/%E7%BB%86%E6%9B%B27.png" alt="" /></p>
<h2 id="细分结果"><a class="header" href="#细分结果">细分结果</a></h2>
<p><img src="SubdivisionCurves/../assets/%E7%BB%86%E6%9B%B210.png" alt="" /></p>
<p>收敛后的极限曲线是由初始多边形决定的二次均匀B样条曲线。<br />
节点处\(𝐶^1\)，其余点处\(𝐶^\infty \)</p>
<h1 id="均匀三次b样条曲线细分方法"><a class="header" href="#均匀三次b样条曲线细分方法">均匀三次B样条曲线细分方法</a></h1>
<p>• 拓扑规则：边分裂成两条新边<br />
• 几何规则：</p>
<p><img src="SubdivisionCurves/../assets/%E7%BB%86%E6%9B%B211-1.png" alt="" /></p>
<p>$$
{\nu }' _{2i}=\frac{1}{8} \nu _{i-1}+\frac{3}{4} \nu _i+\frac{1}{8} \nu _{i+1}
$$</p>
<p>$$
{\nu }' _{2i+1}=\frac{1}{2} \nu _{i}+\frac{1}{2} \nu _{i+1}
$$</p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。
https://caterpillarstudygroup.github.io/GAMES102_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="细分曲线的性质证明"><a class="header" href="#细分曲线的性质证明">细分曲线的性质证明</a></h1>
<h2 id="证明的思路"><a class="header" href="#证明的思路">证明的思路</a></h2>
<p>新顶点是老顶点的线性组合，据此将细分过程表达成矩阵形式<br />
讨论细分矩阵的谱性质（特征根）</p>
<p><img src="SubdivisionCurves/../assets/%E7%BB%86%E6%9B%B212-1.png" alt="" /></p>
<blockquote>
<p>[41:07]证明的思路<br />
这个感受野不离断变大的过程像卷积。 </p>
</blockquote>
<h1 id="chaikin细分"><a class="header" href="#chaikin细分">Chaikin细分</a></h1>
<h2 id="矩阵形式"><a class="header" href="#矩阵形式">矩阵形式</a></h2>
<p>Control points at level   \(𝑙: 𝒑^{(l)}_i\)</p>
<p>“Splitted” points at level \(𝑙+1: \tilde{p} ^{(l+1)}_i\)</p>
<p>“Averaged” control points at level \( 𝑙+1:𝒑^{(l+1)}_i\)</p>
<p><img src="SubdivisionCurves/../assets/%E7%BB%86%E6%9B%B214.png" alt="" /></p>
<p><img src="SubdivisionCurves/../assets/%E7%BB%86%E6%9B%B215.png" alt="" /></p>
<h2 id="极限情况"><a class="header" href="#极限情况">极限情况</a></h2>
<p>极限曲线上的点可由<strong>细分矩阵</strong>的幂次的极限求得:</p>
<p>$$
\begin{pmatrix}x_-^{[\infty ]}
 \\x^{[\infty ]} 
 \\x_+^{[\infty ]}
\end{pmatrix}=\lim_{k \to \infty} M^k_{srbdiv}\begin{pmatrix}x_-^{[l]}
 \\x^{[l]} 
 \\x_+^{[l ]}
\end{pmatrix}
$$</p>
<ul>
<li>收敛的必要条件:<br />
• 细分矩阵的最大特征根为1<br />
• 否则会爆炸 (&gt;1) 或收缩 (&lt;1)</li>
</ul>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。
https://caterpillarstudygroup.github.io/GAMES102_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="插值型细分方法"><a class="header" href="#插值型细分方法">插值型细分方法</a></h1>
<p>细分方法的特点：保留原有顶点不动。对每条边，增加一个新顶点。不断迭代，生成一条曲线</p>
<ul>
<li>可以看成是“<strong>补角法</strong>”</li>
</ul>
<p><img src="SubdivisionCurves/../assets/%E7%BB%86%E6%9B%B218.png" alt="" /></p>
<h2 id="4点插值型细分"><a class="header" href="#4点插值型细分">4点插值型细分</a></h2>
<h3 id="细分规则"><a class="header" href="#细分规则">细分规则</a></h3>
<p><img src="SubdivisionCurves/../assets/%E7%BB%86%E6%9B%B219.png" alt="" /></p>
<blockquote>
<p>👆 蓝点分别是两条线的中点、新增点在中点连线的延长线上。</p>
</blockquote>
<p><img src="SubdivisionCurves/../assets/%E6%9B%B2%E7%BA%BF222.png" alt="" /></p>
<p>当\(𝛼∈(0,\frac{1}{8})\) 时，生成的细分曲线是光滑的；否则，细分曲线非光滑，生成了分形曲线。</p>
<blockquote>
<p>🔎 Nira Dyn, David Levin, John A. Gregory A 4‐point interpolatory subdivision<br />
scheme for curve design. Computer Aided Geometric Design, 4(4): 257‐268, 1987.</p>
</blockquote>
<h3 id="4点插值型细分曲线的例子"><a class="header" href="#4点插值型细分曲线的例子">4点插值型细分曲线的例子</a></h3>
<p><img src="SubdivisionCurves/../assets/%E7%BB%86%E6%9B%B221.png" alt="" /></p>
<h2 id="一般2n点插值细分方法"><a class="header" href="#一般2n点插值细分方法">一般：2n点插值细分方法</a></h2>
<p>极限曲线的连续阶随着\(n\)增大而增加</p>
<ul>
<li>2点插值细分方法</li>
</ul>
<p>$$
P_{2i+1}^{k+1}=\frac{1}{2} (P^k_i+P^k_{i+1})
$$</p>
<ul>
<li>4点插值细分方法</li>
</ul>
<p>$$
P_{2i+1}^{k+1}=-\frac{1}{16} P^k_{i-1}+\frac{9}{16}P^k_{i}+\frac{9}{16}P^k_{i+1}-\frac{1}{16}P^k_{i+2}
$$</p>
<ul>
<li>6点插值细分方法</li>
</ul>
<p>$$
P_{2i+1}^{k+1}=\frac{3}{256} P^k_{i-2}-\frac{25}{256}P^k_{i-1}+\frac{150}{256}P^k_{i}+\frac{150}{256}P^k_{i+1}-\frac{25}{256}P^k_{i+2}+\frac{3}{256}P^k_{i+3}
$$</p>
<h1 id="非线性细分方法"><a class="header" href="#非线性细分方法">非线性细分方法</a></h1>
<h2 id="基于双圆弧插值的曲线细分方法"><a class="header" href="#基于双圆弧插值的曲线细分方法">基于双圆弧插值的曲线细分方法</a></h2>
<p>给定一条边,新点为插值其两端点及两端切向的双圆弧的一个连接点,也是其两端点两端切向的所确定三角形的内心.</p>
<p>每个细分步骤后调整切向.</p>
<p><img src="SubdivisionCurves/../assets/%E7%BB%86%E6%9B%B225.png" alt="" /></p>
<blockquote>
<p>要通过解方程或优化来解</p>
</blockquote>
<p>极限曲线\(𝐺^2\)，光顺，保形</p>
<p><img src="SubdivisionCurves/../assets/%E7%BB%86%E6%9B%B226.png" alt="" /></p>
<h2 id="参考文献"><a class="header" href="#参考文献">参考文献</a></h2>
<p>• Denis Zorin et al.Subdivision for Modeling and Animation. SIGGRAPH 2000 Course Notes<br />
• Warren and Weimer. Subdivision Methods for Geometric Design: A Constructive Approach. Morgan-Kaufmann Publishers, 2002<br />
• M.S. Sabin. Recent Progress in Subdivision: a Survey. Advances in Multiresolution for Geometric Modelling Mathematics and Visualization 2005, 203‐230<br />
• Cashman. Beyond Catmull–Clark? A survey of advances in subdivision surface methods. Compute Graphics Forum,  31(1), 2012, 42–61</p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。
https://caterpillarstudygroup.github.io/GAMES102_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="隐式曲线"><a class="header" href="#隐式曲线">隐式曲线</a></h1>
<h1 id="回顾参数曲线"><a class="header" href="#回顾参数曲线">回顾：参数曲线</a></h1>
<p>曲线定义在一个单参数\(t\)的区间上，有\(t\)上的基函数来线性组合控制顶点来定义</p>
<p>$$
x(t)=\sum_{i=0}^{n} B^n_i(t)b_i
$$</p>
<p><img src="ImplicitCurves/../assets/%E7%98%BE%E6%9B%B21.png" alt="" /> </p>
<blockquote>
<p>曲线的性质来源于<strong>基函数</strong>的性质</p>
</blockquote>
<h1 id="回顾平面曲线的定义方法"><a class="header" href="#回顾平面曲线的定义方法">回顾：平面曲线的定义方法</a></h1>
<h2 id="显式函数"><a class="header" href="#显式函数">显式函数</a></h2>
<p>$$
f:R^1\longrightarrow R^1
$$</p>
<p>$$
y=f(x)
$$</p>
<p><img src="ImplicitCurves/../assets/%E7%98%BE%E6%9B%B22.png" alt="" /></p>
<blockquote>
<p>👆 点\((𝑥,𝑓(𝑥)),𝑥∈[a,b]\)的轨迹</p>
</blockquote>
<h2 id="参数曲线"><a class="header" href="#参数曲线">参数曲线</a></h2>
<p>\(p:R^1\longrightarrow R^2\)<br />
\(x=x(t)\)<br />
\(y=y(t)\)</p>
<p><img src="ImplicitCurves/../assets/%E7%98%BE%E6%9B%B23.png" alt="" /> </p>
<blockquote>
<p>👆 点\((𝑥(𝑡),𝑦(𝑡)),𝑡∈[𝑎,𝑏]\)的轨迹</p>
</blockquote>
<h2 id="隐式函数"><a class="header" href="#隐式函数">隐式函数</a></h2>
<p>自变量\(x\)和应变量\(y\)的关系非显式关系，是一个隐式的关系（代数方程）：</p>
<p>$$
f(x,y)=0
$$</p>
<p>比如：<br />
• \(𝑎𝑥+𝑏𝑦+𝑐=0\)<br />
• \(𝑥^2+𝑦^2=1\)<br />
• \(𝑦^2=𝑥^3+𝑎𝑥+𝑏\)<br />
• \(𝑥𝑦^2+\ln(𝑥 \) \(\sin 𝑦-𝑒^{y-\sqrt{x} })=\cos (x-\sqrt{x^3-2y} )\)</p>
<blockquote>
<p>所有满足该代数方程的点的轨迹是条曲线</p>
</blockquote>
<p><img src="ImplicitCurves/../assets/%E7%A6%BB%E6%95%A36-1.png" alt="" /></p>
<h2 id="细分曲线"><a class="header" href="#细分曲线">细分曲线</a></h2>
<p><img src="ImplicitCurves/../assets/%E7%A6%BB%E6%95%A37.png" alt="" /></p>
<blockquote>
<p>前三种是连续表达，第四种是线段表达。<br />
连续表达在数学上容易表达。但在应用上有局限。</p>
</blockquote>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。
https://caterpillarstudygroup.github.io/GAMES102_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="隐函数定理"><a class="header" href="#隐函数定理">隐函数定理</a></h1>
<p>对于任意的隐函数，全局上很难写出 \(y=f(x)\)形式。<br />
但在任意一个局部，可以定义出\(y=f(x)\)</p>
<h1 id="隐式曲线的绘制"><a class="header" href="#隐式曲线的绘制">隐式曲线的绘制</a></h1>
<p>将隐函数升高一维，看成是\(x\)和\(y\)的二元函数<br />
\(z=f(x,y), \)<br />
\(x,y\in [a,b]\times [c,d]\)</p>
<p>则该隐式曲线为上述二元函数的0等值线（平面\(z=0\)与\(z=f(x,y)\)的交线）</p>
<p>• \(f(x,y)=0\), 曲线上；<br />
• \(f(x,y)&lt;0\), 曲线的左侧（内部）；<br />
• \(f(x,y)&gt;0\), 曲线的右侧（外部）；</p>
<p><img src="ImplicitCurves/../assets/%E7%98%BE%E6%9B%B24.png" alt="" /> </p>
<blockquote>
<p>找一个隐式函数上的点的过程称为显式化或参数化。这是一个比较难的问题，常用方法是Marching Cube。</p>
</blockquote>
<h1 id="隐式函数表达"><a class="header" href="#隐式函数表达">隐式函数表达</a></h1>
<p>已知一条封闭曲线，如何构造隐式函数表达？</p>
<h2 id="general-case"><a class="header" href="#general-case">General case</a></h2>
<ul>
<li>Non‐zero gradient at zero crossings</li>
<li>Otherwise arbitrary</li>
</ul>
<blockquote>
<p>没有解释这种方法</p>
</blockquote>
<h2 id="signed-implicit-function"><a class="header" href="#signed-implicit-function">Signed implicit function:</a></h2>
<p>sign (𝑓):</p>
<ul>
<li>负：inside</li>
<li>正：outside</li>
</ul>
<h2 id="signed-distance-field-sdf"><a class="header" href="#signed-distance-field-sdf">Signed distance field (SDF)</a></h2>
<p>|𝑓|：distance to the surface<br />
sign(𝑓): negative inside, positive outside</p>
<h2 id="squared-distance-function"><a class="header" href="#squared-distance-function">Squared distance function</a></h2>
<p>𝑓 = \((\)distance to the surface\()^2\)</p>
<p><img src="ImplicitCurves/../assets/%E7%98%BE%E6%9B%B25.png" alt="" /> </p>
<h1 id="微分属性-differential-properties"><a class="header" href="#微分属性-differential-properties">微分属性 Differential Properties</a></h1>
<p>对于曲面表面上的点x，满足以下性质：</p>
<ul>
<li>
<p>\( 𝑓(𝒙)=0\)</p>
</li>
<li>
<p>假设\(𝛻𝑓(𝒙)\ne 0\)，否则为奇异点，不考虑这种情况</p>
</li>
<li>
<p>unit normal为：<br />
$$
𝑛(𝒙)=\frac{\nabla  f(x) }{||\nabla f(x)|| }
$$</p>
<ul>
<li>For signed functions, the normal is pointing outward</li>
<li>For signed distance functions, this simplifies to 𝒏(𝒙)=𝛻𝑓(𝒙)</li>
</ul>
</li>
<li>
<p>mean curvature与the divergence of the unit normal成正比:<br />
$$
-2𝐻(𝒙)=𝛻⋅𝒏(𝒙)=\frac{𝜕}{𝜕𝑥} n_x(x)+\frac{𝜕}{𝜕y}ny(x)+\frac{𝜕}{𝜕z}n_z(x)\\
=𝛻 ⋅\frac{𝛻𝑓(𝒙)}{||𝛻𝑓(𝒙)||}
$$</p>
<ul>
<li>For a signed distance function, the formula simplifies to:</li>
</ul>
</li>
</ul>
<p>$$
-2𝐻(𝒙)=𝛻 ⋅ 𝛻𝑓(𝑥)=\frac{𝜕^2}{𝜕𝑥^2} f(x)+\frac{𝜕^2}{𝜕y^2}f(x)+\frac{𝜕^2}{𝜕z^2}f(x)=𝛻𝑓(𝑥)
$$</p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。
https://caterpillarstudygroup.github.io/GAMES102_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="隐式曲线的绘制-1"><a class="header" href="#隐式曲线的绘制-1">隐式曲线的绘制</a></h1>
<p>输入：一个二元隐式函数\(z=f(x,y)\)<br />
输出：值为\(0(或a)\)的等值线\(z=0\)（或\(z-a=0\)）</p>
<p>目的：<br />
• 将隐式曲线转化为参数形式、离散曲线（多边形）形式<br />
• 绘制曲线</p>
<h1 id="marching-cubes算法-siggraph1987"><a class="header" href="#marching-cubes算法-siggraph1987">Marching Cubes算法 [Siggraph1987]</a></h1>
<p>隐式曲线绘制的最常用方法，网上能找到很多开源实现代码</p>
<h2 id="思想2d-marching-squares"><a class="header" href="#思想2d-marching-squares">思想（2D: Marching Squares）</a></h2>
<p>• 在一些离散格子点上求值<br />
• 然后利用局部连续性插值出值为0的点<br />
• 按一定的顺序连接这些点形成离散曲线</p>
<p><img src="ImplicitCurves/../assets/%E7%98%BE%E6%9B%B26.png" alt="" /></p>
<p><img src="ImplicitCurves/../assets/%E7%98%BE%E6%9B%B27.png" alt="" /></p>
<blockquote>
<p>当格子点足够密，曲线性质基本上符合格子性质。 </p>
</blockquote>
<h2 id="歧义情况"><a class="header" href="#歧义情况">歧义情况</a></h2>
<p>In some cases, different topologies are possible which are all locally plausible:</p>
<p><img src="ImplicitCurves/../assets/%E7%98%BE%E6%9B%B28.png" alt="" /> </p>
<p>解决方法：<br />
1.This is an undersampling artifact，可通过提高分辨率（加密）解决<br />
2.判断函数导数</p>
<h1 id="adaptive--hierarchical-grids"><a class="header" href="#adaptive--hierarchical-grids">Adaptive / hierarchical grids</a></h1>
<p>Perform a quadtree / octree tessellation of the domain (or any other partition into elements)<br />
Refine <strong>where more precision is necessary</strong> (near surface, maybe curvature dependent)<br />
Associate basis functions with each cell (constant or higher order)</p>
<p><img src="ImplicitCurves/../assets/%E7%98%BE%E6%9B%B29.png" alt="" /> </p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。
https://caterpillarstudygroup.github.io/GAMES102_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="隐式曲线的拟合问题"><a class="header" href="#隐式曲线的拟合问题">隐式曲线的拟合问题</a></h1>
<p>输入：平面上的一些点（<strong>设采样自封闭曲线</strong>），一般还需给定或估计点的法向信息<br />
输出：拟合这些点的一个隐式函数，该隐式函数所表达的曲线就是拟合曲线</p>
<p><img src="ImplicitCurves/../assets/%E7%98%BE%E6%9B%B210.png" alt="" /></p>
<blockquote>
<p>假设输入点是无序的，因此无法用细分方法<br />
基本思想：</p>
<ol>
<li>根据已知点设计隐式曲线应满足的约束。使如：
$$
f(x)=0,f(x+n)=1,f(x-n)=-1
$$<br />
也可以根据先验知识构造其它约束，约束越多，拟合越好。 </li>
<li>根据约束进行拟合或插值。</li>
</ol>
</blockquote>
<h1 id="拟合问题的求解步骤"><a class="header" href="#拟合问题的求解步骤">拟合问题的求解步骤</a></h1>
<h2 id="1-估计法向"><a class="header" href="#1-估计法向">1. 估计法向</a></h2>
<p>利用邻近点来估计切平面</p>
<p><img src="ImplicitCurves/../assets/%E7%98%BE%E6%9B%B211.png" alt="" /></p>
<h2 id="2-拟合一个二元函数"><a class="header" href="#2-拟合一个二元函数">2. 拟合一个二元函数</a></h2>
<p>在型值点上值为0，外部（法向方向的点）为正，内部为负</p>
<p><img src="ImplicitCurves/../assets/%E7%98%BE%E6%9B%B212.png" alt="" /></p>
<h1 id="隐式函数构造方法"><a class="header" href="#隐式函数构造方法">隐式函数构造方法</a></h1>
<p>• Blobby molecules<br />
• Metaball<br />
• RBF based method<br />
• Multi‐level partition of unity implicits (MPU)</p>
<blockquote>
<p>自适应的RBF</p>
</blockquote>
<p>• Poisson reconstruction method</p>
<blockquote>
<p>不仅拟合点，还拟合点的梯度</p>
</blockquote>
<p>• Screened Poisson method<br />
• …<br />
<img src="ImplicitCurves/../assets/%E7%98%BE%E6%9B%B213.png" alt="" /></p>
<blockquote>
<p>图1是 MDU,图2是 Melaball</p>
</blockquote>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。
https://caterpillarstudygroup.github.io/GAMES102_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="参数曲面-1"><a class="header" href="#参数曲面-1">参数曲面</a></h1>
<p><a href="https://caterpillarstudygroup.github.io/GAMES102_mdbook/ParametricFitting/VectorValue.html">link</a></p>
<h1 id="张量积曲面"><a class="header" href="#张量积曲面">张量积曲面</a></h1>
<h2 id="定义-5"><a class="header" href="#定义-5">定义</a></h2>
<p>张量积：<a href="https://caterpillarstudygroup.github.io/GAMES102_mdbook/ParametricFitting/Multi.html">link</a></p>
<p>$$
f(u,v)=\sum_{i=1}^{n} \sum_{j=1}^{n}b_i(u)b_j(v)p_{i,j}
$$</p>
<p>$$
=\sum_{i=1}^{n} b_i(u)\sum_{j=1}^{n}b_j(v)p_{i,j}
$$</p>
<p>$$
=\sum_{j=1}^{n} b_j(v)\sum_{i=1}^{n}b_{i}(u)p_{i,j}
$$</p>
<p>曲面是曲线的曲线<br />
先沿一个方向做，然后再沿另一个方向做（方向顺序无关）</p>
<h2 id="张量积曲面的性质"><a class="header" href="#张量积曲面的性质">张量积曲面的性质</a></h2>
<p>类似于曲线情形，性质取决于基函数的性质</p>
<h1 id="bezier曲面"><a class="header" href="#bezier曲面">Bezier曲面</a></h1>
<h2 id="定义-6"><a class="header" href="#定义-6">定义</a></h2>
<p>基于张量基定义的形式，以Bizier基定义的曲面</p>
<p>$$
f(u,v)=\sum_{i=1}^{d} \sum_{j=0}^{d}B_i^{(d)}(u)B_j^{(d)}(v)p_{i,j}
$$</p>
<p><img src="SplineSurfaces/../assets/%E6%9B%B2%E9%9D%A26.png" alt="" /></p>
<h2 id="bezier曲面的性质"><a class="header" href="#bezier曲面的性质">Bezier曲面的性质</a></h2>
<ul>
<li>
<p>边界插值</p>
</li>
<li>
<p>凸包</p>
</li>
<li>
<p>变差缩减</p>
</li>
<li>
<p>几何作图法<br />
<img src="SplineSurfaces/../assets/%E6%9B%B2%E9%9D%A27.png" alt="" /></p>
</li>
<li>
<p>曲面片之间的拼接连续性</p>
</li>
</ul>
<p><img src="SplineSurfaces/../assets/%E6%9B%B2%E9%9D%A210.png" alt="" /></p>
<h1 id="其他曲面"><a class="header" href="#其他曲面">其他曲面</a></h1>
<p>• B样条曲面</p>
<p>• 有理曲面</p>
<p>• NURBS曲面</p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。
https://caterpillarstudygroup.github.io/GAMES102_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="trimmed-nurbs曲面"><a class="header" href="#trimmed-nurbs曲面">Trimmed NURBS曲面</a></h1>
<p>Trimmed：裁剪<br />
Trimmed NURBS曲面：表达带“洞”的曲面</p>
<p>（1）在曲面上定义曲线：使用参数域上的NURBS曲线来定义，然后复合得到曲面上的曲线<br />
（2）用曲线来表达曲面上的洞</p>
<p><img src="SplineSurfaces/../assets/%E6%9B%B2%E9%9D%A212.png" alt="" /></p>
<h1 id="三角域上的bezier曲面片"><a class="header" href="#三角域上的bezier曲面片">三角域上的Bezier曲面片</a></h1>
<blockquote>
<p>背景：张量积形式的 Bezier 曲面定义在矩形曲域，表达很不灵活，难以应用于非规整曲面。<br />
定义在三角面片上的类似于 Bezier 的曲面。</p>
</blockquote>
<p>三角域的Bernstein‐Bezier曲面片：表达非矩形边界的曲面</p>
<p>• 矩形域有时不方便<br />
• 使用三角域来定义曲面片</p>
<h2 id="三角bezier曲面片"><a class="header" href="#三角bezier曲面片">三角Bezier曲面片</a></h2>
<p>$$
F(x)=\sum_{i+j+k=n;i,j,k\ge0}^{} \frac{n!}{i!j!k!} \alpha  ^i\beta ^j\gamma ^kp_{i,j,k}
$$</p>
<p>$$
x=\alpha a+\beta b+\gamma c,\alpha +\beta +\gamma =1
$$</p>
<p><img src="SplineSurfaces/../assets/%E6%9B%B2%E9%9D%A217.png" alt="" /></p>
<blockquote>
<p>\(\alpha ,\beta ,\gamma \) 为三角形上某个点的重心坐标。 </p>
</blockquote>
<h2 id="连续性"><a class="header" href="#连续性">连续性</a></h2>
<p><img src="SplineSurfaces/../assets/%E6%9B%B2%E9%9D%A218.png" alt="" /></p>
<h1 id="张量积体三参数"><a class="header" href="#张量积体三参数">张量积体（三参数）</a></h1>
<h2 id="bezier体"><a class="header" href="#bezier体">Bezier体</a></h2>
<p><img src="SplineSurfaces/../assets/%E6%9B%B2%E9%9D%A219.png" alt="" /></p>
<h1 id="张量积曲面总结"><a class="header" href="#张量积曲面总结">张量积曲面总结</a></h1>
<p>• 两个独立方向的“曲线的曲线”<br />
• 性质大都类同于曲线的性质<br />
• 表达、公式形式比曲线情形复杂<br />
• 特殊问题：角点的光滑性</p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。
https://caterpillarstudygroup.github.io/GAMES102_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="三角域的bernsteinbezier曲面片"><a class="header" href="#三角域的bernsteinbezier曲面片">三角域的Bernstein‐Bezier曲面片</a></h1>
<p>• 矩形域有时不方便<br />
• 使用三角域来定义曲面片</p>
<p><img src="SplineSurfaces/../assets/%E6%9B%B2%E9%9D%A216.png" alt="" /></p>
<blockquote>
<p>背景：张量积形式的 Bezier 曲面定义在矩形曲域，表达很不灵活，难以应用于非规整曲面。<br />
定义在三角面片上的类似于 Bezier 的曲面。</p>
</blockquote>
<h1 id="三角bezier曲面片-1"><a class="header" href="#三角bezier曲面片-1">三角Bezier曲面片</a></h1>
<p>$$
F(x)=\sum_{i+j+k=n;i,j,k\ge0}^{} \frac{n!}{i!j!k!} \alpha  ^i\beta ^j\gamma ^kp_{i,j,k}
$$</p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。
https://caterpillarstudygroup.github.io/GAMES102_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="曲线光顺-curve-fairing"><a class="header" href="#曲线光顺-curve-fairing">曲线光顺 Curve fairing</a></h1>
<p>曲线的连续性：<a href="CurveFairing/../CubicSplines/GeometricContinuity.html">link</a><br />
曲线的微分几何：<a href="CurveFairing/../DiscreteDifferential/Curves.html">link</a></p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。
https://caterpillarstudygroup.github.io/GAMES102_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="从曲线的曲率图的直观理解"><a class="header" href="#从曲线的曲率图的直观理解">从曲线的曲率图的直观理解</a></h1>
<p><img src="CurveFairing/../assets/%E5%85%89%E9%A1%BA1.png" alt="" /> </p>
<blockquote>
<p>看上去光滑的曲线，放大后发现是凹凹凸凸的（右）</p>
</blockquote>
<p><strong>Fairing Design is Important!</strong></p>
<p>• Shoe sole<br />
• Cam profile<br />
• Ship hull：船的表面光顺可以减小水的阻力。<br />
• Car profile<br />
• Plane profile<br />
• …</p>
<h1 id="光顺的定义"><a class="header" href="#光顺的定义">光顺的定义</a></h1>
<h2 id="为什么光顺难以定义"><a class="header" href="#为什么光顺难以定义">为什么光顺难以定义</a></h2>
<p>光顺是一种微观的性质，很难描述<br />
是否光顺取决于人的主观和经验<br />
没有明确的数学定义<br />
没有客观的测量方法</p>
<h2 id="光顺的参考定义"><a class="header" href="#光顺的参考定义">光顺的参考定义</a></h2>
<ol>
<li>[Su and Liu 1978]</li>
</ol>
<ul>
<li>\(C^2\) continuous</li>
<li>curvature plot is free of any unnecessary variation<br />
例如： the distribution of curvature must be as uniform as possible.</li>
</ul>
<ol start="2">
<li>[Farin and Sapidis, 1989]</li>
</ol>
<ul>
<li>curvature plot consists of relatively few 单调段（monotone pieces）</li>
</ul>
<ol start="3">
<li>[Farin 2002]</li>
</ol>
<ul>
<li>curvature plot is continuous</li>
<li>curvature plot consists of only a few monotone pieces.</li>
</ul>
<ol start="4">
<li>[Roulier and Rando, 1994]</li>
</ol>
<ul>
<li>\(C^2\) continuous</li>
<li>minimizes the integral of the squared curvature with respect to arc length</li>
</ul>
<p>$$
\int _ck^2ds=MIN
$$</p>
<blockquote>
<p>这是用整条曲线的能量来定义，是全局面定义法。</p>
</blockquote>
<h2 id="observations-of-fairness"><a class="header" href="#observations-of-fairness">Observations of Fairness</a></h2>
<ul>
<li>Neither a global problem nor a local problem, but a  large local problem<br />
• Not an energy minimization problem</li>
<li>Need not \(C^2\) continuous<br />
• Circular spline</li>
<li>Intimately related to uniform distribution of curvature<br />
• Curvature is a “magnifier” of the curve fairness</li>
</ul>
<blockquote>
<p>不能用\(\int K^2=MIN\) 来定义，有可能k不大，但频繁挠
动，仍不算光顺。</p>
</blockquote>
<h3 id="example-1-1"><a class="header" href="#example-1-1">Example 1</a></h3>
<p>$$
y=\sin x, x\in[0,6\pi]
$$</p>
<p><img src="CurveFairing/../assets/%E5%85%89%E9%A1%BA9.png" alt="" /></p>
<p>The curve is \(C^\infty \)，但并不光顺<br />
原因：拐点（vibration）数太多<br />
拐点即 from convex to concave or from concave to convex</p>
<h3 id="example-2"><a class="header" href="#example-2">Example 2</a></h3>
<p>$$
y=\frac{1+\delta }{0} x^2+\sin x,x\in [0,6\pi ],\delta &gt;0
$$</p>
<p><img src="CurveFairing/../assets/%E5%85%89%E9%A1%BA10-1.png" alt="" /></p>
<p>$$
{y}'' =1+\delta -\sin x &gt; 0
$$</p>
<p>The curve is \(C^\infty \)且一直在递增无拐点，但仍不光顺<br />
原因：\(y''\)有太多振荡。</p>
<h3 id="example-3"><a class="header" href="#example-3">Example 3</a></h3>
<p><img src="CurveFairing/../assets/%E5%85%89%E9%A1%BA11.png" alt="" /></p>
<p>The curvature function \({y}''(x) \)不满足G2连续。<br />
\(k_1\)与\(k_2\)变化不大时光顺。<br />
原因：\({y}''(x) \) has large amplitude at discontinuity point.</p>
<blockquote>
<p>不满足\(C^2\)连续，但光顺，因此\(C^2\)不是必须的。</p>
</blockquote>
<h2 id="曲线的光顺的新定义"><a class="header" href="#曲线的光顺的新定义">曲线的光顺的“新定义”</a></h2>
<p>一条曲线是光顺的，如果<br />
（1）它是\(C^{l+1}  ( l &gt; 0 )\)连续的；<br />
（2）它的曲线本身拐点较少；<br />
（3）它的曲率图的拐点较少；<br />
（4）它的曲率图变化的振幅相对小。</p>
<blockquote>
<p>说明 1： 条件(1)中的 \(C^{1+l}\) 是要求曲线为 \(C^{1}\) 连续而不必\(C^{2}\),但\(C^{1}\)的导数满足有界变差。条件 (4) 则要求曲线在曲安非连续点处的跳跃要尺尽可能小。<br />
说明 2： 满足 (2)和(3)描述的曲线的它的曲率图含有的单调段都会相对少。这与前面所述的判 别准则 1-4 一致。<br />
💡 光顺很难定义，为什么一定要给它一个定义？因为定义代表了一个明确的标准，在同一个标准下讨论问题才有意义。</p>
</blockquote>
<h1 id="remarks"><a class="header" href="#remarks">Remarks</a></h1>
<p>震荡数 Vibration：Change from convex to concave or change from concave to convex<br />
一阶震荡数 First vibration number \(R\)：Vibration number of \(y(x)\)<br />
二阶震荡数 Second vibration number \(S\)：Vibration number of curvature function</p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。
https://caterpillarstudygroup.github.io/GAMES102_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="曲线的光顺方法"><a class="header" href="#曲线的光顺方法">曲线的光顺方法</a></h1>
<h1 id="函数型3次样条曲线"><a class="header" href="#函数型3次样条曲线">函数型3次样条曲线</a></h1>
<p>小扰度假设：</p>
<ul>
<li>转角不大于60°</li>
<li>\({y}' (x)\ll 1 \)</li>
<li>\({y}'' (x)\approx k(x)\)</li>
</ul>
<p><img src="CurveFairing/../assets/%E5%85%89%E9%A1%BA13.png" alt="" /></p>
<blockquote>
<p>\({y}' \ll 1⇒  曲线的转角不会太大，此时 y&quot;(x)=K(x)\)<br />
[?]  \(y&quot;\)不就是\(K\)吗？为什么需要这个前提条件？<br />
工业界做高精设备时才需要考虑光顺。</p>
</blockquote>
<h1 id="光顺方法的基本思想"><a class="header" href="#光顺方法的基本思想">光顺方法的基本思想</a></h1>
<p>• \(C^1\) continuous<br />
• Decrease jump amplitude of curvature<br />
• Decrease the first vibration number \(R\)<br />
• Decrease the second vibration number \(S\)</p>
<h1 id="具体步骤-1"><a class="header" href="#具体步骤-1">具体步骤</a></h1>
<p>这个框架适用于大部分问题：预处理 → 核心算法 → 后处理。<br />
核心算法又可以分为粗处理 → 精处理</p>
<h2 id="step-1-初光顺-coarse-fairing"><a class="header" href="#step-1-初光顺-coarse-fairing">Step 1. 初光顺 Coarse fairing</a></h2>
<ul>
<li>定界法<br />
• Adjust the positions of control points<br />
• Decrease the jump amplitude of curvature<br />
• Remove some unwanted inflections</li>
<li>Physical approach</li>
</ul>
<h2 id="step-2-基本光顺-basic-fairing"><a class="header" href="#step-2-基本光顺-basic-fairing">Step 2. 基本光顺 Basic fairing</a></h2>
<ul>
<li>卡尺法<br />
• Adjust the positions of control points<br />
• Remove other redundant inflections<br />
• Decrease the first vibration number \(R\)</li>
<li>Geometric approach</li>
</ul>
<h2 id="step-3-精光顺-fine-fairing"><a class="header" href="#step-3-精光顺-fine-fairing">Step 3. 精光顺 Fine fairing</a></h2>
<ul>
<li>回弹法<br />
• Check the signs of shear force at control points<br />
• Adjust the change numbers of shear force<br />
• Decrease the second vibration number \(S\)</li>
<li>Physical approach</li>
</ul>
<h1 id="b样条曲线的光顺方法"><a class="header" href="#b样条曲线的光顺方法">B样条曲线的光顺方法</a></h1>
<p>• 基于稀疏优化的光顺优化方法</p>
<p>$$
\min_{\tilde{d} } ||e(\tilde{d} )||_1
$$</p>
<p>$$
s.t.||(\tilde{d} )-d||_\infty \le \varepsilon 
$$</p>
<p>曲率的二阶差分向量\(e\). 计算公式如下：</p>
<p>$$
e_i=\frac{C_{i+1}-C_i}{t_{i+1}-t_i} -\frac{C_{i}-C_{i-1}}{t_{i}-t_{i-1}},i=1,\cdots ,n-3 
$$</p>
<p><strong>王士玮等，基于稀疏模型的曲线光顺算法，计算机辅助设计与图形学学报，2016.</strong></p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。
https://caterpillarstudygroup.github.io/GAMES102_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="回顾r2和-r3中的曲线曲面"><a class="header" href="#回顾r2和-r3中的曲线曲面">回顾：\(R^2\)和 \(R^3\)中的曲线/曲面</a></h1>
<p><img src="DiscreteCurves/../assets/%E7%A6%BB%E6%95%A31.png" alt="" /></p>
<p>映射的维数：<a href="DiscreteCurves/../ParametricFitting/VectorValue.html">link</a><br />
重建与设计：<a href="DiscreteCurves/../BezierCurve/Review.html">link</a>
曲线（形状）的不同表达方法：<a href="DiscreteCurves/../ImplicitCurves/Review.html">link</a></p>
<h1 id="几何迭代法渐进迭代逼近"><a class="header" href="#几何迭代法渐进迭代逼近">几何迭代法（渐进迭代逼近）</a></h1>
<p>(progressive‐iterative approximation, PIA)</p>
<p><img src="DiscreteCurves/../assets/%E7%A6%BB%E6%95%A38.png" alt="" /></p>
<h2 id="要解决的问题-1"><a class="header" href="#要解决的问题-1">要解决的问题：</a></h2>
<p>\(Q_0\) ~ \(Q_4\) 是用户给点，要求新的控制顶点P，使其生成
的曲线经过Q点。</p>
<h2 id="普通方法"><a class="header" href="#普通方法">普通方法：</a></h2>
<p>构造方程反求控制顶点。</p>
<h2 id="本文方法"><a class="header" href="#本文方法">本文方法：</a></h2>
<blockquote>
<p>图(b)的P点标注得不对。</p>
</blockquote>
<p>用 Q 作为初始 P<br />
基于 P 画出曲线。<br />
计算曲线对应点与Q的距离，调整P的位置。<br />
公式求解与迭代求解的区别</p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。
https://caterpillarstudygroup.github.io/GAMES102_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="从连续到离散"><a class="header" href="#从连续到离散">从连续到离散</a></h1>
<p>对象的表达<br />
• 在数学上，连续表达与计算<br />
• 在计算机中，离散表达与计算<br />
数值方法：数值微分、数值积分、数值优化<br />
• 数值分析：离散计算对精确计算的近似程度<br />
• Fourier分析/变换：离散Fourier分析/变换<br />
• 卷积（滤波）<br />
在计算机科学（计算机图形学）中，采样无处不在<br />
• 计算机只能表达离散的数值<br />
• 例子：int型的数据（量化）</p>
<blockquote>
<p>💡 人的感知精度高，宏观表现为连续，计算能力支持的精度低，宏观表现为离散，精度不匹配就会产生artifact.</p>
</blockquote>
<h1 id="曲线的离散化"><a class="header" href="#曲线的离散化">曲线的离散化</a></h1>
<h2 id="要解决的问题-2"><a class="header" href="#要解决的问题-2">要解决的问题</a></h2>
<p>将连续性表达转化为<strong>多边形</strong>表达（分段线性）</p>
<p><img src="DiscreteCurves/../assets/%E7%A6%BB%E6%95%A39.png" alt="" /></p>
<blockquote>
<p>黑色是光滑曲线，但无法用于计算。因此用虚线近似替代曲­线进行计算。只要能控制直线与曲线的误差。</p>
</blockquote>
<h2 id="为何要离散化"><a class="header" href="#为何要离散化">为何要离散化？</a></h2>
<ul>
<li>
<p>渲染的必要性：线段/圆的光栅化</p>
<ul>
<li>曲线的绘制：曲线须离散成多边形</li>
<li>曲面的绘制：曲面须离散成<strong>三角形网格</strong><br />
<img src="DiscreteCurves/../assets/%E8%A1%A8%E8%BE%BE1.png" alt="" /></li>
</ul>
</li>
</ul>
<blockquote>
<p>只有针对线段或特殊曲线（圆、椭圆）等的高效渲染算法。<br />
不会针对一般曲线专门设计，因此要把一般曲线离散成线段再渲染。</p>
</blockquote>
<p><img src="DiscreteCurves/../assets/%E7%A6%BB%E6%95%A310.png" alt="" /></p>
<ul>
<li>计算的必要性：直线求交、多项式求根</li>
</ul>
<p><img src="DiscreteCurves/../assets/%E7%A6%BB%E6%95%A311.png" alt="" /></p>
<ul>
<li>制造的必要性：刀具轨迹只能走直线段和圆弧</li>
</ul>
<h1 id="nyquistshannon采样定理"><a class="header" href="#nyquistshannon采样定理">Nyquist–Shannon采样定理</a></h1>
<p>If a function \(x(t)\) contains no frequencies higher than B hertz, it is completely determined by giving its ordinates at a series of points spaced 1/(2B) seconds apart.</p>
<p><img src="DiscreteCurves/../assets/%E7%A6%BB%E6%95%A312.png" alt="" /></p>
<h1 id="bezier曲线的离散定理"><a class="header" href="#bezier曲线的离散定理">Bezier曲线的离散定理</a></h1>
<p>定理：曲线到弦的最大距离&lt;控制顶点到弦的最大距离<br />
应用：给定误差，估计离散层级</p>
<p><img src="DiscreteCurves/../assets/%E7%A6%BB%E6%95%A313.png" alt="" /></p>
<h1 id="离散曲线的几何量的计算"><a class="header" href="#离散曲线的几何量的计算">离散曲线的几何量的计算</a></h1>
<ul>
<li>
<p>如果有连续表达，利用连续表达的曲线来计算</p>
</li>
<li>
<p>如无连续表达<br />
• 差分法：利用差分形式来近似微分属性</p>
</li>
</ul>
<blockquote>
<p>差分法：一个点的导数是相邻点的差分，用前一点和后一点的弦的斜率来代替当前点的切线。</p>
</blockquote>
<p>• 拟合法：利用光滑函数来拟合估计属性</p>
<blockquote>
<p><img src="DiscreteCurves/../RAW/71.1.png" alt="" /></p>
</blockquote>
<ul>
<li>Tylor展开及估计 </li>
</ul>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。
https://caterpillarstudygroup.github.io/GAMES102_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="重心坐标要解决的问题---ffd"><a class="header" href="#重心坐标要解决的问题---ffd">重心坐标要解决的问题 - FFD</a></h1>
<p>FFD = Free‐form Deformation</p>
<p><em>[Sederberg et al. 86]</em></p>
<p><strong>问题</strong>：给定一个包含物体的边界多边形，改变边界时，如何计算物体的变形？<br />
<strong>方法</strong>：Embed the object into a domain that is more easily parametrized than the object.</p>
<p><strong>优点</strong>:<br />
• You can deform arbitrary objects<br />
• Independent of object representation</p>
<p><img src="DiscreteCurves/../assets/%E7%A6%BB%E6%95%A314.png" alt="" /></p>
<blockquote>
<p>本文是作用于3D物体的算法，以2D为例说明该算法：<br />
用 Bezier 面片包围目标面片。通过控制 Bazier 顶点来控制目标面片。<br />
Bezier 顶点称为 proxy （<strong>代理</strong>） ，但Proxy 不一定是 Bezier 点，也可以是边界上的点，主要是找到目标上任意一个点与 Proxy 点之间的关系。<br />
因此问题简化为求<strong>内部点与边界点（控制顶点）之间的关联关系</strong><br />
关联关系本质是重心坐标，即组合系数<br />
代理的优点是：简化问题，可以快速得到一个基本准确的结果。<br />
缺点是：1.有些无法简化的地方，就是artifact.<br />
2.如何得到准确的关联关系。</p>
</blockquote>
<h1 id="几何图形的重心坐标"><a class="header" href="#几何图形的重心坐标">几何图形的重心坐标</a></h1>
<p>三角形的重心坐标：三角形的顶点是 Proxy 点. P是三角形内任意一点。用某种方法来描述P与 Proxy 点之间的关系。</p>
<blockquote>
<p>即把P描述为Proxy点的线性组合。线性组合的系数就是P的重新坐标值。</p>
</blockquote>
<p>四边及以上多边形不能用三角形的方法求重心坐标，因为系数解不唯一。<br />
因此需要一种对所有多边形适用的更统一的重心坐标定义方式。</p>
<blockquote>
<p>Coordinates：这一页没讲<br />
重心坐标的应用：这一页没讲<br />
Coordinates In A Polytope：这一页没讲<br />
BC of 2D Polygons：这一页没讲</p>
</blockquote>
<h1 id="各种重心坐标的计算方法"><a class="header" href="#各种重心坐标的计算方法">各种重心坐标的计算方法</a></h1>
<ul>
<li>Wachspress (WP) coordinates</li>
</ul>
<p>$$
w_{i}=\frac{\cot \gamma_{i-1}+\cot \beta_{i}}{r_{i}^{2}}
$$</p>
<p><img src="DiscreteCurves/../assets/%E7%A6%BB%E6%95%A340.png" alt="" /></p>
<ul>
<li>mean value (MV) coordinates</li>
</ul>
<p>$$
w_{i}=\frac{\tan \left(\alpha_{i-1} / 2\right)+\tan \left(\alpha_{i} / 2\right)}{r_{i}}
$$</p>
<p><img src="DiscreteCurves/../assets/%E7%A6%BB%E6%95%A341.png" alt="" /></p>
<ul>
<li>discrete harmonic (DH) coordinates</li>
</ul>
<p>$$
w_{i}=\cot \beta_{i-1}+\cot \gamma_{i}
$$</p>
<p><img src="DiscreteCurves/../assets/%E7%A6%BB%E6%95%A342.png" alt="" /></p>
<blockquote>
<p>不同的几何坐标都有相应的几何背景</p>
</blockquote>
<h1 id="重心坐标的应用"><a class="header" href="#重心坐标的应用">重心坐标的应用</a></h1>
<h2 id="1imge-warping"><a class="header" href="#1imge-warping">1.imge warping</a></h2>
<p><img src="DiscreteCurves/../assets/%E7%A6%BB%E6%95%A326.png" alt="" /></p>
<h2 id="2-shading"><a class="header" href="#2-shading">2. shading</a></h2>
<p><img src="DiscreteCurves/../assets/%E7%A6%BB%E6%95%A327.png" alt="" /></p>
<blockquote>
<p>通常只存储顶点上的shading value. 非顶点处的shade value 是通过顶点的shading value 插值得到。插值是基于重心坐标做的。</p>
</blockquote>
<h2 id="3-transfinite-interpolation"><a class="header" href="#3-transfinite-interpolation">3. Transfinite Interpolation</a></h2>
<p>问题：给定4条边界曲线，构造插值这4条曲线的一张曲面</p>
<p>Interpolating height function to model a surface</p>
<p><img src="DiscreteCurves/../assets/%E7%A6%BB%E6%95%A328.png" alt="" /></p>
<h2 id="4-allow-directly-updating-on-interpolation-when-resampled"><a class="header" href="#4-allow-directly-updating-on-interpolation-when-resampled">4. allow directly updating on interpolation when resampled.</a></h2>
<p><img src="DiscreteCurves/../assets/%E7%A6%BB%E6%95%A329-1.png" alt="" /></p>
<blockquote>
<p>❓ 这就是普通插值，跟重心坐标有什么关系？</p>
</blockquote>
<h1 id="广义重心坐标的学习资料"><a class="header" href="#广义重心坐标的学习资料">广义重心坐标的学习资料</a></h1>
<p>http://www.inf.usi.ch/faculty/hormann/barycentric</p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。
https://caterpillarstudygroup.github.io/GAMES102_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="2d形状离散曲线处理"><a class="header" href="#2d形状离散曲线处理">2D形状（离散曲线）处理</a></h1>
<h1 id="离散曲线的去噪滤波"><a class="header" href="#离散曲线的去噪滤波">离散曲线的去噪/滤波</a></h1>
<p>• Denoising, smoothing, fairing</p>
<p><img src="DiscreteCurves/../assets/%E7%A6%BB%E6%95%A331.png" alt="" /></p>
<h1 id="曲线简化simplification"><a class="header" href="#曲线简化simplification">曲线简化(Simplification)</a></h1>
<p><img src="DiscreteCurves/../assets/%E7%A6%BB%E6%95%A332.png" alt="" /></p>
<h1 id="曲线编辑变形editingdeformation"><a class="header" href="#曲线编辑变形editingdeformation">曲线编辑/变形(Editing/Deformation)</a></h1>
<p><img src="DiscreteCurves/../assets/%E7%A6%BB%E6%95%A333.png" alt="" /></p>
<h1 id="形状插值morphing"><a class="header" href="#形状插值morphing">形状插值(Morphing)</a></h1>
<p><img src="DiscreteCurves/../assets/%E7%A6%BB%E6%95%A334.png" alt="" /></p>
<h1 id="形状的对称性检测symmetry"><a class="header" href="#形状的对称性检测symmetry">形状的对称性检测(Symmetry)</a></h1>
<p><img src="DiscreteCurves/../assets/%E7%A6%BB%E6%95%A335.png" alt="" /></p>
<h1 id="形状分割segmentation"><a class="header" href="#形状分割segmentation">形状分割(Segmentation)</a></h1>
<p><img src="DiscreteCurves/../assets/%E7%A6%BB%E6%95%A336.png" alt="" /></p>
<h1 id="形状匹配matchingcorrespondences"><a class="header" href="#形状匹配matchingcorrespondences">形状匹配(Matching/Correspondences)</a></h1>
<p><img src="DiscreteCurves/../assets/%E7%A6%BB%E6%95%A337.png" alt="" /></p>
<h1 id="形状检索retrieval"><a class="header" href="#形状检索retrieval">形状检索(Retrieval)</a></h1>
<p><img src="DiscreteCurves/../assets/%E7%A6%BB%E6%95%A338.png" alt="" /></p>
<h1 id="形状描述子descriptors"><a class="header" href="#形状描述子descriptors">形状描述子(Descriptors)</a></h1>
<p><img src="DiscreteCurves/../assets/%E7%A6%BB%E6%95%A339.png" alt="" /></p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。
https://caterpillarstudygroup.github.io/GAMES102_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="回顾三角网格曲面"><a class="header" href="#回顾三角网格曲面">回顾：三角网格曲面</a></h1>
<p><img src="DiscreteDifferential/../assets/%E5%BE%AE%E5%88%861-1.png" alt="" /></p>
<ul>
<li>观点 1：曲面的离散逼近<br />
• 采样：顶点为从曲面上的采样点<br />
• 构网：每个三角面为线性平面<br />
• 本质：分片线性逼近</li>
</ul>
<p><img src="DiscreteDifferential/../assets/%E5%BE%AE%E5%88%862.png" alt="" /></p>
<ul>
<li>观点 2：平面图的嵌入<br />
• 平面图<br />
• 图的顶点提升 (lifting) 至三维空间<br />
• 本质：二维流形</li>
</ul>
<p><img src="DiscreteDifferential/../assets/%E5%BE%AE%E5%88%863.png" alt="" /></p>
<h1 id="几何网格处理库"><a class="header" href="#几何网格处理库">几何（网格）处理库</a></h1>
<p>• CGAL: <a href="http://www.cgal.org">http://www.cgal.org</a><br />
• Libigl: <a href="https://github.com/libigl/libigl">https://github.com/libigl/libigl</a><br />
• MeshLab: <a href="http://www.meshlab.net">http://www.meshlab.net</a><br />
• OpenMesh: <a href="https://www.openmesh.org">https://www.openmesh.org</a><br />
• PCL (Point Cloud Library): <a href="http://www.pointclouds.org">http://www.pointclouds.org</a><br />
• TriMesh: <a href="http://graphics.stanford.edu/software/trimesh">http://graphics.stanford.edu/software/trimesh</a><br />
• DGtal: <a href="https://dgtal.org">https://dgtal.org</a><br />
• pymesh<br />
• Pymeshlab</p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。
https://caterpillarstudygroup.github.io/GAMES102_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="曲线的微分几何"><a class="header" href="#曲线的微分几何">曲线的微分几何</a></h1>
<p><img src="DiscreteDifferential/../assets/%E5%BE%AE%E5%88%8614.png" alt="" /></p>
<h2 id="point-p"><a class="header" href="#point-p">Point p</a></h2>
<p>Point p on the curve at \(u_0\)</p>
<p>$$
p = C (u_0)<br />
$$</p>
<blockquote>
<p>单参数曲线，因此只有一个参数\(u_0\)</p>
</blockquote>
<h2 id="tangent-t"><a class="header" href="#tangent-t">Tangent T</a></h2>
<p>Tangent T to the curve at \(u_0\)</p>
<p>$$
C_u=\frac{\partial C(u)}{\partial u} \\ T=\frac{C_u}{||C_u||}
$$</p>
<h2 id="normal-n-and-binormal-b"><a class="header" href="#normal-n-and-binormal-b">Normal N and Binormal B</a></h2>
<p>Normal N and Binormal B to the curve at \(u_0\)</p>
<blockquote>
<p>\(C_u\) 与曲线相切，又记为T<br />
\(C_{uu} 与 N 同朝向(夹角&lt;90^{\circ})\)<br />
\(C_u\)和\(C_{uu}\)做叉积，得到方向B。<br />
B 称为从法矢，B与 \(C_u\) 叉乘得到 N.<br />
\(N,C_{uu},C_u\) 应该在同一平面内，且\(C_{uu}位于C_u 和 N \)之间。<br />
T（切线），B(以法），N（法线）构成直角坐标系。</p>
</blockquote>
<h2 id="curvature-κ"><a class="header" href="#curvature-κ">Curvature κ</a></h2>
<p>Curvature is <strong>independent</strong> of parameterization，用于Measure curve bending</p>
<p>$$
k=1/R
$$</p>
<p>其中R为二阶密切圆的半径</p>
<h2 id="以上符号的关系"><a class="header" href="#以上符号的关系">以上符号的关系</a></h2>
<p><img src="DiscreteDifferential/../assets/%E5%BE%AE%E5%88%8615.png" alt="" /></p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。
https://caterpillarstudygroup.github.io/GAMES102_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="曲面的微分几何"><a class="header" href="#曲面的微分几何">曲面的微分几何</a></h1>
<p><img src="DiscreteDifferential/../assets/%E5%BE%AE%E5%88%8625.png" alt="" /></p>
<h2 id="point-p-1"><a class="header" href="#point-p-1">Point p</a></h2>
<p>Point p on the surface at \((u_0,v_0)\)</p>
<h2 id="tangent-s_u"><a class="header" href="#tangent-s_u">Tangent \(S_u\)</a></h2>
<p>Tangent \(S_u\) in the u direction</p>
<p>$$
S_u=\frac{\partial S(u,v)}{\partial u}
$$</p>
<h2 id="tangent-s_v"><a class="header" href="#tangent-s_v">Tangent \(S_v\)</a></h2>
<p>Tangent \(S_v\) in the v direction</p>
<p>$$
S_v=\frac{\partial S(u,v)}{\partial v}
$$</p>
<h2 id="plane-of-tangents-t"><a class="header" href="#plane-of-tangents-t">Plane of tangents T</a></h2>
<p>$$
T=uS_u+vS_v
$$</p>
<blockquote>
<p>\(S_u 和 S_v\) 张成一个平面，称为切平面。</p>
</blockquote>
<h2 id="normal-n"><a class="header" href="#normal-n">Normal N</a></h2>
<p>$$
N=\frac{S_u\times S_v}{||S_u\times S_v||}
$$</p>
<h2 id="curvature"><a class="header" href="#curvature">Curvature</a></h2>
<p>方向曲率：曲率是随着方向变化的</p>
<blockquote>
<p>N 所在平面与曲面相交，得到平面曲线，有对应的曲率空间曲面的切线和曲率都是基于特定方向的。</p>
</blockquote>
<h1 id="曲面的曲率"><a class="header" href="#曲面的曲率">曲面的曲率</a></h1>
<h2 id="主曲率-principal-directions"><a class="header" href="#主曲率-principal-directions">主曲率 Principal Directions</a></h2>
<p>两个方向（正交）曲率：最大曲率\(𝜅_1\)和最小曲率\(𝜅_2\)</p>
<p>其他方向曲率：</p>
<p>$$
k=k_1\cos ^2\theta +k_2\sin ^2\theta
$$</p>
<blockquote>
<p>\(\theta \)是当前曲率方向与\(K_1\)方向的夹角。</p>
</blockquote>
<p><img src="DiscreteDifferential/../assets/%E5%BE%AE%E5%88%8628.png" alt="" /><br />
<img src="DiscreteDifferential/../assets/%E5%BE%AE%E5%88%8628-2.png" alt="" /><br />
<img src="DiscreteDifferential/../assets/%E5%BE%AE%E5%88%8629.png" alt="" /></p>
<h2 id="高斯曲率"><a class="header" href="#高斯曲率">高斯曲率</a></h2>
<p>$$
k=k_1k_2
$$</p>
<p>等距变换不变量：曲面发生变形，但曲面上任意两点间距离不变。</p>
<p>可展曲面：处处高斯曲率为0的曲面。其展开为平面时不会发生变形。<br />
有三类可展曲面：柱面、锥面、切线面</p>
<p><img src="DiscreteDifferential/../assets/%E5%BE%AE%E5%88%8626.png" alt="" /></p>
<blockquote>
<p>切线面：任意空间曲线的所有切线构成的面。</p>
</blockquote>
<h2 id="平均曲率"><a class="header" href="#平均曲率">平均曲率</a></h2>
<p>$$
k=\frac{k_1+k_2}{2}
$$</p>
<p>处处平均曲率为0的曲面：<strong>极小曲面</strong></p>
<p><img src="DiscreteDifferential/../assets/%E5%BE%AE%E5%88%8627.png" alt="" /></p>
<h1 id="平均曲率流定理"><a class="header" href="#平均曲率流定理">平均曲率流定理</a></h1>
<p><img src="DiscreteDifferential/../assets/%E7%BD%91%E6%A0%BC14.png" alt="" /></p>
<p>$$
\delta _i=\frac{1}{d_i} \sum _{\nu\in N(i)}(\nu_i-\nu)
$$</p>
<p>$$
\frac{1}{len(\gamma )} \int _{\nu\in \gamma }(\nu_i-\nu)ds
$$</p>
<p>$$
\lim_{len(\gamma ) \to 0} \frac{1}{len(\gamma )} \int _{\nu\in \gamma }(\nu_i-\nu)ds=H(\nu_i)n_i
$$</p>
<p>\(\gamma \)代表红点的邻域外围封闭曲线。<br />
\(V_i 是红点， V是\gamma \)上的点。<br />
\( len(\gamma) \)代表曲线长度。<br />
\(H(V_i)为 V_i\) 的平均曲率。</p>
<p>当曲线长度趋于0，其极限是一个常值。常值的方向为法向，大小为平均曲率。</p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。
https://caterpillarstudygroup.github.io/GAMES102_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="离散微分几何要解决的问题"><a class="header" href="#离散微分几何要解决的问题">离散微分几何要解决的问题</a></h1>
<p>微分几何研究曲面无穷小邻域上的微分属性（导数、曲率）<br />
但Mesh是分段线性的，在三角形内部无穷连续，在边和点上\(C^0\)连续。<br />
\(C^0\)连续不光滑、不可微，如何讨论微分性质？</p>
<blockquote>
<p>答：通过采样点估计出原始曲面的微分属性。包括：<br />
• Normal estimation<br />
• Curvature estimation<br />
• Principal curvature directions<br />
• …</p>
</blockquote>
<h2 id="两种估计微分属性的方法论"><a class="header" href="#两种估计微分属性的方法论">两种估计微分属性的方法论</a></h2>
<p>Approximate the (unknown) underlying surface</p>
<p>（1） Continuous approximation：Approximate the surface &amp; compute continuous differential measures (normal, curvature)<br />
（2） Discrete approximation：Approximate differential measures for mesh</p>
<h1 id="continuous-approximation"><a class="header" href="#continuous-approximation">Continuous Approximation</a></h1>
<h2 id="quadratic-approximation"><a class="header" href="#quadratic-approximation">Quadratic Approximation</a></h2>
<h3 id="第一步获取周围点的信息"><a class="header" href="#第一步获取周围点的信息">第一步：获取周围点的信息</a></h3>
<p>对于要估计的顶点，使用其周围的顶点的信息：</p>
<ul>
<li>Compute normal at vertex
<ul>
<li>Typically average face normals</li>
</ul>
</li>
<li>Compute tangent plane &amp; local coordinate system</li>
<li>For each neighbor vertex compute location in local system
<ul>
<li>relative to node and tangent plane</li>
</ul>
</li>
</ul>
<p><img src="DiscreteDifferential/../assets/%E5%BE%AE%E5%88%8632.png" alt="" /></p>
<h3 id="第二步拟合曲面"><a class="header" href="#第二步拟合曲面">第二步：拟合曲面</a></h3>
<p>定义 quadric function，例如抛物面</p>
<p>$$
F(x, y, z)=ax^{2}+bxy+cy^{2}-z=0 
$$</p>
<p>使用least squares来找到拟合quadric function的系数</p>
<p>$$
\min \sum_{i}^{} (ax_i^2+bx_iy_i+cy_i^2-z_i) 
$$</p>
<p>$$
\begin{pmatrix}x_1^2  &amp; x_1y_1 &amp;y_1^2
\\ \cdots  &amp;\cdots   &amp;\cdots
\\ x_n^2 &amp;x_ny_n  &amp;y_n^2
\end{pmatrix}\begin{pmatrix}a
 \\b
 \\c
\end{pmatrix}=\begin{pmatrix}z_1
 \\\cdots 
 \\z_n
\end{pmatrix}A=\begin{pmatrix}x_1^2  &amp; x_1y_1 &amp;y_1^2
\\ \cdots  &amp;\cdots   &amp;\cdots
\\ x_n^2 &amp;x_ny_n  &amp;y_n^2
\end{pmatrix},X=\begin{pmatrix}a
 \\b
 \\c
\end{pmatrix},b=\begin{pmatrix}z_1
 \\\cdots 
 \\z_n
\end{pmatrix}
$$</p>
<p>Approximation can be found by:\(\tilde{X}=\left(A^{T} A\right)^{-1} A^{T} b\)</p>
<h3 id="第三步基于曲面估计微分属性"><a class="header" href="#第三步基于曲面估计微分属性">第三步：基于曲面估计微分属性</a></h3>
<p>Approximation principal curvatures</p>
<p>Given surface \(F\)，principal curvatures \(k_\min \) and \(k_\max\) are real roots of:</p>
<p>$$
k^{2}-(a+c)k + ac - b^{2} = 0
$$</p>
<p>Mean curvature: </p>
<p>$$
H = (k_\min + k_\max)/2
$$</p>
<p>Gaussian curvature:</p>
<p>$$
K = k_\min  k_\max
$$</p>
<h2 id="other-approximation"><a class="header" href="#other-approximation">Other approximation</a></h2>
<ul>
<li>Cubic approximation<br />
• J. Goldfeather and V. Interrante. A novel cubic‐order algorithm for approximating principal direction vectors. ACM Transactions on Graphics 23, 1 (2004), 45–63.</li>
<li>Implicit surface approximation<br />
• Yutaka Ohtake et al. Multi‐level partition of unity implicits. Siggraph 2003.</li>
<li>Many others…</li>
</ul>
<h1 id="discrete-approximation"><a class="header" href="#discrete-approximation">Discrete Approximation</a></h1>
<h2 id="顶点的normal-estimation"><a class="header" href="#顶点的normal-estimation">顶点的Normal Estimation</a></h2>
<p>顶点Normal = 加权平均 face normals</p>
<p>Weighted:  face areas, angles at vertex</p>
<blockquote>
<p>What happen at edges/creases(折痕)?<br />
为什么刘老师要问这个问题，顶点肯定在边上的。</p>
</blockquote>
<h2 id="mean-curvature"><a class="header" href="#mean-curvature">Mean Curvature</a></h2>
<p>由Laplace‐Beltrami（平均曲率流）定理：</p>
<p>$$
K(x_i)=\frac{1}{2A_M} \sum_{j\in N_1(i)}^{} (\cot \alpha _{ij}+\cot \beta _{ij})(x_i-x_j)
$$</p>
<p><img src="DiscreteDifferential/../assets/%E5%BE%AE%E5%88%8633.png" alt="" /></p>
<p>其中：<br />
\(N_l(X_i)\):表\(X_i点的l\)邻域点<br />
\(A_m\)：整个多边形的面积</p>
<h2 id="gauss-curvature"><a class="header" href="#gauss-curvature">Gauss Curvature</a></h2>
<p>Gauss‐Bonnet定理：</p>
<p><img src="DiscreteDifferential/../assets/%E5%BE%AE%E5%88%8634.png" alt="" /></p>
<p>例子：</p>
<p><img src="DiscreteDifferential/../assets/%E5%BE%AE%E5%88%8635.png" alt="" /></p>
<blockquote>
<p>👆 color map：数据的可视化方法，红 &gt; 绿 &gt; 篮</p>
</blockquote>
<h2 id="存在的问题-1"><a class="header" href="#存在的问题-1">存在的问题</a></h2>
<p>Approximation always results in some noise<br />
解决方法：（1）截断（2）平滑</p>
<h2 id="references"><a class="header" href="#references">References</a></h2>
<ul>
<li>MEYER M., DESBRUN M., SCHRÖDER P., BARR A.: Discrete differential‐geometry operators for triangulated 2‐manifolds. In Visualization and Mathematics III, Hege H.‐C., Polthier K., (Eds.). Springer, 2003, pp. 35–58. (<u>PDF</U>)</li>
</ul>
<blockquote>
<p>离散微分几何算子的开创性文章</p>
</blockquote>
<ul>
<li>TAUBIN G.: Estimating the tensor of curvature of a surface from a polyhedral approximation. In Proc. International Conference on Computer Vision (1995), pp. 902–907.</li>
<li>MEYER M., DESBRUN M., SCHRÖDER P., BARR A.: Discrete differential‐geometry operators for triangulated 2‐ manifolds. In Visualization and Mathematics III, Hege H.‐C., Polthier K., (Eds.). Springer, 2003, pp. 35–58.</li>
<li>CAZALS F., POUGET M.: Estimating differential quantities using polynomial fitting of osculating jets. In Eurographics Symposium on Geometry Processing (2003), pp. 177–187.</li>
<li>COHEN‐STEINER D., MORVAN J.: Restricted delaunay triangulations and normal cycle. In Proc. ACM Symposium on Computational Geometry (2003), pp. 312–321.</li>
<li>GOLDFEATHER J., INTERRANTE V.: A novel cubic‐order algorithm for approximating principal direction vectors. ACM Transactions on Graphics 23, 1 (2004), 45–63.</li>
<li>MARTIN R. R.: Estimation of principal curvatures from range data. International Journal of Shape Modeling 4, 1 (1998), 99–109.</li>
<li>OHTAKE Y., BELYAEV A., SEIDEL H.‐P.: Ridge‐valley lines on meshes via implicit surface fitting. ACM 
Transactions on Graphics 23, 3 (2004), 609–612. (Proc. SIGGRAPH’2004).</li>
<li>PAGE D., SUN Y., KOSCHAN A., PAIK J., ABIDI M.: Normal vector voting: Crease detection and curvature 
extimation on large, noisy meshes. Graphical Models 64, 3‐4 (2002), 199–229.</li>
</ul>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。
https://caterpillarstudygroup.github.io/GAMES102_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="极小曲面"><a class="header" href="#极小曲面">极小曲面</a></h1>
<p>• 平均曲率处处为0的曲面</p>
<p><img src="DiscreteDifferential/../assets/%E5%BE%AE%E5%88%8638.png" alt="" /></p>
<blockquote>
<p>每个点都是马鞍点<br />
常见的极小曲面肥皂泡。</p>
</blockquote>
<blockquote>
<p>建筑中使用极小曲面，好看、省材料、不积水</p>
</blockquote>
<h1 id="极小曲面的平均曲率流"><a class="header" href="#极小曲面的平均曲率流">极小曲面的平均曲率流</a></h1>
<p><img src="DiscreteDifferential/../assets/%E5%BE%AE%E5%88%8649.png" alt="" /></p>
<p><strong>Laplace Operator (Umbrella Operator)</strong></p>
<p>Mean 曲率处处为0，代入 Mean Curve 的计算公式</p>
<p>$$ 
K=\frac{1}{2A_m} \sum (\cot \alpha_{ij}+\cot \beta_{ij})(x_i-x_j)=0
$$</p>
<p>以上公式可以看作是 V 与其 1 邻域点的线性组合，得到 Q 平面内的重心坐标点。</p>
<p>任意一个曲面，把P往Q方向移动，就可以得到极小曲面：</p>
<p>$$
L(P)=\frac{1}{n} \sum_{i=1}^{n} \overrightarrow{PQ_i} =\frac{1}{n} \sum_{i=1}^{n}Q_i-P
$$</p>
<p><img src="DiscreteDifferential/../assets/%E5%BE%AE%E5%88%8650.png" alt="" /></p>
<p>但是不建议直接把P移动Q点，而是每次移一小部分。</p>
<ul>
<li>因为每个点的运动是互相影响的，一个点变化太大，它邻居的目标就不对了。</li>
</ul>
<p><img src="DiscreteDifferential/../assets/%E5%BE%AE%E5%88%8651.png" alt="" /></p>
<p>不断迭代，每个顶点都会接近平均曲率为0。（离散平均曲率流定理）</p>
<blockquote>
<p>\(\lambda \)太大会不收敛。\(\lambda \)取小一点多走几步。</p>
</blockquote>
<p>其中Hn的定义如下：</p>
<p>$$
H_n=\frac{\nabla_PA}{2A} 
$$</p>
<p>$$
H_n=\frac{1}{4A} \sum_{j}^{} (\cot \alpha _j+\cot \beta _j)(P-Q_j)
$$</p>
<p><img src="DiscreteDifferential/../assets/%E5%BE%AE%E5%88%8652.png" alt="" /></p>
<h1 id="离散极小曲面的局部迭代法"><a class="header" href="#离散极小曲面的局部迭代法">离散极小曲面的局部迭代法</a></h1>
<h2 id="非封闭曲面"><a class="header" href="#非封闭曲面">非封闭曲面</a></h2>
<pre><code class="language-python">找到边界 # 只能对非封闭曲面（带一条边界）操作    
固定边界顶点    
迭代 # 尝试试验不同的参数𝜆
   对每个内部顶点    
      找顶点1‐邻域    
      更新其坐标 # 更新坐标需要用老的顶点坐标   
更新所有顶点法向   
</code></pre>
<p><img src="DiscreteDifferential/../assets/%E5%BE%AE%E5%88%8653.png" alt="" /></p>
<h2 id="封闭曲面"><a class="header" href="#封闭曲面">封闭曲面</a></h2>
<p>对于封闭曲面，不固定住的点，最后会收缩到一个点。</p>
<p><img src="DiscreteDifferential/../assets/%E5%BE%AE%E5%88%8654.png" alt="" /></p>
<blockquote>
<p>❓ 如何构造曲面边界？<br />
答：自己构造</p>
</blockquote>
<h1 id="triangle"><a class="header" href="#triangle">Triangle</a></h1>
<p><a href="http://www.cs.cmu.edu/%7Equake/triangle.html">http://www.cs.cmu.edu/~quake/triangle.html</a></p>
<p>当满足\(K=0时， L 的模长为0\)。<br />
从任意取曲面优化成极小曲面的方法：</p>
<ol>
<li>计算出中间的黑点</li>
<li>向黑点移动<br />
（重心）</li>
</ol>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。
https://caterpillarstudygroup.github.io/GAMES102_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="三角网格曲面的离散表达"><a class="header" href="#三角网格曲面的离散表达">三角网格：曲面的离散表达</a></h1>
<p>三角形网格是曲面的分片线性逼近。通过定义点的位置和点之间的连续关系，来描述一个曲面。</p>
<h2 id="流形meshes"><a class="header" href="#流形meshes">流形Meshes</a></h2>
<p>流形：任意一个点的无穷小领域同胚于一个二维圆盘</p>
<h3 id="非流形边"><a class="header" href="#非流形边">非流形边</a></h3>
<p><img src="TriangularMeshes/../assets/%E8%A1%A8%E8%BE%BE7.png" alt="" /></p>
<blockquote>
<p>👆 图1中一条边有三个相邻的面，因此是非流型边</p>
</blockquote>
<h3 id="非流形顶点"><a class="header" href="#非流形顶点">非流形顶点</a></h3>
<p><img src="TriangularMeshes/../RAW/72-1.png" alt="" /></p>
<blockquote>
<p>❗ 本课程假设都是流型曲面。如果遇到非流型就直接去掉或变成流形。 </p>
</blockquote>
<h2 id="mesh上的操作"><a class="header" href="#mesh上的操作">Mesh上的操作</a></h2>
<p>在mesh上的操作有：</p>
<ul>
<li>网速细分：引入更多三角形，并调整顶点坐标。使表面更光滑</li>
<li>网格简化：在保持基本形状的情况下，用更少的三角形</li>
<li>网格 Regularization：使网格更接近正三角形，这样对渲染更友好</li>
</ul>
<p><img src="TriangularMeshes/../assets/Mesh_65.PNG" alt="" /></p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。
https://caterpillarstudygroup.github.io/GAMES102_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="网格曲面的数据结构"><a class="header" href="#网格曲面的数据结构">网格曲面的数据结构</a></h1>
<blockquote>
<p>Uses of Mesh Data：跳过<br />
Storing Mesh Data：跳过<br />
Define a Mesh：跳过</p>
</blockquote>
<h1 id="3d-mesh-surface"><a class="header" href="#3d-mesh-surface">3D Mesh Surface</a></h1>
<ul>
<li>Surface &amp; material properties<br />
• Material color<br />
• Ambient, hightlight coefficients<br />
• Texture coordinates<br />
• BRDF, BTF</li>
<li>Rendering properties<br />
• Lighting<br />
• Normals<br />
• Rendering modes</li>
</ul>
<h1 id="general-used-mesh-files"><a class="header" href="#general-used-mesh-files">General Used Mesh Files</a></h1>
<ul>
<li>General used mesh files<br />
• Wavefront OBJ ( *. obj)<br />
• 3D Max ( *. max, *. 3ds)<br />
• VRML ( *. vrl)<br />
• Inventor (  *.  iv)<br />
• PLY ( *. ply, *. ply2)<br />
•  Py mesh lab<br />
• User‐defined ( *. m, *. liu)</li>
<li>Storage<br />
• Text – (Recommended)<br />
• Binary</li>
</ul>
<h2 id="wavefront-obj-file-format"><a class="header" href="#wavefront-obj-file-format">Wavefront OBJ File Format</a></h2>
<ul>
<li>Vertices<br />
• Start with char ‘v’<br />
• (x,y,z) coordinates</li>
<li>Faces<br />
• Start with char ‘f’<br />
• Indices of its vertices in the file</li>
<li>Other properties<br />
• Normal, texture coordinates, material, etc.</li>
</ul>
<p><img src="TriangularMeshes/../assets/%E8%A1%A8%E8%BE%BE13.png" alt="" /></p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。
https://caterpillarstudygroup.github.io/GAMES102_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="review3d网格曲面"><a class="header" href="#review3d网格曲面">Review：3D网格曲面</a></h1>
<p>3D网格曲面是二维流形曲面的离散：<a href="LaplacianCoordinates/../DiscreteDifferential/Review.html">link1</a>、<a href="LaplacianCoordinates/../../../DiscreteCurves/Discretization.html">link2</a> 、<a href="LaplacianCoordinates/../TriangularMeshes/DataStructure.html">link3</a></p>
<h1 id="局部特征度量"><a class="header" href="#局部特征度量">局部特征度量</a></h1>
<p>一个点的信息通常由它周围的顶点和面片来决定。</p>
<p><img src="LaplacianCoordinates/../assets/%E7%BD%91%E6%A0%BC5.png" alt="" /></p>
<p>对于离散几何来说，无穷小邻域性质就通过 n 邻域来分近似。</p>
<blockquote>
<p>其中最常用的是1‐邻域，即1‐ring neighborhood</p>
</blockquote>
<p>­离散观点：直接取邻域点的特征来计算当前点的特征<br />
连续观点：取邻域点拟合成曲面，然后分析曲面在该点处的特征。</p>
<blockquote>
<p>一般“流形”结构也是通过局部邻域来定义</p>
</blockquote>
<p><img src="LaplacianCoordinates/../assets/%E7%BD%91%E6%A0%BC6.png" alt="" /></p>
<p>Detail = surface – smooth (surface)<br />
Smoothing = averaging</p>
<blockquote>
<p>红点是surface。<br />
黄点是smooth，是蓝点的加权平均，可以用各种加权方式。有哪些权重方法见本页最后。<br />
黄色向量是detail，称为拉普拉斯算子，可以描述红点的尖锐承度。</p>
</blockquote>
<h2 id="连续laplace算子operator"><a class="header" href="#连续laplace算子operator">连续Laplace算子(operator)</a></h2>
<blockquote>
<p>此页中是连续形式的 Laplace 算子。</p>
</blockquote>
<h3 id="定义在欧氏空间的laplace-算子"><a class="header" href="#定义在欧氏空间的laplace-算子">定义在欧氏空间的Laplace 算子</a></h3>
<p>\(n\)维欧几里得空间的二阶微分算子（椭圆型算子）<br />
梯度 \(\nabla f\) 的散度 \(\nabla \cdot f\)</p>
<p>$$
\Delta f=\nabla \cdot \nabla f=\nabla^{2} f
$$</p>
<blockquote>
<p>梯度是一个向量，散度指向量各个分量之和。</p>
</blockquote>
<h3 id="定义在坐标系中的laplace-算子"><a class="header" href="#定义在坐标系中的laplace-算子">定义在坐标系中的Laplace 算子</a></h3>
<p>在笛卡尔坐标系中，为所有非混合二阶偏导数：</p>
<p>$$
\Delta f=\sum_{i=1}^{n} \frac{\partial^{2} f}{\partial x_{i}^{2}}
$$</p>
<p>特别地，对二元实函数\(f(x,y)\)：</p>
<p>$$
\Delta f=\frac{\partial^{2} f}{\partial x^{2}}+\frac{\partial^{2} f}{\partial y^{2}}
$$</p>
<h3 id="定义在黎曼流形上的laplace-算子"><a class="header" href="#定义在黎曼流形上的laplace-算子">定义在黎曼流形上的Laplace 算子</a></h3>
<p>称为Laplace‐Beltrami 算子</p>
<p>$$
\nabla ^2f=\nabla \cdot \nabla f \\
=\frac{1}{\sqrt{|g|} } \partial _i(\surd |g|g^{ij}\partial _jf).
$$</p>
<h2 id="离散-laplacian-算子"><a class="header" href="#离散-laplacian-算子">离散 Laplacian 算子</a></h2>
<p>又称为Umbrella Operator、伞型算子</p>
<p>$$
\delta _i=\nu _i-\sum _{j\in N(i)}w_j\nu _j
$$</p>
<p><img src="LaplacianCoordinates/../assets/%E7%BD%91%E6%A0%BC7.png" alt="" /></p>
<blockquote>
<p>❓ 如何理解离散曲面的Laplace比算子？[23:40]</p>
</blockquote>
<h3 id="2d场景-图2439"><a class="header" href="#2d场景-图2439">2D场景： （图[24:39]）</a></h3>
<p>后向差分： </p>
<p>$$
{f}'_ x=\frac{y_ {i+1}-y_i}{x_ {i+1}-x_ i} 
$$</p>
<p>前向差分：
$$
{f}'_ x= \frac{y_ i-y_ {i-1}}{x_ i-x_ {i-1}} 
$$</p>
<h3 id="3d的场景"><a class="header" href="#3d的场景">3D的场景</a></h3>
<p><img src="LaplacianCoordinates/../RAW/75.1.png" alt="" /><br />
① ② ③ ④ 看作是⑤的 1 邻域。<br />
推广到一般形式可得：\(\delta _i\)<br />
\(\delta _i\)称为 Laplace 算子，也叫 Laplace 坐标、<strong>微分坐标</strong>。</p>
<h2 id="平均曲率流定理-1"><a class="header" href="#平均曲率流定理-1">平均曲率流定理</a></h2>
<p><img src="LaplacianCoordinates/../assets/%E7%BD%91%E6%A0%BC8.png" alt="" /></p>
<p>平均曲率流定理：<a href="LaplacianCoordinates/../DiscreteDifferential/Surfaces.html">link</a></p>
<p>将此定理公式写成离散形式，与\(\delta _i\)公式相通。</p>
<p>微分坐标 represent the <strong>local</strong> detail / local shape description，具有与\(H(v_i)n_i\)相同的特点：</p>
<ul>
<li>The direction approximates the normal</li>
<li>The size approximates the mean curvature</li>
</ul>
<p><img src="LaplacianCoordinates/../assets/%E7%BD%91%E6%A0%BC9.png" alt="" /></p>
<h1 id="weighting-schemes"><a class="header" href="#weighting-schemes">Weighting Schemes</a></h1>
<p>• Uniform weight (geometry oblivious)</p>
<p>$$
w_i=1
$$</p>
<p>• Cotangent weight (geometry aware)</p>
<p>$$
w_j=(\cot \alpha +\cot \beta )
$$</p>
<p>• Normalization</p>
<p>$$
w_j=\frac{w_j}{\sum _jw_j} 
$$</p>
<p><img src="LaplacianCoordinates/../assets/%E7%BD%91%E6%A0%BC10.png" alt="" /></p>
<p>$$
\delta _i=\frac{1}{d_i} \sum _{j\in N(i)}(\nu_i-\nu_j)
$$</p>
<blockquote>
<p>1邻域点加权平均的权有讲究,通常使用 cotangent.</p>
</blockquote>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。
https://caterpillarstudygroup.github.io/GAMES102_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="local-laplacian-smoothing的作用"><a class="header" href="#local-laplacian-smoothing的作用">Local Laplacian Smoothing的作用</a></h1>
<h2 id="几何细节的度量"><a class="header" href="#几何细节的度量">几何细节的度量</a></h2>
<p>Useful for operations on surfaces where <strong>surface details</strong> are important</p>
<h2 id="laplacian-smoothing"><a class="header" href="#laplacian-smoothing">Laplacian Smoothing</a></h2>
<h3 id="方法"><a class="header" href="#方法">方法</a></h3>
<p>$$
P^{new}=P^{old}+\lambda L(P^{old})
$$</p>
<p><img src="LaplacianCoordinates/../assets/%E7%BD%91%E6%A0%BC11.png" alt="" /></p>
<blockquote>
<p>上节课的任意曲面到极小曲面的过程,是一种特殊的Local Lapluàn Smoothing.<br />
也可以看作是去噪、滤波。</p>
</blockquote>
<p>平滑也相当于滤波，GAMES101有解释。</p>
<h3 id="over-smoothing问题"><a class="header" href="#over-smoothing问题">over-smoothing问题</a></h3>
<p>但存在over-smoothing问题，需要选择合适的\(\lambda\)和迭代次数。<br />
<img src="LaplacianCoordinates/../assets/%E7%BD%91%E6%A0%BC13.png" alt="" /></p>
<h3 id="基于平均曲率流近似laplacian-smoothing的效果"><a class="header" href="#基于平均曲率流近似laplacian-smoothing的效果">基于平均曲率流近似Laplacian Smoothing的效果</a></h3>
<p>平均曲率流：<a href="LaplacianCoordinates/../LaplacianCoordinates/LaplacianCoordinates.html">link</a></p>
<p>不知道拉普拉斯坐标，但知道平均曲率和法向，也能做拉普拉斯平滑<br />
Laplacian 可以用于提取高频和平滑高频，效果取决于权重定义是否合理。 </p>
<p><img src="LaplacianCoordinates/../assets/%E7%BD%91%E6%A0%BC15.png" alt="" /></p>
<p>$$
Hn=\frac{\nabla _PA}{2A} 
$$</p>
<p>$$
Hn=\frac{1}{4A} \sum _j(\cot \alpha _j+\cot \beta _j)(P-Q_j)
$$</p>
<p><img src="LaplacianCoordinates/../assets/%E7%BD%91%E6%A0%BC16.png" alt="" /></p>
<p><img src="LaplacianCoordinates/../assets/%E7%BD%91%E6%A0%BC17.png" alt="" /></p>
<blockquote>
<p>Mean Curvature Flow 使用 cotangent 权，因此是Laplacian Smoothing 的特殊形式。<br />
对于 low densily mesh,\(\delta _i\) 比较长，如果使用普­通权，这种情况会收缩快。如果使用 cotangent 权，则不会。</p>
</blockquote>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。
https://caterpillarstudygroup.github.io/GAMES102_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="local-laplacian-smoothing-方法存在的问题"><a class="header" href="#local-laplacian-smoothing-方法存在的问题">Local Laplacian Smoothing 方法存在的问题</a></h1>
<ol>
<li>不同位置收敛速度不同</li>
<li>自交</li>
</ol>
<h1 id="global-laplacian-smoothing"><a class="header" href="#global-laplacian-smoothing">Global Laplacian Smoothing</a></h1>
<h2 id="极小曲面-1"><a class="header" href="#极小曲面-1">极小曲面</a></h2>
<h3 id="方法-1"><a class="header" href="#方法-1">方法</a></h3>
<p>极小曲面(minimal surface) = 平均曲率处处为0 = 微分坐标一致为0</p>
<p><img src="LaplacianCoordinates/../assets/%E7%BD%91%E6%A0%BC20.png" alt="" /></p>
<p>所有顶点的方程联立，得到网格曲面的整体Laplacian方程：</p>
<p>$$
Ax = 0 \\
x=(v_1,v_2,\dots ,v_n)^\top 
$$
\(A 的第 i 行为 (v_i)的系数，即 第i个系数为1，第j个系数为 w_{ij}\),其余为0.整体上非常稀疏。</p>
<h3 id="应用生成极小曲面"><a class="header" href="#应用生成极小曲面">应用：生成极小曲面</a></h3>
<ul>
<li>检测边界，固定边界</li>
<li>构建稀疏方程组\((\delta=0)\)</li>
</ul>
<blockquote>
<p>global体现在所有点的约束同时满足，不需要像Local那样迭代出极小曲面。<br />
但是global需要求解方程组，可以用数学方法，也可以用迭代方法。</p>
</blockquote>
<ul>
<li>求解稀疏方程组</li>
</ul>
<blockquote>
<p>注：有高效的求解方法，且有成熟的数学库可使用MLK, Eigen</p>
</blockquote>
<ul>
<li>更新内部顶点坐标</li>
</ul>
<p><img src="LaplacianCoordinates/../assets/%E7%BD%91%E6%A0%BC24.png" alt="" /></p>
<h2 id="任意曲面"><a class="header" href="#任意曲面">任意曲面</a></h2>
<p>也不一定目标是极小曲面，可以是指定曲率的曲面，则Laplacian Matrix为：</p>
<h3 id="方法-2"><a class="header" href="#方法-2">方法</a></h3>
<p><img src="LaplacianCoordinates/../assets/%E7%BD%91%E6%A0%BC21.png" alt="" /></p>
<p>$$
A_{ij}=\begin{cases}
 1 ,     i\in N(j)\\
0, otherwise
\end{cases}
$$</p>
<p>$$
D_{ij}=\begin{cases}
 d_i,     i=j\\
0, otherwise
\end{cases}
$$</p>
<p>$$
L=I-D^{-1}A
$$</p>
<p>考虑到每个点有x, y, z三个分量，展开来是这样的：</p>
<p><img src="LaplacianCoordinates/../assets/%E7%BD%91%E6%A0%BC22.png" alt="" /></p>
<p>增加将边界点固定的约束。</p>
<h3 id="应用reconstruction"><a class="header" href="#应用reconstruction">应用：Reconstruction</a></h3>
<p>根据拓扑关系生成L矩阵，那么在拓扑不变的情况下，就可以根据提前记录下的\(\delta\)还原出原曲面。</p>
<p>$$
Lv=\delta
$$</p>
<p><img src="LaplacianCoordinates/../assets/%E7%BD%91%E6%A0%BC23.png" alt="" /></p>
<blockquote>
<p>不断减小\(\delta\)而更新V,得到极小曲面。</p>
</blockquote>
<blockquote>
<p>Rank(L) = n‐c (n‐1 for connected meshes)<br />
L 非满秩， C 为 mesh 的联通个数，至少为1.<br />
必须增加额外约束使L满秩。 </p>
</blockquote>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。
https://caterpillarstudygroup.github.io/GAMES102_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mesh-parameterization-mesh-flattening"><a class="header" href="#mesh-parameterization-mesh-flattening">Mesh Parameterization (Mesh Flattening)</a></h1>
<h2 id="什么是曲面参数化"><a class="header" href="#什么是曲面参数化">什么是曲面参数化</a></h2>
<p>对于一个二维流形的三维曲面，把它拍成二维的过程称为参数化。</p>
<p><img src="LaplacianCoordinates/../assets/%E7%BD%91%E6%A0%BC27.png" alt="" /></p>
<ul>
<li>每个3D顶点(\(x,y,z\))对应一个2D点(\(u,v\))<br />
• (\(u,v\)) 称为 (\(x,y,z\)) 的参数（2D流形曲面的本征维数）</li>
</ul>
<h2 id="曲面参数化要解决的问题"><a class="header" href="#曲面参数化要解决的问题">曲面参数化要解决的问题</a></h2>
<p><img src="LaplacianCoordinates/../assets/%E7%BD%91%E6%A0%BC28.png" alt="" /></p>
<p>非可展曲面展开后必须形变，因此希望展开后的平面形变尽量地少，具体衡量为：</p>
<ol>
<li>三角形不能发生翻转。</li>
<li>三角形的扭曲能够保持。</li>
<li>边界不要自交。</li>
</ol>
<blockquote>
<p>这节课为曲面参数化的基础课，不涉及这些内容，将在后面展开。</p>
</blockquote>
<h2 id="参数化的应用"><a class="header" href="#参数化的应用">参数化的应用</a></h2>
<ol>
<li>提供了三维曲面每个点的一个二维参数，可用于<strong>贴纹理</strong></li>
<li>在低维来处理高维问题，减少复杂度</li>
<li>三维曲面之间的相关问题可通过参数化空间来处理</li>
</ol>
<h1 id="曲面参数化的方法tuttes-method"><a class="header" href="#曲面参数化的方法tuttes-method">曲面参数化的方法：Tutte’s Method</a></h1>
<h2 id="第一步将边界映射到平面的凸多边形上"><a class="header" href="#第一步将边界映射到平面的凸多边形上">第一步：将边界映射到平面的<strong>凸</strong>多边形上</a></h2>
<p><em>[Floater 97’]</em></p>
<p><img src="LaplacianCoordinates/../assets/%E7%BD%91%E6%A0%BC35.png" alt="" /></p>
<p>M. Floater. Parametrization and smooth approximation of surface triangulations. CAGD, 1997.<br />
<a href="http://www.cs.jhu.edu/%7Emisha/Fall09/Floater97.pdf">http://www.cs.jhu.edu/~misha/Fall09/Floater97.pdf</a></p>
<h2 id="第二步求解稀疏方程组"><a class="header" href="#第二步求解稀疏方程组">第二步：求解稀疏方程组</a></h2>
<p><img src="LaplacianCoordinates/../assets/%E7%BD%91%E6%A0%BC36.png" alt="" /></p>
<p>Forming a sparse linear system</p>
<blockquote>
<p>还是之前 Global Laplacian Smoothing 求极小曲面的原理。<br />
边界点在同一平面上，得到的极小曲面也是在平面上的。<br />
但是要把边界点放右边呢？因为右边是固定点，要求的是内部点。</p>
</blockquote>
<h2 id="性质-1"><a class="header" href="#性质-1">性质</a></h2>
<p><img src="LaplacianCoordinates/../assets/%E7%BD%91%E6%A0%BC37.png" alt="" /></p>
<ul>
<li>优点：<br />
简单<br />
如果边界位于凸多边形上，则三角形一定不会发生翻转！</li>
<li>缺点：<br />
扭曲大<br />
在密的地方容易发生数值上的精度问题</li>
<li>其它
第二步中使用不同的权值定义方向得到的结果不同，<strong>使用cot权的扭曲最小</strong></li>
</ul>
<p><img src="LaplacianCoordinates/../assets/%E7%BD%91%E6%A0%BC40.png" alt="" /></p>
<blockquote>
<p>使用这种格子作为纹理，方便观察扭曲情况，仍建议用 cotangent 权，扭曲较小。<br />
图1：均匀权， 图3：cotangent权</p>
</blockquote>
<h2 id="操作步骤总结"><a class="header" href="#操作步骤总结">操作步骤总结</a></h2>
<p>• 检测边界<br />
• <strong>将边界映射到正方形边界或圆边界（凸边界）</strong><br />
• 构建稀疏方程组<br />
• 求解稀疏方程组<br />
• 更新顶点坐标<br />
• <strong>连接纹理图像，更新显示</strong></p>
<h1 id="分块参数化"><a class="header" href="#分块参数化">分块参数化</a></h1>
<p><img src="LaplacianCoordinates/../assets/%E7%BD%91%E6%A0%BC42.png" alt="" /></p>
<p>复杂模型割成多块分别参数化，再 packing<br />
优点：1.减少扭曲。    2.具有语义。<br />
缺点：1.空间浪费。</p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。
https://caterpillarstudygroup.github.io/GAMES102_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="shrinkage问题"><a class="header" href="#shrinkage问题">Shrinkage问题</a></h1>
<p>Global Laplacian smoothing results in shrinkages</p>
<p><img src="LaplacianCoordinates/../assets/%E7%BD%91%E6%A0%BC45.png" alt="" /></p>
<p>解决方法：add constraints，例如顶点约束、面约束…</p>
<p><img src="LaplacianCoordinates/../assets/%E7%BD%91%E6%A0%BC46.png" alt="" /></p>
<h1 id="soft-lapacian-smoothness"><a class="header" href="#soft-lapacian-smoothness">Soft Lapacian Smoothness</a></h1>
<p>不带约束的 Laplacian 会导致maesh收缩，因此要固定几个
点作为约束。<br />
hard 约束（Interpolation）：必须满足的约束，例如 \(S.T.g(t)=0\)<br />
Soft 约束（Approximation）: 尽量满足的约束，例如 \(\min f(x)\)</p>
<p><strong>硬约束会导致约束点变成一尖点，因此引入软约束</strong></p>
<p>从优化的方法讲，Soft可以用GD迭代。比hard的KKT要简单</p>
<h2 id="vertex-constraints"><a class="header" href="#vertex-constraints">Vertex Constraints</a></h2>
<p>Add position constraint for one vertex</p>
<p><img src="LaplacianCoordinates/../assets/%E7%BD%91%E6%A0%BC51.png" alt="" /></p>
<blockquote>
<p>hard 约束的问题是,fix点处会很突兀,因此通常使用软约束。<br />
每 fix 一个点，在矩阵下面增加三行。<br />
加入约束之后. L 的行数远多于列数。只能求近似解。<br />
\(\min \left || Ax- b \right ||^2\),相当于软约束优化问题。</p>
</blockquote>
<p>$$
\min _{{X}'} {||L{X}' ||^2+\mu ^2\sum _{i\in C}|{v }'_i -v_i|^2}
$$</p>
<blockquote>
<p>第一项： Laplace 尽量小，第二项：固定点尽量不动</p>
</blockquote>
<p><img src="LaplacianCoordinates/../assets/%E7%BD%91%E6%A0%BC53.png" alt="" /></p>
<h2 id="face-constraints"><a class="header" href="#face-constraints">Face Constraints</a></h2>
<p><img src="LaplacianCoordinates/../assets/%E7%BD%91%E6%A0%BC54.png" alt="" /></p>
<blockquote>
<p>除了固定顶点位置的约束，<strong>还可以对面加约束</strong>，例如：固定面片重心的位置。<strong>关键是要线性约束</strong>。</p>
</blockquote>
<p><img src="LaplacianCoordinates/../assets/%E7%BD%91%E6%A0%BC55.png" alt="" /></p>
<h2 id="other-constraints"><a class="header" href="#other-constraints">Other Constraints</a></h2>
<p>• Edge constraints</p>
<p><img src="LaplacianCoordinates/../assets/%E7%BD%91%E6%A0%BC56.png" alt="" /></p>
<p>• 1‐ring barycenter constraints</p>
<p><img src="LaplacianCoordinates/../assets/%E7%BD%91%E6%A0%BC57.png" alt="" /></p>
<p>• Other linear constraints</p>
<h1 id="results"><a class="header" href="#results">Results</a></h1>
<p><img src="LaplacianCoordinates/../assets/%E7%BD%91%E6%A0%BC59.png" alt="" /></p>
<p><strong>‘8’-like mesh model<br />
3070 vertices, 6144 triangles</strong></p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。
https://caterpillarstudygroup.github.io/GAMES102_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="laplacian-editing"><a class="header" href="#laplacian-editing">Laplacian Editing</a></h1>
<p>[Sorkine et al. SGP 2004]</p>
<h1 id="whats-are-details"><a class="header" href="#whats-are-details">What’s are Details?</a></h1>
<p>• Detail = surface – smooth (surface)<br />
• Smoothing = averaging</p>
<p><img src="LaplacianCoordinates/../assets/%E7%BD%91%E6%A0%BC62.png" alt="" /></p>
<h1 id="whats-the-difference"><a class="header" href="#whats-the-difference">What’s the Difference?</a></h1>
<p><img src="LaplacianCoordinates/../assets/%E7%BD%91%E6%A0%BC63.png" alt="" /></p>
<h1 id="laplacian-editing-1"><a class="header" href="#laplacian-editing-1">Laplacian Editing</a></h1>
<ul>
<li>Local detail representation – enables <strong>detail preservation</strong> through various modeling tasks</li>
<li>Representation with <strong>sparse</strong> matrices</li>
<li>Efficient <strong>linear</strong> surface reconstruction</li>
</ul>
<p><img src="LaplacianCoordinates/../assets/%E7%BD%91%E6%A0%BC64.png" alt="" /></p>
<h1 id="editing-framework"><a class="header" href="#editing-framework">Editing framework</a></h1>
<ul>
<li>The spatial constraints will serve as modeling constraints</li>
<li>Reconstruct the surface every time the modeling constraints are changed</li>
</ul>
<p>Detail constraints: \(LX=\delta \)<br />
Modeling constraints: \(x_j=c_j,j\in\) {\(j_1,j_2,\dots j_k\)}</p>
<blockquote>
<p>用户对 mesh 的一个点进行编辑，算法更新其他的点，得到合理结果。<br />
本质：保持 mesh 的 Laplace 不变，因为 Laplace 描述了曲面的特征。<br />
准确说是 Laplace 长度不变，方向有可能旋转。</p>
</blockquote>
<h1 id="direct-detail-preserving"><a class="header" href="#direct-detail-preserving">Direct Detail Preserving</a></h1>
<p><img src="LaplacianCoordinates/../assets/%E7%BD%91%E6%A0%BC65.png" alt="" /></p>
<h1 id="rotation-transformation"><a class="header" href="#rotation-transformation">Rotation Transformation</a></h1>
<p><img src="LaplacianCoordinates/../assets/%E7%BD%91%E6%A0%BC65-1.png" alt="" /></p>
<p>$$
\begin{pmatrix}b_1-b_i
 \\\vdots 
 \\b_N-b_i
\end{pmatrix}=\begin{pmatrix}a_1-a_i
 \\\vdots 
 \\a_N-a_i
\end{pmatrix}R_i
$$</p>
<h1 id="reconstruction"><a class="header" href="#reconstruction">Reconstruction</a></h1>
<p>• Soft constraints</p>
<p>$$
L^TLv=L^T\delta 
$$</p>
<p><img src="LaplacianCoordinates/../assets/%E7%BD%91%E6%A0%BC66.png" alt="" /></p>
<h1 id="variational-viewpoint"><a class="header" href="#variational-viewpoint">Variational Viewpoint</a></h1>
<p>• Laplacian Approximation</p>
<p>$$
\tilde{X} =\underset{X}{argmin} (||LX-\delta ^{(x)}||^2+\sum _{j\in C}w^2||x_j-c_j||^2).
$$</p>
<p>• Gradient Approximation</p>
<p>$$
\underset{\phi }{min} \iint _\Omega ||\nabla \phi -w||^2dA,
$$</p>
<h1 id="user-interfaces"><a class="header" href="#user-interfaces">User Interfaces</a></h1>
<p>• ROI is bounded by a belt (static anchors)<br />
• Manipulation through handle(s)</p>
<p><img src="LaplacianCoordinates/../assets/%E7%BD%91%E6%A0%BC67.png" alt="" /></p>
<h1 id="results-1"><a class="header" href="#results-1">Results</a></h1>
<p><img src="LaplacianCoordinates/../assets/%E7%BD%91%E6%A0%BC68.png" alt="" /></p>
<h1 id="detail-transfer-and-mixing"><a class="header" href="#detail-transfer-and-mixing">Detail transfer and mixing</a></h1>
<p>• “Peel“ the coating of one surface and transfer to 
another</p>
<p><img src="LaplacianCoordinates/../assets/%E7%BD%91%E6%A0%BC69.png" alt="" /></p>
<p>第一步：Parameterization onto a common domain and elastic warp to align the features, if needed</p>
<p>第二步：Detail peeling:</p>
<p><img src="LaplacianCoordinates/../assets/%E7%BD%91%E6%A0%BC71.png" alt="" /></p>
<p>$$
\xi _i=\delta _i-\tilde{\delta } _i
$$</p>
<p>第三步：Changing local frames:</p>
<p><img src="LaplacianCoordinates/../assets/%E7%BD%91%E6%A0%BC72.png" alt="" /></p>
<p>第四步：Reconstruction of target surface from: \(\delta _{target}\)</p>
<p>$$
\delta _{target} ={\delta}' _i+{\xi}' _i
$$</p>
<h1 id="examples"><a class="header" href="#examples">Examples</a></h1>
<p><img src="LaplacianCoordinates/../assets/%E7%BD%91%E6%A0%BC75.png" alt="" /></p>
<h1 id="mixing-laplacians"><a class="header" href="#mixing-laplacians">Mixing Laplacians</a></h1>
<p>• Taking weighted average of \(\delta _i\) and  \(\delta ^‘_i\)</p>
<p><img src="LaplacianCoordinates/../assets/%E7%BD%91%E6%A0%BC76.png" alt="" /></p>
<h1 id="mesh-transplanting"><a class="header" href="#mesh-transplanting">Mesh transplanting</a></h1>
<ul>
<li>The user defines<br />
• Part to transplant<br />
• Where to transplant<br />
• Spatial orientation and scale</li>
<li>Topological stitching</li>
<li>Geometrical stitching via Laplacian mixing</li>
</ul>
<p><img src="LaplacianCoordinates/../assets/%E7%BD%91%E6%A0%BC77.png" alt="" /></p>
<p>• Details gradually change in the transition area</p>
<p><img src="LaplacianCoordinates/../assets/%E7%BD%91%E6%A0%BC78.png" alt="" /></p>
<p><img src="LaplacianCoordinates/../assets/%E7%BD%91%E6%A0%BC78-2.png" alt="" /><br />
提取与还原即 Encoder&amp; Decoder.Laplace 是手工方法，E&amp;D是AI方法。</p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。
https://caterpillarstudygroup.github.io/GAMES102_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="网格细分-0926"><a class="header" href="#网格细分-0926">网格细分 [09：26]</a></h1>
<p>目的：引入更多三角形，并调整顶点坐标。使表面更光滑</p>
<p><img src="MeshTessellation/../assets/Mesh_66.PNG" alt="" /></p>
<p>基本方法都是通过平均的方式让平面的局部得到平滑，类似图像的模糊操作。</p>
<blockquote>
<p>✅ 立方体不断细分后会变成球体，因为细分的目的是变光滑。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h2 id="loop-细分算法"><a class="header" href="#loop-细分算法">Loop 细分算法</a></h2>
<p>[11:30] (<em>loop 是人名，不代表循环</em>）</p>
<h3 id="第一步-划分三角形"><a class="header" href="#第一步-划分三角形">第一步： 划分三角形</a></h3>
<p><img src="MeshTessellation/../assets/Mesh_9.PNG" alt="" /></p>
<h3 id="第二步更新new顶点的位置"><a class="header" href="#第二步更新new顶点的位置">第二步：更新new顶点的位置</a></h3>
<p><img src="MeshTessellation/../assets/Mesh_10.PNG" alt="" /></p>
<p>new顶点被两个old三角形共享，更新公式为：</p>
<p>\[
p = \frac{3}{8}(A+B) + \frac{1}{8}(C+D)
\]</p>
<h3 id="第三步更新old顶点的位置"><a class="header" href="#第三步更新old顶点的位置">第三步：更新old顶点的位置</a></h3>
<p><img src="MeshTessellation/../assets/Mesh_11.PNG" alt="" /></p>
<p>old 顶贞被多个 old 三角形共享</p>
<p>更新公式为：</p>
<p>\[
p = (1 - n * u) * pos + n * neighbor
\]</p>
<p>n:与old顶点连接的边数</p>
<p>u:一个经验值</p>
<p>pos: old顶点更新前的位置</p>
<p>neighbor: old顶点的所有邻居的位置之和</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="catmull-clark-细分"><a class="header" href="#catmull-clark-细分">Catmull-Clark 细分</a></h2>
<p>loop 细分只能用于三角形面片，而此算法则更通用</p>
<h3 id="定义-7"><a class="header" href="#定义-7">定义</a></h3>
<p>Quad face：四边形面片</p>
<p>Non-quad face：非四边形面片</p>
<p>奇异点： degree不为4的点，degree 表示与点相邻的边数</p>
<p><img src="MeshTessellation/../assets/Mesh_69.PNG" alt="" /></p>
<h3 id="第一步取所有边上的中点与面上的中点"><a class="header" href="#第一步取所有边上的中点与面上的中点">第一步：取所有边上的中点与面上的中点</a></h3>
<p>把边中点与面中总用一条线连起来</p>
<p><img src="MeshTessellation/../assets/Mesh_70.PNG" alt="" /></p>
<p>操作后，<strong>增加的</strong>奇异点个数与 操作前的non-quad face 数相同，且所有的面都变为 quad face</p>
<p><img src="MeshTessellation/../assets/Mesh_71.PNG" alt="" /></p>
<h3 id="第二步-更新面中心的新增点"><a class="header" href="#第二步-更新面中心的新增点">第二步： 更新面中心的新增点，</a></h3>
<p><img src="MeshTessellation/../assets/Mesh_12.PNG" alt="" /></p>
<p>更新公式为：</p>
<p>\[
f = \frac{v_1 + v_2 + v_3 + v_4}{4}
\]</p>
<blockquote>
<p>❓ 如果是在一个三角形面片的中心呢？</p>
</blockquote>
<h3 id="第三步-更新边中心的新增点"><a class="header" href="#第三步-更新边中心的新增点">第三步： 更新边中心的新增点</a></h3>
<p><img src="MeshTessellation/../assets/Mesh_13.PNG" alt="" /></p>
<p>更新公式为：</p>
<p>\[
e = \frac{v_1 + v_2 + f_1 + f_2}{4}
\]</p>
<h3 id="更新-old-顶点"><a class="header" href="#更新-old-顶点">更新 old 顶点</a></h3>
<p><img src="MeshTessellation/../assets/Mesh_14.PNG" alt="" /></p>
<p>更新公式为：</p>
<p>\[
p' = \frac{f_1 + f_2 + f_3 + f_4 + 2(e_1 + e_2 + e_3 + e_4) + 4p}{16}
\]</p>
<blockquote>
<p>💡 以上这些方法都是基于经验估计。<br />
new point的位置不是该是由邻居点使用固定加权值得到，这个权值应该是不固定的，与old point和neighbour的距离有关。<br />
这些都是local细分方法，要想细分后与原mesh形状接近，应该使用global方法。<br />
同时，mesh细分是对丢失信息的补全，要想猜丢失的信息，还需要从其它mesh的统计规律、物理意义、人为知识中得到先验信息。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="网格-regularization"><a class="header" href="#网格-regularization">网格 Regularization</a></h1>
<p><img src="MeshRegularization/../assets/Mesh_68.PNG" alt="" /></p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="mesh-surface-denoising"><a class="header" href="#mesh-surface-denoising">Mesh (surface) Denoising</a></h1>
<p>Meshes obtained from real world objects are often noisy.</p>
<p><img src="Smoothing/../assets/%E5%8E%BB%E8%BA%812.png" alt="" /></p>
<p>• Mesh denoising<br />
• Mesh smoothing<br />
• Mesh filtering<br />
• Mesh improvement<br />
• Surface fairing (*)</p>
<blockquote>
<p>这几个词都是去噪的不同表达。<br />
在连续几何中， fairing 代表光顺，与 smoothing 不同。<br />
在离散几何中， fairing 与 smoothing 通用。</p>
</blockquote>
<h2 id="噪声的特点"><a class="header" href="#噪声的特点">噪声的特点</a></h2>
<p>No Precise Mathematical Definition! 以下是经验上的描述：</p>
<p>• High‐frequent tiny parts<br />
• Small bumps on the surface<br />
• High curvature parts<br />
• High fairing energy parts<br />
• …</p>
<p><img src="Smoothing/../assets/%E5%8E%BB%E8%BA%813.png" alt="" /></p>
<blockquote>
<p>👆 实际上，满足以上特点的不一定是噪声，也有可能是特征。</p>
</blockquote>
<h2 id="去噪的难点"><a class="header" href="#去噪的难点">去噪的难点</a></h2>
<p>去噪的难点在于，噪声和特征都是未知的。因此去噪需要识别噪声和特征，要Eliminate high frequency并Preserve global features</p>
<h1 id="mesh去噪方法论---mesh-smoothing-model"><a class="header" href="#mesh去噪方法论---mesh-smoothing-model">Mesh去噪方法论 - Mesh Smoothing Model</a></h1>
<p>假定：网格顶点的数据及连接关系不变<br />
问题转化为：顶点进行适当的扰动或偏移，得到顶点的新位置，使得“噪声”减少！<strong>关键是顶点如何偏移？</strong></p>
<p>定义\(M\)为含噪声的网格曲面，\(M^0\)为无噪声的网格曲面，for all \(v\in M\)，认为：</p>
<p>$$
v=v^0+\varepsilon n
$$</p>
<p>即顶点偏移的方向为n，大小为\(\varepsilon\)</p>
<p>好的算法不追求绝对的真实，而是合理的假设与必要的简化</p>
<h2 id="偏移的方向n"><a class="header" href="#偏移的方向n">偏移的方向n</a></h2>
<p>n可以是\(𝒗^0\)点的法向，或\(𝒗\)点的法向。<br />
如果取前者，仍然是ill‐posed问题。<br />
因此在这里用后者，即v点的法向。 </p>
<blockquote>
<p>\(v是带噪声曲面上的点，v_0\)是无噪声曲面上的点。<br />
假设：<br />
① \(v是v_0\)沿几方向上做了一点偏移。<br />
② \(n是v_0\)的法方向。<br />
③ 当\(v接近v_0\)时， \(v 的法线方向接近 n\)<br />
因此随着逐步迭代，后者会趋进前者。</p>
</blockquote>
<h2 id="偏移的大小varepsilon"><a class="header" href="#偏移的大小varepsilon">偏移的大小\(\varepsilon\)</a></h2>
<p>经验值，不展开</p>
<h1 id="filtering"><a class="header" href="#filtering">Filtering</a></h1>
<p>连续形式：</p>
<p>$$
(x*h)(t)=\int_{-\infty }^{\infty } x(\tau )h(t-\tau )d\tau
$$</p>
<p>离散形式：</p>
<p>$$
(x*h)(t)= {\textstyle \sum_{𝜏=-\infty }^{\infty }}  x(𝜏 )h(t-𝜏 )
$$</p>
<p><img src="Smoothing/../assets/%E5%8E%BB%E8%BA%817.png" alt="" /></p>
<p>几何意义：<br />
将函数\(ℎ(𝑡)\)作为权来对\(𝑥(𝑡)\)进行加权平均（滤波）<br />
将\(𝑥(𝑡)\)的局部信息进行混合平均</p>
<h2 id="gaussian-filtering"><a class="header" href="#gaussian-filtering">Gaussian Filtering</a></h2>
<p>通常使用Gauss函数作为权函数</p>
<p>$$
{I}' (u)=\sum _{p\in N(u)}e^{\frac{||u-P||^2}{2\sigma ^2} }I(P)
$$</p>
<blockquote>
<p>Gauss 函数的好处：<br />
① 概率密度函数，积分和为1.<br />
② 具有对称性<br />
③ 与距离相关</p>
</blockquote>
<h2 id="mesh-vertex-filtering"><a class="header" href="#mesh-vertex-filtering">Mesh Vertex Filtering</a></h2>
<p>Laplacian operator / Umbrella Operator：<a href="Smoothing/../LaplacianCoordinates/LocalLaplacianSmoothing.html">link</a></p>
<h2 id="滤波对象"><a class="header" href="#滤波对象">滤波对象</a></h2>
<ul>
<li>Vertex</li>
<li>Normal</li>
<li>Curvature</li>
<li>Color</li>
<li>Other physical properties (texture, albedo, … )</li>
</ul>
<h2 id="challenges"><a class="header" href="#challenges">Challenges:</a></h2>
<p>• Iteration number<br />
• Shrinkage</p>
<p><img src="Smoothing/../assets/%E5%8E%BB%E8%BA%8112.png" alt="" /></p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。
https://caterpillarstudygroup.github.io/GAMES102_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="1-vertex-filtering"><a class="header" href="#1-vertex-filtering">1. Vertex Filtering</a></h1>
<h2 id="11-laplacian-smoothing"><a class="header" href="#11-laplacian-smoothing">1.1 Laplacian Smoothing</a></h2>
<h3 id="原理"><a class="header" href="#原理">原理</a></h3>
<p><a href="Smoothing/../LaplacianCoordinates/LocalLaplacianSmoothing.html">link</a></p>
<p><img src="Smoothing/../assets/%E5%8E%BB%E8%BA%8113.png" alt="" /></p>
<h3 id="特点"><a class="header" href="#特点">特点</a></h3>
<ul>
<li>Equivalent to box filter in signal processing</li>
<li>Apply to all vertices on mesh</li>
<li>Typically repeat several times</li>
<li>Can describe as energy minimization<br />
• Energy = sum of squared edge lengths in mesh<br />
• Parameter\(\lambda &gt;0\)controls convergence &quot;speed&quot;</li>
</ul>
<h3 id="存在的问题-2"><a class="header" href="#存在的问题-2">存在的问题</a></h3>
<p>存在Over‐smoothing问题</p>
<p><img src="Smoothing/../assets/%E5%8E%BB%E8%BA%8114.png" alt="" /></p>
<p>存在Shrinkage问题</p>
<p><img src="Smoothing/../assets/%E5%8E%BB%E8%BA%8115.png" alt="" /></p>
<h3 id="改进"><a class="header" href="#改进">改进</a></h3>
<ul>
<li>Laplacian</li>
</ul>
<p>$$
P^{new} = P^{old}+\lambda L(P^{old})
$$</p>
<ul>
<li>Taubin’95：Laplacian + Expansion</li>
</ul>
<p>$$
P^{new} = P^{old}-(\mu -\lambda )L(P^{old})-\mu \lambda L^2(P^{old}),\mu &gt;\lambda &gt;0
$$</p>
<p><img src="Smoothing/../assets/%E5%8E%BB%E8%BA%8116.png" alt="" /></p>
<blockquote>
<p>图1：原图<br />
图2：普通 Laplace<br />
图3：Laplace + 收缩完再扩张回去。去噪同时保留了一些特征。 </p>
</blockquote>
<ul>
<li>Bilaplacian：Special case of Taubin’s</li>
</ul>
<p>$$
P^{new} = P^{old}+\lambda L^2(P^{old})
$$</p>
<blockquote>
<p>两阶拉普拉斯</p>
</blockquote>
<h2 id="12-mean-curvature-flow"><a class="header" href="#12-mean-curvature-flow">1.2 Mean Curvature Flow</a></h2>
<p><a href="Smoothing/../LaplacianCoordinates/LocalLaplacianSmoothing.html">link</a></p>
<blockquote>
<p>引入平均曲率、考虑了几何特征。</p>
</blockquote>
<h2 id="13-bilateral-filtering-双边滤波"><a class="header" href="#13-bilateral-filtering-双边滤波">1.3 Bilateral filtering 双边滤波</a></h2>
<p>此方向借鉴于图像算法</p>
<h3 id="图像算法是的双边滤波"><a class="header" href="#图像算法是的双边滤波">图像算法是的双边滤波</a></h3>
<p><img src="Smoothing/../assets/%E5%8E%BB%E8%BA%8121.png" alt="" /></p>
<blockquote>
<p>Bilateral:双边<br />
U 和 P 代表U点与P点的位置<br />
I(U) 和I(P)代表U和P点的值<br />
分子：U 点对 P 点的影响表现I(P)前面的系数上。<br />
系数考虑了两方面因素：<br />
(1) U 与 P 的距离，反映了U 对 P 的影响力。<br />
(2) I(U) 与I(P)的距离，反映了I(P)的特征性。<br />
二者都是距离越大权重越小。<br />
分母，归一化</p>
</blockquote>
<p>例子：<br />
<img src="Smoothing/../assets/%E5%8E%BB%E8%BA%8122.png" alt="" /></p>
<blockquote>
<p>👆 f是普通的高斯权重。fg是考虑了点的距离之后的权重。</p>
</blockquote>
<blockquote>
<p>除了U和I(U)，还可以根据实际情况加入更多的特征考量。<br />
这也是人工提取特征，然后用公式表达出来的传统方法。</p>
</blockquote>
<h3 id="网格中的双边滤波"><a class="header" href="#网格中的双边滤波">网格中的双边滤波</a></h3>
<p><img src="Smoothing/../assets/%E5%8E%BB%E8%BA%8125.png" alt="" /></p>
<blockquote>
<p>灰线：理想曲面，实际位置未知。<br />
黄点：曲面上的点，由于带噪声呈上下分布。<br />
蓝点：黄点中取的任意一点作为例子。</p>
</blockquote>
<p><img src="Smoothing/../assets/%E5%8E%BB%E8%BA%8127.png" alt="" /></p>
<blockquote>
<p>对蓝点做以下估计：<br />
取P点邻域内的点，做PCA，最大特征值对应的向量为 P点的法向。<br />
所有点向切平面上投影，得到距离1。<br />
所有点向法线上投影，得到距离2。<br />
由于同时考虑了距离1和距离2，因此称双边。</p>
</blockquote>
<blockquote>
<p>💡 我的想法：<br />
前面提到的， feature 和 noise 很难区分。<br />
比如例子中的棱角和噪声一样，具有高频、曲率大的特点。<br />
但特征有连续性，在大的区间里表现出规律，而噪声不具备这个特点，可以据此区分。</p>
</blockquote>
<p>效果：<br />
<img src="Smoothing/../assets/%E5%8E%BB%E8%BA%8130.png" alt="" /></p>
<h2 id="14-implicit-mesh-evolutions"><a class="header" href="#14-implicit-mesh-evolutions">1.4 Implicit Mesh Evolutions</a></h2>
<p>explicit scheme：</p>
<p>$$
M_{n+1}=M_n+\lambda L(M_n)
$$</p>
<p>implicit scheme：</p>
<p>$$
M_{n+1}=M_n+\lambda L(M_{n+1}) \\
\Rightarrow (I-\lambda L)M_{n+1}=M_n
$$</p>
<blockquote>
<p>隐式方法通过求解线性稀疏方程组得到结果（类似全局法）<br />
❓ 认为噪声是沿着法向的偏移，本身就是一种猜测、为什么说用真实曲面的法向会更好呢？</p>
</blockquote>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。
https://caterpillarstudygroup.github.io/GAMES102_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="2-normal-filtering"><a class="header" href="#2-normal-filtering">2. Normal Filtering</a></h1>
<h2 id="法向滤波的应用场景"><a class="header" href="#法向滤波的应用场景">法向滤波的应用场景</a></h2>
<p>先对法向进行滤波（可使用顶点滤波的任何方法），根据滤波后的法向<strong>重建网格顶点</strong></p>
<p><img src="Smoothing/../assets/%E5%8E%BB%E8%BA%8131.png" alt="" /></p>
<h2 id="由法向重建顶点"><a class="header" href="#由法向重建顶点">由法向重建顶点</a></h2>
<p>• 输入：滤波后的法向量场<br />
• 输出：重建网格顶点，使得其法向量接近输入</p>
<blockquote>
<p>法向是一阶微分量，可以通过积分求出顶点。<br />
离散情况下，积分过程变成了线性方程组，方程依据是法向与边垂直。</p>
</blockquote>
<p>$$
\begin{cases}
 n_f^T\cdot (x_j-x_i)=0\\
n_f^T\cdot (x_k-x_j)=0  \\
n_f^T\cdot (x_i-x_k)=0
\end{cases}
$$</p>
<p>Energy:</p>
<p>$$
E=\sum _{fk}\sum _{i,j\in fk}(n^T_k\cdot (x_j-x_i))^2
$$</p>
<p><strong>求解线性方程组</strong></p>
<p><em>See more in [Zhang et al. Guided Mesh Normal Filtering. PG 2015.]</em></p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。
https://caterpillarstudygroup.github.io/GAMES102_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="3-global-smoothing"><a class="header" href="#3-global-smoothing">3. Global Smoothing</a></h1>
<h2 id="能量优化方法"><a class="header" href="#能量优化方法">能量优化方法</a></h2>
<p><em>Liu et al. Non‐Iterative Approach for Global Mesh  Optimization. CAD 2007.</em></p>
<p><img src="Smoothing/../assets/%E5%8E%BB%E8%BA%8132.png" alt="" /></p>
<blockquote>
<p>E(s')，第一项：光滑，第二项：数据保持，关键是如何度量光滑。</p>
</blockquote>
<h2 id="增加约束"><a class="header" href="#增加约束">增加约束</a></h2>
<p>约束：<a href="Smoothing/../LaplacianCoordinates/Constrained.html">link</a></p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。
https://caterpillarstudygroup.github.io/GAMES102_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="4-mesh-improvement"><a class="header" href="#4-mesh-improvement">4. Mesh Improvement</a></h1>
<p>什么是质量好？（1）三角形接近正三角形（2）无翻转</p>
<h2 id="方法一flip"><a class="header" href="#方法一flip">方法一：Flip</a></h2>
<p><img src="Smoothing/../assets/%E5%8E%BB%E8%BA%8149.png" alt="" /></p>
<p>Example<br />
<img src="Smoothing/../assets/%E5%8E%BB%E8%BA%8150.png" alt="" /></p>
<h1 id="其他去噪方法"><a class="header" href="#其他去噪方法">其他去噪方法</a></h1>
<ul>
<li>
<p>基于稀疏优化的方法<br />
• He and Schaefer. Mesh denoising via L0 minimization. Siggraph 2013.</p>
</li>
<li>
<p>基于压缩感知的方法<br />
• Wang et al. Decoupling Noises and Features via Weighted L1‐analysis Compressed Sensing.  ACM TOG, 2014.</p>
</li>
<li>
<p>基于机器学习的方法<br />
• Wang et al. Mesh Denoising via Cascaded Normal Regression. Siggraph 2016.</p>
</li>
<li>
<p>很多很多工作…</p>
</li>
</ul>
<h1 id="其他数据的去噪"><a class="header" href="#其他数据的去噪">其他数据的去噪</a></h1>
<p>• Point cloud</p>
<blockquote>
<p>点云：把点云去噪转化为前面学过的问题。例如取空间上的邻居点作为它的邻域。</p>
</blockquote>
<p>• Volumetric data</p>
<p>• Depth images</p>
<blockquote>
<p>深度相机的数据质量很差，尤其是深度这一维度。</p>
</blockquote>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。
https://caterpillarstudygroup.github.io/GAMES102_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="采样-sampling"><a class="header" href="#采样-sampling">采样 (Sampling)</a></h1>
<p>从连续到离散：<a href="SamplingTessellation/../DiscreteCurves/Discretization.html">link</a><br />
曲线曲面的离散表达：<a href="SamplingTessellation/../DiscreteCurves/Discretization.html">link</a></p>
<p>图像是对区域的采样，视频是对时间的采样</p>
<h2 id="采样与重建"><a class="header" href="#采样与重建">采样与重建</a></h2>
<p><img src="SamplingTessellation/../assets/%E9%87%87%E6%A0%B76.png" alt="" /></p>
<h2 id="采样与信号频率"><a class="header" href="#采样与信号频率">采样与信号频率</a></h2>
<p><strong>Nyquist–Shannon sampling theorem</strong></p>
<p><img src="SamplingTessellation/../assets/%E9%87%87%E6%A0%B77.png" alt="" /></p>
<p>Slide courtesy of Prof. Ren Ng, UC Berkeley</p>
<h2 id="欠采样产生频率的走样"><a class="header" href="#欠采样产生频率的走样">欠采样产生频率的走样</a></h2>
<p>• 高频函数拟合低频信号：过拟合<br />
• 低频函数拟合高频信号：欠拟合</p>
<p><img src="SamplingTessellation/../assets/%E9%87%87%E6%A0%B78.png" alt="" /></p>
<h1 id="采样举例"><a class="header" href="#采样举例">采样举例</a></h1>
<h2 id="1d曲线的采样分段线性逼近表达"><a class="header" href="#1d曲线的采样分段线性逼近表达">1D曲线的采样：分段线性逼近表达</a></h2>
<p><img src="SamplingTessellation/../assets/%E9%87%87%E6%A0%B712.png" alt="" /></p>
<h2 id="2d曲面的采样分片线性逼近表达"><a class="header" href="#2d曲面的采样分片线性逼近表达">2D曲面的采样：分片线性逼近表达</a></h2>
<p><img src="SamplingTessellation/../assets/%E9%87%87%E6%A0%B713.png" alt="" /></p>
<blockquote>
<p>三角形面片拟合曲面：分片线性逼近面<br />
课程以2D为例。</p>
</blockquote>
<h1 id="平面区域的采样"><a class="header" href="#平面区域的采样">平面区域的采样</a></h1>
<h2 id="规则采样"><a class="header" href="#规则采样">规则采样</a></h2>
<p>将一个区域分解为若干个小区域</p>
<p><img src="SamplingTessellation/../assets/%E9%87%87%E6%A0%B714.png" alt="" /></p>
<h2 id="不规则采样"><a class="header" href="#不规则采样">不规则采样</a></h2>
<p><img src="SamplingTessellation/../assets/%E9%87%87%E6%A0%B715.png" alt="" /></p>
<blockquote>
<p>如何根据不规则的采样点，把平面<strong>剖分</strong>成子区域（三角形）</p>
</blockquote>
<p><img src="SamplingTessellation/../assets/%E9%87%87%E6%A0%B716.png" alt="" /></p>
<h2 id="blue-noise-sampling"><a class="header" href="#blue-noise-sampling">Blue Noise Sampling</a></h2>
<p>Blue Noise：不均匀且没有规整的 pattern 可通过频谱图来分析。</p>
<p><img src="SamplingTessellation/../assets/%E9%87%87%E6%A0%B718.png" alt="" /></p>
<blockquote>
<p>👆 左： A uniformly distributed yet randomly located point set<br />
右：The typical power spectrum, radially averaged ower spectrum and anisotropy of blue noise distributions.</p>
</blockquote>
<h1 id="三角化-triangulation"><a class="header" href="#三角化-triangulation">三角化 Triangulation</a></h1>
<p>复杂函数的分片线性逼近 (piece‐wise linear approximation)</p>
<p><img src="SamplingTessellation/../assets/%E9%87%87%E6%A0%B717.png" alt="" /></p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。
https://caterpillarstudygroup.github.io/GAMES102_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="平面三角网格"><a class="header" href="#平面三角网格">平面三角网格</a></h1>
<p>给定平面上一些点，如何生成<strong>比较好</strong>的三角剖分？</p>
<h2 id="什么是好的三角剖分"><a class="header" href="#什么是好的三角剖分">什么是好的三角剖分？</a></h2>
<p><img src="SamplingTessellation/../assets/%E9%87%87%E6%A0%B719.png" alt="" /></p>
<p>• Minimal angle<br />
• Mean ratio<br />
• Aspect/radius ratio<br />
• <strong>Singular values</strong></p>
<blockquote>
<p>Singular values：奇异值<br />
计算当前三角形到正三角形的变换矩阵。 A 对奇异值做分解，得到2或3个奇异值。<br />
奇异值越接近，表明三角形越正。质量越好。</p>
</blockquote>
<p>• …</p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。
https://caterpillarstudygroup.github.io/GAMES102_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="delaunay三角化"><a class="header" href="#delaunay三角化">Delaunay三角化</a></h1>
<blockquote>
<p>[1:06:28] 一种点云剖分算法</p>
</blockquote>
<h2 id="剖分结果"><a class="header" href="#剖分结果">剖分结果</a></h2>
<p><img src="SamplingTessellation/../assets/%E9%87%87%E6%A0%B721.png" alt="" /></p>
<blockquote>
<p>绿点：点云、平面上的点</p>
</blockquote>
<p><img src="SamplingTessellation/../assets/%E9%87%87%E6%A0%B722.png" alt="" /></p>
<blockquote>
<p>(1) 给每个点一个区域，区域的边界由两个绿点的中垂线构成。（蓝线图）<br />
(2) 红线图为蓝线图的对偶图<br />
[?] 什么是对偶图？边对边、面对点是什么意思？<br />
以图上观察是，点所属区域有几个边，点就会发出多少连线，连线的另一端是区域边界对应的点。</p>
</blockquote>
<h2 id="具体过程"><a class="header" href="#具体过程">具体过程</a></h2>
<p><img src="SamplingTessellation/../assets/%E9%87%87%E6%A0%B723.png" alt="" /></p>
<p><img src="SamplingTessellation/../assets/%E9%87%87%E6%A0%B724.png" alt="" /></p>
<p><img src="SamplingTessellation/../assets/%E9%87%87%E6%A0%B725.png" alt="" /></p>
<p><img src="SamplingTessellation/../assets/%E9%87%87%E6%A0%B726.png" alt="" /></p>
<p>(1)图称为 Voronoi 图<br />
(2)图称为 Trangulation 图 </p>
<h1 id="properties-of-dt"><a class="header" href="#properties-of-dt">Properties of DT</a></h1>
<blockquote>
<p>DT: Delaunay Triangulation</p>
</blockquote>
<h2 id="空圆性质"><a class="header" href="#空圆性质">空圆性质</a></h2>
<p>Empty sphere property: no points inside the circum‐sphere of any simplex</p>
<p>空圆性质：三角形外接圆一定不含其它绿点（四点共圆除外）</p>
<p><img src="SamplingTessellation/../assets/%E9%87%87%E6%A0%B727.png" alt="" /></p>
<h2 id="最小角最大"><a class="header" href="#最小角最大">最小角最大</a></h2>
<p>最小角是指：所有三角形中最小的角<br />
最大是指：所有可能的三角化方法中，此方法的最小角最大。</p>
<p><em>[Lawson 1977] and [Sibson 1978]</em></p>
<p><img src="SamplingTessellation/../assets/%E9%87%87%E6%A0%B728.png" alt="" /></p>
<h2 id="凸包"><a class="header" href="#凸包">凸包</a></h2>
<p>三角形最外层边是点集的凸包</p>
<p><img src="SamplingTessellation/../assets/%E9%87%87%E6%A0%B729.png" alt="" /></p>
<h2 id="其它"><a class="header" href="#其它">其它</a></h2>
<ul>
<li>DT maximizes the arithmetic mean of the radius of inscribed circles of the triangles.
<ul>
<li>[Lambert 1994]</li>
</ul>
</li>
<li>DT minimizes roughness (the Dirichlet energy of any piecewise‐linear scalar function)
<ul>
<li>[Rippa 1990]</li>
</ul>
</li>
<li>DT minimizes the maximum containing radius (the radius of the smallest sphere containing the simplex)
<ul>
<li>[Azevedo and Simpson 1989], [Rajan 1991]</li>
</ul>
</li>
</ul>
<h1 id="edge-swappingflipping-sibson-1978"><a class="header" href="#edge-swappingflipping-sibson-1978">Edge Swapping/Flipping [Sibson 1978]</a></h1>
<blockquote>
<p>这是一个求Delaunay的方法</p>
</blockquote>
<ol>
<li>Start with any triangulation</li>
<li>find any two adjacent triangles that form a onvex uadrilateral that does not satisfy empty sphere condition</li>
<li>swap the diagonal of the quadrilateral to be a Deluany triangulation of that four points</li>
<li>repeat step 1,2 until stuck.</li>
</ol>
<p><img src="SamplingTessellation/../assets/%E9%87%87%E6%A0%B732.png" alt="" /></p>
<blockquote>
<p>优点：简单、直观、必定收敛。<br />
缺点：慢、不可并行。</p>
</blockquote>
<h1 id="algorithms-for-voronoi-diagrams"><a class="header" href="#algorithms-for-voronoi-diagrams">Algorithms for Voronoi Diagrams</a></h1>
<blockquote>
<p>这是一个求Voronoi的方法</p>
</blockquote>
<ul>
<li>Compute the intersection of n‐1 half‐planes for each site, and “merge” the cells into the diagram</li>
<li>Divide‐and‐conquer (1975, Shamos &amp; Hoey)</li>
<li>Plane sweep (1987, Fortune)</li>
<li>Randomized incremental construction (1992, Guibas, Knuth&amp; Sharir)</li>
</ul>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。
https://caterpillarstudygroup.github.io/GAMES102_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mesh-generation"><a class="header" href="#mesh-generation">Mesh Generation</a></h1>
<p>Given a <strong>fixed point set</strong>, Delaunay triangulation will try to make the triangulation more shape regular and thus is considered as a “good” structured mesh.</p>
<p><img src="SamplingTessellation/../assets/%E9%87%87%E6%A0%B733.png" alt="" /></p>
<p><strong>如果点集的位置本身就不好？</strong></p>
<p><img src="SamplingTessellation/../assets/%E9%87%87%E6%A0%B734.png" alt="" /></p>
<blockquote>
<p>👆 The <strong>distribution of points</strong> is more important for a good mesh.</p>
</blockquote>
<p>How to sample points to generate high‐quality meshes?</p>
<p><img src="SamplingTessellation/../assets/%E9%87%87%E6%A0%B735.png" alt="" /></p>
<h1 id="centroidal-voronoi-tessellation"><a class="header" href="#centroidal-voronoi-tessellation">Centroidal Voronoi Tessellation</a></h1>
<h2 id="定义-8"><a class="header" href="#定义-8">定义</a></h2>
<p><strong>定义</strong>: The VT is a centroidal Voronoi tessellation (CVT) , if each seed coincides with the <strong>centroid</strong> of its Voronoi cell</p>
<p><img src="SamplingTessellation/../assets/%E9%87%87%E6%A0%B736.png" alt="" /></p>
<blockquote>
<p>👆 CVT:满是“点与所在区域的重心重合”的 Voronoi 图。</p>
</blockquote>
<h2 id="方法-3"><a class="header" href="#方法-3">方法</a></h2>
<p><img src="SamplingTessellation/../RAW/83-1.png" alt="" /></p>
<p>• Construct the  VT associated with the points<br />
• Compute the centroids of the Voronoi regions<br />
• Move the points to the centroids<br />
• Iterate until convergent</p>
<h2 id="效果"><a class="header" href="#效果">效果</a></h2>
<p><img src="SamplingTessellation/../assets/%E9%87%87%E6%A0%B738.png" alt="" /></p>
<h2 id="cvt理论"><a class="header" href="#cvt理论">CVT理论</a></h2>
<p>CVT energy function:</p>
<p>$$
F(X)=\sum_{i=1}^{N} \int _{V_i}\rho (X)||X-X_i||^2dX
$$</p>
<p>CVT is a critical point of \(F(X)\), an optimal CVT is a global minimizer of \(F(X)\)</p>
<h3 id="geometric-interpretation"><a class="header" href="#geometric-interpretation">Geometric interpretation</a></h3>
<p>The CVT energy with \(\rho (X)\) identical to 1, is the volume difference between the circumscribed polytope and the araboloid.</p>
<blockquote>
<p>\(\rho (x)\)是种加权，用于内容相关。<br />
当 \(\rho =I 时， X为 V_i \)的重心时能量最小。</p>
</blockquote>
<p><img src="SamplingTessellation/../assets/%E9%87%87%E6%A0%B739.png" alt="" /></p>
<p>The gradient of \(F(X)\) is [Iri et al. 1984; Asami 1991; 
Du et al. 1999]:</p>
<p>$$
\frac{\partial F}{\partial \chi _i} =2m_i(\chi _i-C_i),
$$
where 
$$
m_i=\int _{\chi\in \Omega _i }\rho (\chi )d\sigma
$$</p>
<p>Lloyd’s method is a gradient descent method, thus has linear convergence</p>
<h3 id="smoothness-of-fx"><a class="header" href="#smoothness-of-fx">Smoothness of F(X)</a></h3>
<p>Can BFGS method be applied to computing CVT? Or does CVT energy F(X) have required \(C^2\) smoothness?</p>
<p>Results:</p>
<ul>
<li>It has been noted that F(X) is non‐smooth [Iri et al. 
1984], but without proof</li>
<li>It has been proved that F(X) is \(C^1\) [Cortes et al. 2005]</li>
<li>F(X) is \(C^2\) in a convex domain in 2D and 3D [Liu et al. 2009]</li>
</ul>
<h3 id="c2-continuity-of-fx"><a class="header" href="#c2-continuity-of-fx">C2 Continuity of F(X)</a></h3>
<p><img src="SamplingTessellation/../assets/%E9%87%87%E6%A0%B740.png" alt="" /></p>
<p><strong>Figure</strong>: Illustration of \(C^2\) smoothness of CVT energy in 2D</p>
<h2 id="cvt的应用"><a class="header" href="#cvt的应用">CVT的应用</a></h2>
<ul>
<li>CVT on Surface</li>
<li>CVT for Remeshing</li>
</ul>
<blockquote>
<p>[1:20:59]<br />
把 CVT 算法推广到曲面，可以把距离改为测地线度量<br />
连续曲面测地距离：表面上的孤长<br />
离散网格的测地距离：可参数化到平面再计算 </p>
</blockquote>
<h1 id="optimal-delaunay-triangulation"><a class="header" href="#optimal-delaunay-triangulation">Optimal Delaunay Triangulation</a></h1>
<p>ODT energy function:</p>
<p>$$
E(X)=||f-f_{I,T }||L^1(\Omega)
$$</p>
<p>$$
=\sum _{\tau \in T}\int _\tau f_I(X)dX-\int _\Omega f(X)dX
$$</p>
<p><img src="SamplingTessellation/../assets/%E9%87%87%E6%A0%B743.png" alt="" /></p>
<h1 id="cvt-vs-odt-energy"><a class="header" href="#cvt-vs-odt-energy">CVT VS ODT Energy</a></h1>
<p>• CVT energy</p>
<p>$$
F(X)=\sum _{i=1}^N\int _{V_i}||X-X_i||^2dX
$$</p>
<p>• ODT energy</p>
<p>$$
E(X)=\sum _{\tau \in T}\int _\tau f_I(X)dX-\int _\Omega f(X)dX
$$</p>
<p><img src="SamplingTessellation/../assets/%E9%87%87%E6%A0%B744.png" alt="" /></p>
<p><strong>比较：</strong>
<img src="SamplingTessellation/../assets/%E9%87%87%E6%A0%B746.png" alt="" /></p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。
https://caterpillarstudygroup.github.io/GAMES102_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="高维几何对象的采样与剖分"><a class="header" href="#高维几何对象的采样与剖分">高维几何对象的采样与剖分</a></h1>
<h2 id="二维流形曲面的三角网格化"><a class="header" href="#二维流形曲面的三角网格化">二维流形曲面的三角网格化</a></h2>
<p><img src="SamplingTessellation/../assets/%E9%87%87%E6%A0%B748.png" alt="" /></p>
<h2 id="二维流形曲面的四边形网格化"><a class="header" href="#二维流形曲面的四边形网格化">二维流形曲面的四边形网格化</a></h2>
<p><img src="SamplingTessellation/../assets/%E9%87%87%E6%A0%B749.png" alt="" /></p>
<h1 id="空间体的采样与剖分"><a class="header" href="#空间体的采样与剖分">空间体的采样与剖分</a></h1>
<ul>
<li>Interior of 3D shapes<br />
• FEM<br />
• Simulation<br />
• …</li>
<li>Two typical types<br />
• Tetrahedral meshes<br />
• Hexahedral meshes</li>
</ul>
<p><img src="SamplingTessellation/../assets/%E9%87%87%E6%A0%B750.png" alt="" /></p>
<blockquote>
<p>表面三角形，内部四面体。<br />
表面四边形，内部六面体。</p>
</blockquote>
<h1 id="solving-pde-fem"><a class="header" href="#solving-pde-fem">Solving PDE (FEM)</a></h1>
<p>见GAMES103</p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。
https://caterpillarstudygroup.github.io/GAMES102_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="回顾-1"><a class="header" href="#回顾-1">回顾</a></h1>
<p>\(R^3\)中的参数曲面：<a href="Parameterization/../ParametricFitting/VectorValue.html">link</a><br />
参数化(Parameterization)：<a href="Parameterization/../ParametricFitting/CurveFitting.html">link</a><br />
参数化的重要性：<a href="Parameterization/../ParametricFitting/CurveFitting.html">link</a></p>
<h1 id="参数化期望保持的几何性质"><a class="header" href="#参数化期望保持的几何性质">参数化期望保持的几何性质</a></h1>
<p>• 保角映射(angle‐preserving)：conformal（共形）<br />
• 保面积映射(area‐preserving)：authalic<br />
• 等距映射(isometric)：conformal + authalic</p>
<p><img src="Parameterization/../assets/%E5%8F%82%E6%95%B06.png" alt="" /></p>
<blockquote>
<p>👆 \(f\) is approximated by <strong>piecewise linear maps</strong> between pairs of triangles</p>
</blockquote>
<h1 id="参数化引起的扭曲"><a class="header" href="#参数化引起的扭曲">参数化引起的扭曲</a></h1>
<h2 id="low-distortion"><a class="header" href="#low-distortion">Low distortion</a></h2>
<p><img src="Parameterization/../assets/%E5%8F%82%E6%95%B012.png" alt="" /></p>
<h2 id="扭曲来源"><a class="header" href="#扭曲来源">扭曲来源</a></h2>
<p><img src="Parameterization/../assets/%E5%8F%82%E6%95%B09.png" alt="" /></p>
<blockquote>
<p>R 把3D三角形旋转为平面三角形。<br />
\(\phi \)是两个平面三角形之间的变形。扭曲都来自\(\phi \)</p>
</blockquote>
<p>\(\phi 是奇异矩阵，因此2D是3×3.扭曲都来自L(2×2)\)<br />
线性变换都可以用transformation matrix表示，都可以通过矩阵的性质来分析变换特点</p>
<h2 id="扭曲度量"><a class="header" href="#扭曲度量">扭曲度量</a></h2>
<p>$$
L=U\begin{pmatrix}\sigma_1  &amp; 0
\\0  &amp;\sigma _2
\end{pmatrix}V^*
$$</p>
<p>$$
\sigma _2\ge \sigma _1
$$</p>
<p><img src="Parameterization/../assets/%E5%8F%82%E6%95%B010.png" alt="" /></p>
<blockquote>
<p>\(L 是 2×2， 做SVD, \sigma_{1}和\sigma_{2}\)是奇异值。　</p>
</blockquote>
<p>• angle‐preserving (conformal) \(\sigma _1=\sigma _2\)</p>
<p>• area‐preserving (authalic) \(\sigma _1\sigma _2\)</p>
<p>• length‐preserving (isometric) \(\sigma _1=\sigma _2=1\)</p>
<h1 id="local-injectivity"><a class="header" href="#local-injectivity">Local Injectivity</a></h1>
<h2 id="flip-free-triangles"><a class="header" href="#flip-free-triangles">Flip free triangles</a></h2>
<p><img src="Parameterization/../assets/%E5%8F%82%E6%95%B015.png" alt="" /></p>
<h2 id="翻转度量"><a class="header" href="#翻转度量">翻转度量</a></h2>
<p><img src="Parameterization/../assets/%E5%8F%82%E6%95%B014.png" alt="" /></p>
<blockquote>
<p>翻转\(\sigma_{1}\cdot \sigma_{2}&lt;0 \)</p>
</blockquote>
<h2 id="distortion-flipfoldover"><a class="header" href="#distortion-flipfoldover">Distortion (Flip/Foldover)</a></h2>
<table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td><img src="Parameterization/../assets/%E5%8F%82%E6%95%B016.png" alt="" /></td><td><img src="Parameterization/../assets/%E5%8F%82%E6%95%B017.png" alt="" /></td></tr>
<tr><td><img src="Parameterization/../assets/%E5%8F%82%E6%95%B018.png" alt="" /></td><td><img src="Parameterization/../assets/%E5%8F%82%E6%95%B019.png" alt="" /></td></tr>
</tbody></table>
<h1 id="methods-of-mesh-parameterization"><a class="header" href="#methods-of-mesh-parameterization">Methods of Mesh Parameterization</a></h1>
<h2 id="tuttes-method-and-its-variants"><a class="header" href="#tuttes-method-and-its-variants">Tutte’s method and its variants</a></h2>
<h3 id="tuttes-embedding-method"><a class="header" href="#tuttes-embedding-method">Tutte’s embedding method</a></h3>
<p><em>Tutte’s method [Tutte 1963; Floater 1997, 2003]</em></p>
<p><a href="Parameterization/../LaplacianCoordinates/MeshParameterization.html">link</a></p>
<blockquote>
<p>外部点：映射到 convex boundary 上。<br />
内部点：1 邻域点的线性组合，权自己定义。通过求解稀疏方程组确定点的位置。<br />
优点：简单、不翻转。<br />
缺点：扭曲大。</p>
</blockquote>
<h3 id="variants-of-tuttes-embedding-method"><a class="header" href="#variants-of-tuttes-embedding-method">Variants of Tutte’s embedding method</a></h3>
<p><img src="Parameterization/../assets/%E5%8F%82%E6%95%B022.png" alt="" /></p>
<h2 id="geometrybased-optimization-methods"><a class="header" href="#geometrybased-optimization-methods">Geometry‐based optimization methods</a></h2>
<p>• Representation based methods [Sheffer and Sturler 2001;  Sheffer et al. 2005; Chien et al. 2016b; Fu and Liu 2016]<br />
• ARAP [Sorkine and Alex 2007; Liu et al. 2008]<br />
• Bounded distortion methods [Lipman 2012; Aigerman et al. 2014; Kovalsky et al. 015]</p>
<h3 id="angle-based-flattening-abf--abf"><a class="header" href="#angle-based-flattening-abf--abf">Angle Based Flattening (ABF) &amp; ABF++</a></h3>
<p>[Sheffer and Sturler 2001; Sheffer et al. 2005]</p>
<p>基于角度的展开，把角度当作变量，求解参数化的网格 </p>
<p><img src="Parameterization/../assets/%E5%8F%82%E6%95%B023.png" alt="" /></p>
<p><img src="Parameterization/../assets/%E5%8F%82%E6%95%B024-02.png" alt="" /></p>
<p><img src="Parameterization/../assets/%E5%8F%82%E6%95%B024.png" alt="" /></p>
<p><strong>目标</strong>:minimize (relative) deviation of angles</p>
<p>$$
F(\alpha )=\sum_{i,j}w_i^j(\alpha _i^j-\beta _i^j)^2
$$</p>
<p>Initial choice for weights:</p>
<p>$$
w_i^j=\beta  _i^{j^-2}
$$</p>
<p><strong>Constraints</strong>：To avoid flipped triangles</p>
<p>$$
g^1(\alpha )\equiv \alpha _i^j\ge \varepsilon
$$</p>
<p>$$
g^2(\alpha )\equiv \alpha _i^1+\alpha _i^2+\alpha _i^3=\pi 
$$</p>
<p>$$
g^3(\alpha )\equiv \sum _k\alpha _i^j(k)=2\pi 
$$</p>
<p>$$
g^4(\alpha )\equiv \prod _k\sin(\alpha _i^{j(k)-1})-\prod _k\sin(\alpha _i^{j(k)+1})=0
$$</p>
<p><img src="Parameterization/../assets/%E5%8F%82%E6%95%B025.png" alt="" /></p>
<p>$$
\frac{l_1}{l_2} =\frac{\sin(\alpha _1) }{\sin(\alpha _2) } 
$$</p>
<p>$$
\frac{l_1}{l_2} \cdots \frac{l_2}{l_1}=\frac{\sin(\alpha _1) }{\sin(\alpha _2) }\cdots \frac{\sin(\alpha _i) }{\sin(\alpha _j) }<br />
$$</p>
<p><strong>求解</strong>：用 Lagrange 算法解带约束的优化问题</p>
<h3 id="simplex-assembly-fu-and-liu-2016"><a class="header" href="#simplex-assembly-fu-and-liu-2016">Simplex Assembly [Fu and Liu 2016]</a></h3>
<blockquote>
<p>优化三角形变换的系数</p>
</blockquote>
<p>✅Instead of vertex positions, treat the affine transformation as variables<br />
✅Use a barrier function to prevent the inversion<br />
✅No theoretically guaranteed to avoid foldovers</p>
<p><img src="Parameterization/../assets/%E5%8F%82%E6%95%B028.png" alt="" /></p>
<blockquote>
<p>[Fu and Liu. Computing Inversion‐Free Mappings by Simplex Assembly. Siggraph Asia 2016]</p>
</blockquote>
<p><img src="Parameterization/../assets/%E5%8F%82%E6%95%B028-1.png" alt="" /></p>
<h2 id="foldover-free-guaranteed-optimization-methods"><a class="header" href="#foldover-free-guaranteed-optimization-methods">Foldover free guaranteed optimization methods</a></h2>
<p><em>[Smith and Schaefer 2015; Kovalsky et al. 2016; Jiang et al. 2017; Claici et al. 2017; Rabinovich et al. 2017; Shtengel et al.  2017; Zhu et al. 2018]</em></p>
<blockquote>
<p>以 Tuttle 算法为基础，调整边界点位置，减少扭曲</p>
</blockquote>
<h3 id="flipfree-parameterization-methods"><a class="header" href="#flipfree-parameterization-methods">Flip‐free parameterization methods</a></h3>
<ul>
<li>Start with a flip‐free (valid) initialization</li>
<li>Reducing the distortion while guaranteeing the validity<br />
• Generally non‐convex nonlinear optimization</li>
</ul>
<p><img src="Parameterization/../assets/%E5%8F%82%E6%95%B029.png" alt="" /></p>
<blockquote>
<p>红色表示扭曲大，白色表示扭曲少</p>
</blockquote>
<blockquote>
<p>调整的同时移动顶点，减少扭曲，关键是如何度量扭曲</p>
</blockquote>
<p><img src="Parameterization/../assets/%E5%8F%82%E6%95%B030.png" alt="" /></p>
<blockquote>
<p>度量扭曲的方法[22:43]（最后一个最常用）</p>
</blockquote>
<p><strong>目标</strong>：</p>
<p>$$
\min_{V} E(V)=\sum _{t\in T}(\sigma _1^2+\frac{1}{\sigma _1^2} +\sigma _2^2+\frac{1}{\sigma _2^2})
$$</p>
<p>s.t  \(\sigma _1\sigma _2&gt;0,\)  \(\forall t\)</p>
<p>• The cost function is highly <strong>nonlinear</strong> and <strong>nonconvex</strong><br />
• The constraints are <strong>nonlinear</strong><br />
• The Heissian matrix is highly <strong>non‐definite</strong></p>
<blockquote>
<p>Computationally expensive for large scale meshes!</p>
</blockquote>
<p><strong>求解</strong>：</p>
<p>Input: a valid parameterization initialization \(𝑥_0\)<br />
Repeat<br />
\(p=-H^{-1}\nabla E(x)\)<br />
How to find a good decent direction?</p>
<p>\(𝛼_{max}\)← injective maximal search step<br />
\(𝛼\) ←line search by backtracking from \(𝛼_{max}\)<br />
\(x ← 𝒙 + 𝛼p\)</p>
<p>Until converged<br />
<strong>Output</strong>: a locally injective parameterization</p>
<blockquote>
<p>局限性：非线性、非凸问题、且参数多<br />
因此优化效率低</p>
</blockquote>
<h3 id="more"><a class="header" href="#more">More</a></h3>
<blockquote>
<p>❗ 后面没展开讲的方法，就不记了，没讲清楚，记了也没用</p>
</blockquote>
<blockquote>
<p>AQP：利用离散 Laplacian 作为 Hessian 的近似<br />
SLIM: \(\dots ，加权 \dots \)<br />
AKVF:\(\dots 向量场算子\dots\)<br />
CM：使用隐式 Laplacian 矩阵，二阶方法、速度更快<br />
各种方法都是找更好的H近似，使得优化过程更快更稳定。</p>
</blockquote>
<ul>
<li>Accelerated Quadratic Proxy (AQP)</li>
</ul>
<blockquote>
<p>Kovalsky et al. Accelerated Quadratic Proxy for eometric Optimization. Siggraph 2016.</p>
</blockquote>
<ul>
<li>Scalable Locally Injective Mappings (SLIM)</li>
</ul>
<blockquote>
<p>Rabinovich et al. Scalable Locally Injective Mappings. Siggraph 2017.</p>
</blockquote>
<ul>
<li>Isometry‐Aware Preconditioning (AKVF)</li>
</ul>
<blockquote>
<p>Claici et al. Isometry‐Aware Preconditioning for Mesh Parameterization. SGP 2017.</p>
</blockquote>
<ul>
<li>Composite Majorization (CM)</li>
</ul>
<blockquote>
<p>Shtengel et al. Geometric Optimization via Composite Majorization. Siggraph 2017.</p>
</blockquote>
<ul>
<li>Blended Cured Quasi‐Newton (BCQN)</li>
</ul>
<blockquote>
<p>Zhu et al. Blended Cured quasi‐Newton for Distortion Optimization. Siggraph 2018.</p>
</blockquote>
<h3 id="progressive-paramerization"><a class="header" href="#progressive-paramerization">Progressive Paramerization</a></h3>
<p>• Near‐degenerate triangles (i.e., large distortion) in the initializations by Tutte’s method<br />
• Small iterative step and slow convergence in existing methods<br />
• Key: even one <strong>extremely large distortion</strong> term can <strong>restrict</strong> the line search <strong>step</strong> size!</p>
<p><img src="Parameterization/../assets/%E5%8F%82%E6%95%B038.png" alt="" /></p>
<blockquote>
<p>[Ligang Liu et al.  Progressive Parameterizations. Siggraph 2018]</p>
</blockquote>
<blockquote>
<p>问题描述：<br />
[图28:52]以脖子为边界。头挤在中间，中间扭曲很大⇒能量大⇒下降慢<br />
解决方法：<br />
[图29:29] <strong>不优化整体，或寻找更好的H逼近，而是中间那区域</strong><br />
*个人感觉不 make sense *<br />
[图30:35]</p>
</blockquote>
<p><img src="Parameterization/../assets/%E5%8F%82%E6%95%B039.png" alt="" /></p>
<blockquote>
<p>[Ligang Liu et al.  Progressive Parameterizations. Siggraph 2018]</p>
</blockquote>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。
https://caterpillarstudygroup.github.io/GAMES102_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bijective-parameterization"><a class="header" href="#bijective-parameterization">Bijective Parameterization</a></h1>
<p>问题描述：<br />
<strong>Globally intersection‐free</strong>，即不允许全局发生碰撞<br />
这是一个全局问题，因此计算量大</p>
<p><img src="Parameterization/../assets/%E5%8F%82%E6%95%B042.png" alt="" /></p>
<h1 id="解决方法-2"><a class="header" href="#解决方法-2">解决方法</a></h1>
<h2 id="quasinewton-qn-smith-et-al-2015"><a class="header" href="#quasinewton-qn-smith-et-al-2015">Quasi‐Newton (QN) [Smith et al. 2015]</a></h2>
<p><strong>Quasi‐Newton solver  with slow convergence</strong>!</p>
<p>Energy: 1.027<br />
Time: 8.57s<br />
Iterations: 3553</p>
<h2 id="scaffold-jiang-et-al-2017"><a class="header" href="#scaffold-jiang-et-al-2017">Scaffold [Jiang et al. 2017]</a></h2>
<p><strong>Linear systems with updated nonzero structure matrices</strong>!</p>
<p>Energy: 1.027<br />
Time: 3.22s<br />
Iterations: 24</p>
<blockquote>
<p>在形状外面包一层更大的网格<br />
在更大网格上用传统方法处理</p>
</blockquote>
<h2 id="efficient-bijective-parameterizations"><a class="header" href="#efficient-bijective-parameterizations">Efficient Bijective Parameterizations</a></h2>
<p>[Su et al. Siggraph 2020]</p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。
https://caterpillarstudygroup.github.io/GAMES102_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="封闭曲面的割缝问题"><a class="header" href="#封闭曲面的割缝问题">封闭曲面的割缝问题</a></h1>
<blockquote>
<p>封闭曲面要展开必须先割缝</p>
</blockquote>
<p><img src="Parameterization/../assets/%E5%8F%82%E6%95%B049.png" alt="" /></p>
<h1 id="existing-works"><a class="header" href="#existing-works">Existing Works</a></h1>
<h2 id="mesh-segmentation-approaches"><a class="header" href="#mesh-segmentation-approaches">Mesh segmentation approaches</a></h2>
<p>[Julius et al. 2005; Lévy et al. 2002; Sander et al. 2002, 2003; Zhang et al. 2005; Zhou et al. 2004]</p>
<h1 id="minimum-spanning-tree-methods"><a class="header" href="#minimum-spanning-tree-methods">Minimum spanning tree methods</a></h1>
<p><em>[Sheffer 2002; Sheffer and Hart 2002; Chai et al. 2018]</em></p>
<p><strong>Nodes: extrema points with high curvature/distortion etc</strong>.</p>
<p><img src="Parameterization/../assets/%E5%8F%82%E6%95%B050.png" alt="" /></p>
<blockquote>
<p>MST 算法1:<br />
找最大扭曲→找边界最短路径→路径对应割缝<br />
MST 算法 2：
把曲面映射到球面，找最大扭曲的点，连起来</p>
</blockquote>
<h1 id="simultaneous-optimization"><a class="header" href="#simultaneous-optimization">Simultaneous optimization</a></h1>
<p><em>[Poranne et al. 2017; Li et al. 2018]</em> </p>
<p><img src="Parameterization/../assets/%E5%8F%82%E6%95%B051.png" alt="" /></p>
<blockquote>
<p>OptCuts 算法<br />
通过割缝减少中心扭曲<br />
AutoCuts<br />
可以实时割开或合并</p>
</blockquote>
<h1 id="variational-surface-cutting"><a class="header" href="#variational-surface-cutting">Variational Surface Cutting</a></h1>
<p>[Sharp and Crane 2018]</p>
<p><img src="Parameterization/../assets/%E5%8F%82%E6%95%B052.png" alt="" /></p>
<p>扭曲小 &amp;&amp; 割缝总长度小</p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。
https://caterpillarstudygroup.github.io/GAMES102_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="纹理地图多片参数化"><a class="header" href="#纹理地图多片参数化">纹理地图：多片参数化</a></h1>
<p>Texture Atlas，Multi‐charts Parameterization</p>
<blockquote>
<p>[43:48]<br />
单片参数化扭曲大，因此切成小片，分别参数化、再拼起来。<br />
拼起来时尽量少的面积浪费[44:54]，即Minimizing <strong>Packing Efficiency</strong> (<strong>PE</strong>)</p>
</blockquote>
<p><img src="Parameterization/../assets/%E5%8F%82%E6%95%B055.png" alt="" /></p>
<h1 id="atlas-generation-集装箱问题"><a class="header" href="#atlas-generation-集装箱问题">Atlas Generation 集装箱问题</a></h1>
<ul>
<li>Low Distortion<br />
• [Golla et al. 2018; Liu et al. 2018; Shtengel et al. 2017; Zhu et al. 2018]</li>
<li>Consistent orientation<br />
• [Floater 2003; Tutte 1963; Claici et al. 2017; Hormann and Greiner 2000; Rabinovich et al. 2017; Schüller et al. 2013]</li>
<li>Bijection<br />
• [Jiang et al. 2017; Smith and Schaefer 2015]</li>
<li>Low boundary length<br />
• [Li et al. 2018; Poranne et al. 2017; Sorkine et al. 2002]</li>
<li>Packing efficiency<br />
• Box cutter [Limper et al. 2018]<br />
• <strong>Bounded Packing Efficiency</strong> [<strong>Liu et al. 2019</strong>]</li>
</ul>
<h1 id="atlas-refinement-higher-pe"><a class="header" href="#atlas-refinement-higher-pe">Atlas Refinement: Higher PE</a></h1>
<p><img src="Parameterization/../assets/%E5%8F%82%E6%95%B056.png" alt="" /></p>
<h1 id="box-cutter-limper-et-al-2018"><a class="header" href="#box-cutter-limper-et-al-2018">Box Cutter [Limper et al. 2018]</a></h1>
<ul>
<li>Atlas refinement<br />
• Remove overlaps<br />
• Improve <strong>packing efficiency</strong></li>
</ul>
<p><img src="Parameterization/../assets/%E5%8F%82%E6%95%B057.png" alt="" /></p>
<ul>
<li>No additional distortion</li>
<li>Bounded boundary length elongation</li>
</ul>
<p><img src="Parameterization/../assets/%E5%8F%82%E6%95%B058.png" alt="" /></p>
<blockquote>
<p>Boater:割开与填补</p>
</blockquote>
<h1 id="bounded-packing-efficiency"><a class="header" href="#bounded-packing-efficiency">Bounded Packing Efficiency</a></h1>
<p><img src="Parameterization/../assets/%E5%8F%82%E6%95%B059.png" alt="" /></p>
<blockquote>
<p>[Liu et al. Atlas Refinement with Bounded Packing Efficiency. Siggraph 2019.]</p>
</blockquote>
<blockquote>
<p>把网格参数化为box align.装箱之后再对边界优化</p>
</blockquote>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。
https://caterpillarstudygroup.github.io/GAMES102_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="球面参数化"><a class="header" href="#球面参数化">球面参数化</a></h1>
<p>输入：亏格为0的封闭曲面（拓扑同胚于球面）</p>
<p><img src="Parameterization/../assets/%E5%8F%82%E6%95%B062.png" alt="" /></p>
<h2 id="球面参数化的主要方法"><a class="header" href="#球面参数化的主要方法">球面参数化的主要方法</a></h2>
<ul>
<li>Direct methods<br />
• [Kent et al. 1992], [Kobbelt et al. 99], [Gu et al. 03]</li>
<li>Optimization methods<br />
• [Sheffer et al. 04], [Li et al.06&amp;07], [Zayer et al.06], [Friedel et al., 07], [Kazhdan et al. 2012], [Wan et al. 
12&amp;13], [Wang et al., 14&amp;16]</li>
<li>Coarse‐to‐fine methods<br />
• [Praun and Hoppe 04], [Tang et al. 16], [Hu et al. 17]</li>
</ul>
<h1 id="mapping-between-mesh-surfaces"><a class="header" href="#mapping-between-mesh-surfaces">Mapping between Mesh Surfaces</a></h1>
<p>相容性网格（Compatible mesh）：一组具有相同连接关系且与给定模型形状近似的网格</p>
<p><img src="Parameterization/../assets/%E5%8F%82%E6%95%B064.png" alt="" /></p>
<h1 id="总结曲面参数化"><a class="header" href="#总结曲面参数化">总结：曲面参数化</a></h1>
<p>• 几何处理的基本问题：大量的应用<br />
• 是一个从3D到2D的降维问题：将几何数据表达为图像<br />
• 特殊的几何结构（三角网格）：特殊的优化方法</p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。
https://caterpillarstudygroup.github.io/GAMES102_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="关于简化"><a class="header" href="#关于简化">关于简化</a></h1>
<p><img src="Simplification/../assets/67.PNG" alt="" /></p>
<h2 id="简化原因"><a class="header" href="#简化原因">简化原因</a></h2>
<ol>
<li>冗余数据：信息熵</li>
<li>由于计算能力不足，需要简化模型</li>
<li>有些场景中，不需要足够精细的模型(LOD)</li>
</ol>
<h2 id="simplification-applications"><a class="header" href="#simplification-applications">Simplification Applications</a></h2>
<ul>
<li>Level‐of‐detail modeling<br />
<img src="Simplification/../assets/%E7%AE%80%E5%8C%961.png" alt="" /> 
• Generate a family of models for the same object with 
different polygon counts<br />
• Select the appropriate model based on estimates of the object's projected size</li>
<li>Simulation proxies<br />
• Run the simulation on a simplified model<br />
• Interpolate results across a more complicated model to be used for rendering</li>
</ul>
<h2 id="tradeoff"><a class="header" href="#tradeoff">Tradeoff</a></h2>
<p>• Size<br />
• Error<br />
• Quality</p>
<p><img src="Simplification/../assets/%E7%AE%80%E5%8C%964.png" alt="" /></p>
<h2 id="performance-requirements"><a class="header" href="#performance-requirements">Performance Requirements</a></h2>
<ul>
<li>Offline<br />
• Generate model at given level(s) of detail<br />
• Focus on quality</li>
<li>Real‐time<br />
• Generate model at given level(s) of detail<br />
• Focus on speed<br />
• Requires preprocessing<br />
• Time/space/quality tradeoff</li>
</ul>
<h1 id="简化算法"><a class="header" href="#简化算法">简化算法</a></h1>
<h2 id="顶点删除-图5451"><a class="header" href="#顶点删除-图5451">顶点删除 [图54:51]</a></h2>
<h3 id="方法一"><a class="header" href="#方法一">方法一</a></h3>
<p>v ← v‐1，f ← f‐2<br />
Remaining vertices是subset of original vertex set</p>
<p><img src="Simplification/../assets/%E7%AE%80%E5%8C%966.png" alt="" /></p>
<h3 id="方法二"><a class="header" href="#方法二">方法二</a></h3>
<p>Pair contraction (cluster of two vertices)<br />
Vertices may move</p>
<p><img src="Simplification/../assets/%E7%AE%80%E5%8C%969.png" alt="" /></p>
<h2 id="边收缩-图5646-edge-collapse"><a class="header" href="#边收缩-图5646-edge-collapse">边收缩 [图56:46] Edge collapse</a></h2>
<h3 id="方法一-1"><a class="header" href="#方法一-1">方法一</a></h3>
<p>v ← v‐1，f ← f‐2<br />
Vertices may move</p>
<p><img src="Simplification/../assets/72.PNG" alt="" /></p>
<ul>
<li>原理：</li>
</ul>
<ol>
<li>选择一条边，把边坍缩成点</li>
<li>建立边周围的点到新点之间的边</li>
<li>使坍缩后的形状与坍缩前尽量接近</li>
</ol>
<ul>
<li>要解决的问题：</li>
</ul>
<ol>
<li>要坍缩哪些边？</li>
<li>边坍缩成点以后，这个点应该放在什么位置？</li>
<li>怎么衡量坍缩后的形状与坍缩前的接近程度？</li>
</ol>
<h3 id="方法二-1"><a class="header" href="#方法二-1">方法二</a></h3>
<p>Cluster contraction (set of vertices)<br />
Vertices may move</p>
<p><img src="Simplification/../assets/%E7%AE%80%E5%8C%9610.png" alt="" /></p>
<h2 id="面-triangle-collapse"><a class="header" href="#面-triangle-collapse">面 Triangle collapse</a></h2>
<h3 id="方法一-2"><a class="header" href="#方法一-2">方法一</a></h3>
<p>v ← v‐2，f ← f‐4<br />
Vertices may move</p>
<p><img src="Simplification/../assets/%E7%AE%80%E5%8C%968.png" alt="" /></p>
<h3 id="方法二-2"><a class="header" href="#方法二-2">方法二</a></h3>
<p>聚类法：[57:46]，画格子，格子内的三角形收缩、点合并会产生非流型和悬挂边</p>
<p>Merge all vertices within the same cell</p>
<p><img src="Simplification/../assets/%E7%AE%80%E5%8C%9611.png" alt="" /></p>
<h1 id="简化度量"><a class="header" href="#简化度量">简化度量</a></h1>
<p>衡量坍缩后的形状与坍缩前的接近程度</p>
<p>• 几何<br />
• 视觉：纹理、材质、法向…</p>
<h2 id="local-vs-global-error"><a class="header" href="#local-vs-global-error">Local vs. Global Error</a></h2>
<p>全局优于局部，具体见下一页</p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。
https://caterpillarstudygroup.github.io/GAMES102_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="1-local-simplification-strategies"><a class="header" href="#1-local-simplification-strategies">1. Local Simplification Strategies</a></h1>
<p>Local error: Compare new patch with previous iteration</p>
<p>• Fast<br />
• Accumulates error<br />
• Memory‐less</p>
<p>大部分情况下local就够用了。</p>
<h2 id="the-basic-algorithm"><a class="header" href="#the-basic-algorithm">The Basic Algorithm</a></h2>
<p>（1） Select the element with minimal error<br />
（2） Perform simplification operation (remove/contract)<br />
（3） Update error (local/global)<br />
重复（1）-（3）Until mesh size / quality is achieved</p>
<h2 id="顶点删除的误差度量"><a class="header" href="#顶点删除的误差度量">顶点删除的误差度量</a></h2>
<blockquote>
<p>点越尖锐越重要。(Laplace,一圈夹角等)</p>
</blockquote>
<ul>
<li>Measures<br />
• Distance to plane<br />
• Curvature</li>
<li>Usually approximated<br />
• Average plane<br />
• Discrete curvature</li>
</ul>
<p><img src="Simplification/../assets/%E7%AE%80%E5%8C%9613.png" alt="" /></p>
<h2 id="边收缩的误差度量"><a class="header" href="#边收缩的误差度量">边收缩的误差度量</a></h2>
<h3 id="quadris-error-matricsqem-二次误差度量"><a class="header" href="#quadris-error-matricsqem-二次误差度量">Quadris Error Matrics(QEM), 二次误差度量</a></h3>
<p>二次误差度量用于衡量“坍缩后的形状与坍缩前的接近程度”，使算法可以基于此标准选择要坍缩的边及确定坍缩点的位置。</p>
<p>用二次曲面拟合这条边。拟合得到系数矩阵，用矩阵性质度量扭曲。从直观上理解就是， 二次误差来度量[41：17]  = new point 到 old edge（或old face） 的距离平方和。</p>
<p>（1） Choose point closest to set of planes (triangles)</p>
<p><img src="Simplification/../assets/%E7%AE%80%E5%8C%9617.png" alt="" /></p>
<p>坍缩点的位置应该在使二次度量误差最小的地方。<br />
找到坍缩点转化为一个优化问题。</p>
<p>（2） Sum of squared distances to set of planes is quadratic  \(\Rightarrow\)  has a minimum</p>
<p>把所有边都尝试坍缩，评估一下每条边如果要做坍缩并选择了最好的坍缩点位置，会得到多少误差。最后选择造成误差最少的边。</p>
<p>即：遍历-计算-排序-选择-坍缩</p>
<p>每次选择当前最优，这是贪心的思想。不一定最终是最优，但是至少效果可用。</p>
<p><img src="Simplification/../assets/%E7%AE%80%E5%8C%9618.png" alt="" /></p>
<blockquote>
<p>用二次曲面来拟合，得到系数矩阵，用二次曲面性质来度量 [Garland &amp; Heckbert 1997]</p>
</blockquote>
<p>Given a plane, we can define a <strong>quadric</strong> Q</p>
<p>$$
Q=(A,b,c)=(nn^T,dn,d^2)
$$</p>
<p>measuring squared distance to the plane as</p>
<p>$$
Q(V)=V^TAV+2b^TV+c
$$</p>
<p>$$
Q(V)=\begin{bmatrix}
x  &amp;  y&amp;z
\end{bmatrix}\begin{bmatrix}
a^2 &amp;ab  &amp;ac \\
ab&amp;  b^2&amp;bc \\
ac &amp; bc &amp;c^2
\end{bmatrix}\begin{bmatrix}
x\\
y\\
z
\end{bmatrix}+2\begin{bmatrix}
ad &amp; bd &amp;cd
\end{bmatrix}\begin{bmatrix}
x\\
y\\
z
\end{bmatrix}+d^2
$$</p>
<blockquote>
<p>Garland and Heckbert. Surface Simplification Using Quadric Error Metrics. Siggraph 1997.</p>
</blockquote>
<ul>
<li>Sum of quadrics represents set of planes</li>
</ul>
<p>$$
\sum _i(n_i^TV+d_i)^2=\sum _iQ_i(V)=\begin{pmatrix}\sum _iQ_i
\end{pmatrix}(V)
$$</p>
<ul>
<li>Each vertex has an associated quadric<br />
• Error\((v_i) = Q_i (v_i)\)<br />
• Sum quadrics when contracting \((v_i,v_j) \to v’\)<br />
• Cost of contraction is \(Q(v’)\)</li>
</ul>
<p>$$
Q=Q_i+Q_j=(A_i+A_j,b_i+b_j,c_i+c_j)
$$</p>
<ul>
<li>Sum of endpoint quadrics determines v’<br />
• Fixed placement: select \(v_1\) or \(v_2\)<br />
• Optimal placement: choose v’ minimizing \(Q(v’)\)</li>
</ul>
<p>$$
\nabla Q({V}' )=0\Rightarrow {V}' =-A^{-1}b
$$</p>
<p>• Fixed placement is faster but lower quality<br />
• But it also gives smaller progressive meshes<br />
• Fallback to fixed placement if A is non‐invertible</p>
<h3 id="contracting-two-vertices"><a class="header" href="#contracting-two-vertices">Contracting Two Vertices</a></h3>
<ul>
<li><strong>Goal</strong>: Given edge e=(\(v_1, v_2\)), find contracted</li>
</ul>
<p>\(v=(x, y, z)\) that minimizes  \(\Delta(v)\):</p>
<p>$$
\partial \Delta / \partial x=\partial \Delta / \partial y=\partial \Delta / \partial z=0 
$$</p>
<ul>
<li>Solve system of linear normal equations.</li>
</ul>
<p>$$
\begin{bmatrix}
q_{11} &amp;q_{12}  &amp;q_{13}  &amp;q_{14} \\
q_{21}  &amp; q_{22} &amp;q_{23}  &amp; q_{24}\\
q_{31}  &amp; q_{32} &amp;q_{33}  &amp; q_{34}\\
0&amp; 0 &amp; 0 &amp;1
\end{bmatrix}V=\begin{bmatrix}
0 \\
0\\
0\\
1
\end{bmatrix}
$$</p>
<p>If no solution - select the edge midpoint</p>
<h3 id="visualizing-quadrics"><a class="header" href="#visualizing-quadrics">Visualizing Quadrics</a></h3>
<p><img src="Simplification/../assets/%E7%AE%80%E5%8C%9619.png" alt="" /></p>
<ul>
<li>Quadric isosurfaces<br />
• Are ellipsoids (maybe degenerate)<br />
• Centered around vertices<br />
• Characterize shape<br />
• Stretch in least‐curved directions</li>
</ul>
<blockquote>
<p>简化后的折叠、翻转现象</p>
</blockquote>
<h3 id="selecting-valid-pairs-for-contraction"><a class="header" href="#selecting-valid-pairs-for-contraction">Selecting Valid Pairs for Contraction</a></h3>
<ul>
<li>Edges:</li>
</ul>
<p>{\((v_1, v_2):(v_1v_2)\). is in the mesh }</p>
<ul>
<li>Close vertices:</li>
</ul>
<p>{\((v_1,v_2):||v_1-v_2||&lt;T\)}</p>
<ul>
<li>Threshold T is input parameter</li>
</ul>
<p><img src="Simplification/../assets/%E7%AE%80%E5%8C%9620.png" alt="" /></p>
<h3 id="动态优先队列"><a class="header" href="#动态优先队列">动态优先队列</a></h3>
<p>计算一条边的坍缩点及坍缩误差是一个优化问题，用迭代法来解。因此“遍历-计算”是一个比较耗时的过程。<br />
尤其是使用“遍历-计算-排序-选择-坍缩”的过程坍缩了一条边之后，坍缩过程对被坍缩的边周围的边造成影响，上一轮的“遍历-计算”的结果已经不适用了，不能直接基于此结果做排序和选择。</p>
<ul>
<li>解决方法：</li>
</ul>
<p>优先队列。动态更新受影响的边。</p>
<p>预处理：遍历-计算-生成队列<br />
循环：取队列top - 坍缩 - 部分点重新计算 - 更新队列部分点</p>
<blockquote>
<p>💡 计算出new point的位置后可以再调整一下old point的位置。</p>
</blockquote>
<h3 id="algorithm"><a class="header" href="#algorithm">Algorithm</a></h3>
<ul>
<li>Compute \(Q_v\) for all the mesh vertices</li>
<li>Identify all valid pairs</li>
<li>Compute for each valid pair (\(v_1, v_2\)) the contracted vertex \(v\) and its error  \(\Delta(v)\)</li>
<li>Store all valid pairs in a priority queue (according to  \(\Delta(v)\))</li>
<li>While reduction goal not met<br />
• Contract edge (\(v_1, v_2\))  with the smallest error to \(v\)<br />
• Update the priority queue with new valid pairs</li>
</ul>
<h3 id="artifacts-by-edge-collapse"><a class="header" href="#artifacts-by-edge-collapse">Artifacts by Edge Collapse</a></h3>
<p><img src="Simplification/../assets/%E7%AE%80%E5%8C%9621.png" alt="" /></p>
<p>收缩后会出现边的翻转</p>
<h3 id="pros-and-cons"><a class="header" href="#pros-and-cons">Pros and Cons</a></h3>
<ul>
<li>Pros<br />
• Error is bounded<br />
• Allows topology simplification<br />
• High quality result<br />
• Quite efficient</li>
<li>Cons<br />
• Difficulties along boundaries<br />
• Difficulties with coplanar planes<br />
• Introduces new vertices not present in the original mesh</li>
</ul>
<h2 id="appearancebased-metrics"><a class="header" href="#appearancebased-metrics">Appearance‐based metrics</a></h2>
<ul>
<li>Generalization required to handle appearance properties
<ul>
<li>color</li>
<li>texture</li>
<li>normals</li>
<li>etc.</li>
</ul>
</li>
<li>Treat each vertex as a 6‐vector [x,y,z,r,g,b]
<ul>
<li>Assume this 6D space is Euclidean
<ul>
<li>Of course, color space is only roughly Euclidean</li>
</ul>
</li>
<li>Scale xyz space to unit cube for consistency</li>
</ul>
</li>
</ul>
<h3 id="generalized-quadric-metric"><a class="header" href="#generalized-quadric-metric">Generalized Quadric Metric</a></h3>
<table><thead><tr><th></th><th>Vertex</th><th>Dimension</th></tr></thead><tbody>
<tr><td>Color</td><td>[x y z r g b]</td><td>6x6 quadrics</td></tr>
<tr><td>Texture</td><td>[x y z s t]</td><td>5x5 quadrics</td></tr>
<tr><td>Norma</td><td>[x y z u v w]</td><td>6x6 quadrics</td></tr>
<tr><td>Color+Normal</td><td>[x y z r g b u v w]</td><td>9x9 quadrics</td></tr>
</tbody></table>
<p>$$
Q(V)=V^TAV+2b^TV+C
$$</p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。
https://caterpillarstudygroup.github.io/GAMES102_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="2-global-simplification-strategies"><a class="header" href="#2-global-simplification-strategies">2. Global Simplification Strategies</a></h1>
<h2 id="21-mesh-retiling-turk-92"><a class="header" href="#21-mesh-retiling-turk-92">2.1 Mesh Re‐Tiling [Turk 92]</a></h2>
<p>Re‐tiling attempts to simplify as well as improve meshing by introducing new “uniformly spaced ” vertices</p>
<p><img src="Simplification/../assets/%E7%AE%80%E5%8C%9626.png" alt="" /></p>
<blockquote>
<p>本质上是在曲面上重采样<br />
把顶点看作曲面上流动的粒子，模拟粒子之间的作用力<br />
不能保持 Appearance 特征</p>
</blockquote>
<h2 id="22-mesh-optimization-hoppe-et-al-93"><a class="header" href="#22-mesh-optimization-hoppe-et-al-93">2.2 Mesh Optimization [Hoppe et al 93]</a></h2>
<ul>
<li>Frames simplification as an optimization problem<br />
• Minimizes some <strong>energy function</strong><br />
• Make simple changes to the topology of the mesh<br />
• Evaluate the energy before and after the change<br />
• Accept any change that reduces the energy</li>
</ul>
<p>$$
\min\int d^2(U,V)
$$</p>
<p><img src="Simplification/../assets/%E7%AE%80%E5%8C%9628.png" alt="" /></p>
<blockquote>
<p>光顺能量<br />
minimize Laplacian 能量 [1:06:02图]</p>
</blockquote>
<h1 id="basic-topological-operations"><a class="header" href="#basic-topological-operations">Basic Topological Operations</a></h1>
<p>• Edge Collapse<br />
• Edge Split<br />
• Edge Swap</p>
<p><img src="Simplification/../assets/%E7%AE%80%E5%8C%9629.png" alt="" /></p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。
https://caterpillarstudygroup.github.io/GAMES102_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="level-of-detail-lod"><a class="header" href="#level-of-detail-lod">Level of Detail (LOD)</a></h1>
<p><img src="Simplification/../assets/%E7%AE%80%E5%8C%9630.png" alt="" /></p>
<h1 id="多分辨率的分析与表达"><a class="header" href="#多分辨率的分析与表达">多分辨率的分析与表达</a></h1>
<h2 id="多分辨率表达-multiresolution-representation"><a class="header" href="#多分辨率表达-multiresolution-representation">多分辨率表达 Multiresolution Representation</a></h2>
<p>Multiresolution Representation of \(M\) = Base mesh \(M^0\)  +  A sequence of refinements \(M^i\)</p>
<blockquote>
<p>\(M_i\)： (中间的操作)，记录简化过程</p>
</blockquote>
<p><img src="Simplification/../assets/%E7%AE%80%E5%8C%9631.png" alt="" /></p>
<h2 id="多分辨率分析-multiresolution-analysis"><a class="header" href="#多分辨率分析-multiresolution-analysis">多分辨率分析 Multiresolution Analysis</a></h2>
<p>[Lounsbery-etal93] [Eck-etal95] [Certain-etal96]</p>
<p><img src="Simplification/../assets/%E7%AE%80%E5%8C%9632.png" alt="" /></p>
<h1 id="1-discrete-lod"><a class="header" href="#1-discrete-lod">1. Discrete LOD</a></h1>
<p>提前生成好不同 level 的模型，根据实际情况决定用哪个可能存在跳变。</p>
<h1 id="2-continuous-lod"><a class="header" href="#2-continuous-lod">2. Continuous LOD</a></h1>
<p>记录中间操作，可以只增加或减少一个边<br />
消耗计算资源，因此不常用</p>
<p><img src="Simplification/../assets/%E7%AE%80%E5%8C%9635.png" alt="" /></p>
<blockquote>
<p>👆 recode sequence of edge collapses</p>
</blockquote>
<h1 id="3-viewdependent-lod"><a class="header" href="#3-viewdependent-lod">3. View‐Dependent LOD</a></h1>
<p>Show nearby portions of object at higher resolution than distant portions</p>
<p><img src="Simplification/../assets/%E7%AE%80%E5%8C%9641.png" alt="" /></p>
<h1 id="challenges-1"><a class="header" href="#challenges-1">Challenges</a></h1>
<ul>
<li>纹理的简化<br />
• 熵、保特征…</li>
<li>数据组织与调度<br />
• 虚拟纹理<br />
• 虚拟几何</li>
<li>计算模式<br />
• Client/Server (CS)<br />
• Browser/Server (BS)<br />
• Cloud‐Edge‐Client computing：云、边、端</li>
<li>…</li>
</ul>
<h1 id="resources"><a class="header" href="#resources">Resources</a></h1>
<ul>
<li>Internet, Papers, Siggraph courses</li>
<li>VDSlib ‐<a href="http://vdslib.virginia.edu">http://vdslib.virginia.edu</a><br />
• A public‐domain view‐dependent simplification and rendering  package/library</li>
<li>Luebke's work on view‐dependent simplification:<br />
• <a href="http://www.cs.virginia.edu/%7Eluebke/simplification.html">http://www.cs.virginia.edu/~luebke/simplification.html</a></li>
<li>Hoppe's work on progressive meshes:<br />
• <a href="http://www.research.microsoft.com/%7Ehhoppe">http://www.research.microsoft.com/~hhoppe</a></li>
<li>Garland's work on quadric error metrics:<br />
• <a href="http://www.uiuc.edu/%7Egarland">http://www.uiuc.edu/~garland</a><br />
• <a href="http://www.cs.cmu.edu/afs/cs/user/garland/www/multires/survey.html">http://www.cs.cmu.edu/afs/cs/user/garland/www/multires/survey.html</a></li>
<li>The Multi‐Tesselation (MT) homepage:<br />
• <a href="http://www.disi.unige.it/person/MagilloP/MT">http://www.disi.unige.it/person/MagilloP/MT</a></li>
</ul>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。
https://caterpillarstudygroup.github.io/GAMES102_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="回顾-2"><a class="header" href="#回顾-2">回顾</a></h1>
<p>曲面参数化<br />
映射（ Mapping / Map ）<br />
平面几何映射</p>
<h1 id="映射的表达"><a class="header" href="#映射的表达">映射的表达</a></h1>
<h2 id="映射基函数的线性组合"><a class="header" href="#映射基函数的线性组合">映射：基函数的线性组合</a></h2>
<p>映射表达为基本映射（基函数）的线性组合</p>
<p>• 基函数(basis functions):</p>
<p>$$
f_1,f_2,f_3,\cdots ,f_n
$$</p>
<p>• 基函数的线性组合：</p>
<p>$$
f(X)=\begin{pmatrix}u(X)
\\v(X)
\end{pmatrix}=\begin{pmatrix}\sum a_if_i(X)
\\\sum b_if_i(X)
\end{pmatrix}
$$</p>
<p><img src="Mapping/../assets/%E6%98%A0%E5%B0%844.png" alt="" /></p>
<p><img src="Mapping/../assets/%E6%98%A0%E5%B0%845.png" alt="" /></p>
<p><img src="Mapping/../assets/%E6%98%A0%E5%B0%846.png" alt="" /></p>
<h2 id="映射简单区域上映射的连续组合"><a class="header" href="#映射简单区域上映射的连续组合">映射：简单区域上映射的连续组合</a></h2>
<p>映射表达为小区域（三角形区域）上映射的拼接</p>
<p>\(f\) is approximated by <strong>piecewise linear maps</strong> between pairs of triangles</p>
<p><img src="Mapping/../assets/%E6%98%A0%E5%B0%847.png" alt="" /></p>
<h1 id="几何映射的例子"><a class="header" href="#几何映射的例子">几何映射的例子</a></h1>
<h2 id="例12d变形"><a class="header" href="#例12d变形">例1：2D变形</a></h2>
<p><img src="Mapping/../assets/%E6%98%A0%E5%B0%848.png" alt="" /></p>
<blockquote>
<p>[06:51] 2D变形问题：构造一个函数\(f\)， 使得拖拽点\(f(P)\)满足到达目标点的约束。<br />
[10:06] 或\(f(P)\)满足\(f'(P)\)为目标值的约束，就是法线插值。<br />
[10:43] mesh 点是指定点（例如重心坐标）的组合。通过移动指定点控制mesh.</p>
</blockquote>
<p>本质：插值问题</p>
<h2 id="例2-barycentric-coordinates"><a class="header" href="#例2-barycentric-coordinates">例2: Barycentric Coordinates</a></h2>
<p>重心坐标：<a href="Mapping/../DiscreteCurves/BarycentricCoordinate.html">link</a></p>
<h1 id="映射的性质"><a class="header" href="#映射的性质">映射的性质</a></h1>
<p>问：What are good maps?</p>
<p><img src="Mapping/../assets/%E6%98%A0%E5%B0%8414.png" alt="" /></p>
<p>答：（1）满足双射，即Source 与 target 一一 对应。local 双射（单射)：一一对应，但有翻转发生<br />
（2）扭曲尽量少，否则有鬼影现象 [21:28下图]</p>
<h2 id="翻转-flip-foldover---单射"><a class="header" href="#翻转-flip-foldover---单射">翻转 Flip (foldover) - 单射</a></h2>
<h3 id="现象"><a class="header" href="#现象">现象</a></h3>
<p><img src="Mapping/../assets/%E6%98%A0%E5%B0%8415.png" alt="" /></p>
<h3 id="原理-1"><a class="header" href="#原理-1">原理</a></h3>
<p><img src="Mapping/../assets/%E6%98%A0%E5%B0%8426.png" alt="" /></p>
<p>\(f(x)\)是映射关系，求\(f\)的 Jacobian,</p>
<p>\(J\)是每个分量分别对\(x\)和构成偏导<br />
\(\det|J| &gt;0 \Rightarrow \)未翻转。</p>
<blockquote>
<p>[图23:35]有两个区域 \(D_1, D_2\),<br />
\(\Omega \) 为\(x_0\)的无穷小邻域<br />
\(\Omega\)映射到\(D_2\)后成为\(f(\Omega)\)<br />
A: signed area.
$$
y=\underset{A(\Omega )} {lim}=\frac{A(f(\Omega ))}{A(\Omega )} =J(f)l_{x=x_0}
$$
|y|&gt;1：膨胀<br />
|y|&lt;1:收缩<br />
y&lt;0：翻转</p>
</blockquote>
<p>[31:02] 3D空间则分解为\(\sigma _1,\sigma _2,\sigma _3\)<br />
[32:02图]  有一个矩形，希望把它边界变成红线形，求变形后的形状：<br />
期望：形变较小/夹角小\(\dots\) (看应用需求)</p>
<h2 id="globally-bijective---双射"><a class="header" href="#globally-bijective---双射">Globally Bijective - 双射</a></h2>
<p><img src="Mapping/../assets/%E6%98%A0%E5%B0%8415-1.png" alt="" /></p>
<blockquote>
<p>单射→双射：需要显式地判断是否发生碰撞</p>
</blockquote>
<p><img src="Mapping/../assets/%E6%98%A0%E5%B0%8421.png" alt="" /></p>
<blockquote>
<p>这里的形变，虽然每个面片都没有发生翻转，但整体上发生了碰撞，不满足双射</p>
</blockquote>
<h2 id="扭曲"><a class="header" href="#扭曲">扭曲</a></h2>
<h3 id="jacobian的几何意义"><a class="header" href="#jacobian的几何意义">Jacobian的几何意义</a></h3>
<p>函数在某点的Jacobian度量了其局部的形变量</p>
<p><img src="Mapping/../assets/%E6%98%A0%E5%B0%8429.png" alt="" /></p>
<p>$$
L=U\begin{pmatrix}
\sigma _1  &amp; 0\\
0  &amp;\sigma _2 
\end{pmatrix}V^*
$$</p>
<p>$$
\sigma _2\ge \sigma _1
$$</p>
<p><img src="Mapping/../assets/%E6%98%A0%E5%B0%8430.png" alt="" /></p>
<p>• angle‐preserving (conformal) \(\sigma _1= \sigma _2\)</p>
<p>• area‐preserving (authalic) \(\sigma _1\sigma _2=1\)</p>
<p>• length‐preserving (isometric) \(\sigma _1=\sigma _2=1\)</p>
<h3 id="其它distortion-metric"><a class="header" href="#其它distortion-metric">其它Distortion Metric</a></h3>
<p><img src="Mapping/../assets/%E6%98%A0%E5%B0%8431.png" alt="" /></p>
<h1 id="映射的优化模型"><a class="header" href="#映射的优化模型">映射的优化模型</a></h1>
<h2 id="recap-formulation-of-parameterization"><a class="header" href="#recap-formulation-of-parameterization">Recap: Formulation of Parameterization</a></h2>
<p>$$
\min_{V} E(V)=\sum _{t\in T}(\sigma _1^2+\frac{1}{\sigma _1^2} +\sigma _2^2+\frac{1}{\sigma _2^2}) 
$$</p>
<p>$$
s.t.\sigma _1\sigma _2&gt;0,\forall t
$$</p>
<p>• The cost function is highly <strong>nonlinear</strong> and <strong>nonconvex</strong><br />
• The constraints are <strong>nonlinear</strong><br />
• The Heissian matrix is highly <strong>non‐definite</strong></p>
<blockquote>
<p>Computationally expensive for large scale meshes!</p>
</blockquote>
<h2 id="要解决的问题-3"><a class="header" href="#要解决的问题-3">要解决的问题</a></h2>
<p>输入：<br />
<img src="Mapping/../assets/%E6%98%A0%E5%B0%8432.png" alt="" /><br />
可能的输出：<br />
<img src="Mapping/../assets/%E6%98%A0%E5%B0%8433.png" alt="" /><br />
希望找到形变较少的度量，不同的度量会得到不同的结果</p>
<h2 id="优化的能量"><a class="header" href="#优化的能量">优化的能量</a></h2>
<p>基于不同的度量，生成对应能量函数，进行优化<br />
<img src="Mapping/../assets/%E6%98%A0%E5%B0%8434.png" alt="" /></p>
<p>能量由每个三角形的变形能量相加得到：
<img src="Mapping/../assets/%E6%98%A0%E5%B0%8435.png" alt="" /></p>
<p>$$
E(\phi )=E(A_1,\cdots ,A_m) = \sum _jf(A_j)
$$</p>
<h2 id="map-optimization"><a class="header" href="#map-optimization">Map optimization</a></h2>
<p>同时要考虑三角形能够拼到一起。</p>
<p><img src="Mapping/../assets/%E6%98%A0%E5%B0%8438.png" alt="" /></p>
<h3 id="explicit-continuity"><a class="header" href="#explicit-continuity">Explicit continuity</a></h3>
<p>优化参数: \(A_1,A_2,\cdots ,A_m\)<br />
相邻三角形的\(A\)应满足约束：</p>
<p><img src="Mapping/../assets/%E6%98%A0%E5%B0%8439.png" alt="" /></p>
<p>$$
A_iv_1=A_jv_1
$$</p>
<p>$$
A_iv_2=A_jv_2
$$</p>
<h3 id="implicit-continuity"><a class="header" href="#implicit-continuity">Implicit continuity</a></h3>
<p><img src="Mapping/../assets/%E6%98%A0%E5%B0%8441.png" alt="" /></p>
<p>$$
A_i\overline{\begin{bmatrix}
\nu_1 &amp; \nu_2 &amp;\nu_3
\end{bmatrix}} =\overline{\begin{bmatrix}
u_1 &amp; u_2 &amp;u_3
\end{bmatrix}}
$$</p>
<p>$$
A_i=\overline{\begin{bmatrix}
u_1 &amp; u_2 &amp;u_3
\end{bmatrix}} \overline{\begin{bmatrix}
\nu_1 &amp; \nu_2 &amp;\nu_3
\end{bmatrix}}
$$</p>
<p>$$
A_i=A_i(U)
$$</p>
<blockquote>
<p>变量不是\(A\)，而是\(u\)，\(A\)是由\(u\)决定的</p>
</blockquote>
<p>Optimization variables: \(u_1,u_2,\cdots ,u_n(U)\)</p>
<p>$$
E(\Phi )=\sum _jf(A_j(U))
$$</p>
<blockquote>
<p>这种方法更常用</p>
</blockquote>
<h1 id="几何优化的求解"><a class="header" href="#几何优化的求解">几何优化的求解</a></h1>
<p>优化能量，关键是怎么定义能量</p>
<h2 id="各种能量"><a class="header" href="#各种能量">各种能量</a></h2>
<h3 id="dirichlet能量"><a class="header" href="#dirichlet能量">Dirichlet能量</a></h3>
<p>area / volume   \(\Rightarrow E_D=\sum _jw_j||A_j||_F^2\)</p>
<blockquote>
<p>公式没有几何意义，纯粹是一种度量。<br />
会造成比较大的扭曲，现在很少用了</p>
</blockquote>
<h3 id="orthogonal-and-similarity"><a class="header" href="#orthogonal-and-similarity">Orthogonal and Similarity</a></h3>
<p>• R is <strong>orthogonal</strong> if \(R^T=R^{-1}\)<br />
(rotation if det 𝑅 &gt; 0)</p>
<p><img src="Mapping/../assets/%E6%98%A0%E5%B0%8445.png" alt="" /></p>
<p>• S is a <strong>similarity</strong> if \(S =\alpha R\)</p>
<p><img src="Mapping/../assets/%E6%98%A0%E5%B0%8446.png" alt="" /></p>
<p>• \(\Re(A)=\) closest orthogonal/rotation matrix to \(A\)<br />
• \(\varsigma  (A)\)= closest similarity matrix to  \(A\)</p>
<p>对A做SVD/SSVD分解:</p>
<p>\(A=U\sum V^T\);\(\sum\) =diag\((\sigma _1,\cdots ,\sigma _n)\)</p>
<p><img src="Mapping/../assets/%E6%98%A0%E5%B0%8446-1.png" alt="" /></p>
<h3 id="assimilaraspossible-asap"><a class="header" href="#assimilaraspossible-asap">As‐Similar‐As‐Possible (ASAP)</a></h3>
<p>$$
E_L=\sum _jw_j||A_j-\varsigma (A_j)||_F^2
$$</p>
<p><img src="Mapping/../assets/%E6%98%A0%E5%B0%8447.png" alt="" /></p>
<p>Solving sparse linear system!</p>
<h3 id="asrigidaspossible-arap"><a class="header" href="#asrigidaspossible-arap">As‐Rigid‐As‐Possible (ARAP)</a></h3>
<p>$$
E_R=\sum _jw_j||A_j-\Re (A_j)||_F^2
$$</p>
<p><img src="Mapping/../assets/%E6%98%A0%E5%B0%8448.png" alt="" /></p>
<p><strong>Alternating Optimization</strong></p>
<ul>
<li>Iteratively:<br />
• Compute and fix \( R_j = \Re (A_j) \)    Local step</li>
</ul>
<p>• Minimize</p>
<p>\(\sum _jw_j||A_j-R_j||_F^2\)   Global step</p>
<p>[Liu et al. A Local/Global Approach to Mesh Parameterization. SGP 2008]</p>
<blockquote>
<p>[42:11] locd: 分裂     global:缝合<br />
交替迭代优化方法</p>
</blockquote>
<table><thead><tr><th></th><th></th><th></th><th></th></tr></thead><tbody>
<tr><td><img src="Mapping/../assets/%E6%98%A0%E5%B0%8451.png" alt="" /></td><td><img src="Mapping/../assets/%E6%98%A0%E5%B0%8452.png" alt="" /></td><td><img src="Mapping/../assets/%E6%98%A0%E5%B0%8453.png" alt="" /></td><td><img src="Mapping/../assets/%E6%98%A0%E5%B0%8454.png" alt="" /></td></tr>
<tr><td><img src="Mapping/../assets/%E6%98%A0%E5%B0%8455.png" alt="" /></td><td><img src="Mapping/../assets/%E6%98%A0%E5%B0%8456.png" alt="" /></td><td><img src="Mapping/../assets/%E6%98%A0%E5%B0%8457.png" alt="" /></td><td><img src="Mapping/../assets/%E6%98%A0%E5%B0%8458.png" alt="" /></td></tr>
</tbody></table>
<blockquote>
<p>交替优先的方法非常常用</p>
</blockquote>
<h2 id="各种方法的比较"><a class="header" href="#各种方法的比较">各种方法的比较</a></h2>
<h3 id="arap-vs-asap"><a class="header" href="#arap-vs-asap">ARAP vs. ASAP</a></h3>
<p><img src="Mapping/../assets/%E6%98%A0%E5%B0%8449.png" alt="" /></p>
<h3 id="singular-values-perspective"><a class="header" href="#singular-values-perspective">Singular values perspective</a></h3>
<p><img src="Mapping/../assets/%E6%98%A0%E5%B0%8450.png" alt="" /></p>
<h1 id="summary"><a class="header" href="#summary">Summary</a></h1>
<h2 id="geometric-mapping"><a class="header" href="#geometric-mapping">Geometric Mapping</a></h2>
<p>• Discrete Mapping</p>
<p><img src="Mapping/../assets/%E6%98%A0%E5%B0%8460-1.png" alt="" /></p>
<p>• Discrete formulation</p>
<p>argmin \(E(\phi )\)  Separable<br />
s.t. \(\phi \in K\)</p>
<p>• Nonlinear and nonconvex<br />
• Computationally expensive for large scale meshes!</p>
<h2 id="meshless-mappings"><a class="header" href="#meshless-mappings">Meshless mappings</a></h2>
<p>$$
f(x)=\sum_{i=1}^{m} c_iB_i(x)
$$</p>
<blockquote>
<p>[46:28] \(f\)有些独特的性质。例如在边界上满足一定的性质，就能保证内部一定满足某些性质。<br />
对整个对象做映射，因此是meshless.</p>
</blockquote>
<p><img src="Mapping/../assets/%E6%98%A0%E5%B0%8461.png" alt="" /></p>
<p>• Low distortion<br />
• Flip‐free<br />
• Bijective</p>
<h2 id="其他区域间的映射求解"><a class="header" href="#其他区域间的映射求解">其他区域间的映射求解</a></h2>
<p>• 离散形式<br />
• 约束条件</p>
<p><img src="Mapping/../assets/%E6%98%A0%E5%B0%8462.png" alt="" /></p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。
https://caterpillarstudygroup.github.io/GAMES102_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="回顾-3"><a class="header" href="#回顾-3">回顾</a></h1>
<p>参数化中的优化问题<br />
几何处理中的优化问题</p>
<p><img src="Optimization/../assets/%E4%BC%98%E5%8C%962.png" alt="" /></p>
<h1 id="geometry-problem-and-modeling"><a class="header" href="#geometry-problem-and-modeling">Geometry Problem and Modeling</a></h1>
<ol>
<li>Formulate an objective energy \(E(x)\)</li>
<li>Define constraints, if apply<br />
\(\star \) Equality / Inequality<br />
\(\star \) Linear / Nonlinear</li>
<li>Numerical optimization</li>
</ol>
<p>\begin{array}{cl}
\underset{x \in \mathbb{R}^{n}}{\operatorname{minimize}} &amp; E(x) \\
\text { subject to } &amp; c_{1}(x)=d_{1} \\
&amp; c_{2}(x)&gt;d_{2}
\end{array}</p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。
https://caterpillarstudygroup.github.io/GAMES102_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="优化问题的一般形式"><a class="header" href="#优化问题的一般形式">优化问题的一般形式</a></h1>
<blockquote>
<p>优化问题的目标函数一般是实值函数，因为实数才能比大小<br />
不同的\(g(x) 和 h(x)\)，用不同的方法优化。</p>
</blockquote>
<p>高维实值函数：\(f:\mathbb{R}^n\to \mathbb{R}\)</p>
<table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>\(\min_x\in \mathbb{R} ^nf(x)\)</td><td>目标函数 or 能量函数</td></tr>
<tr><td>S.t.\(g(x)=0\)</td><td>等式约束</td></tr>
<tr><td>\(h(x)\ge 0 \)</td><td>不等式约束</td></tr>
</tbody></table>
<p>不同的优化<strong>问题</strong>须用不同的优化方法<br />
特定的优化问题需要<strong>设计</strong>特定的优化方法达到最佳性能</p>
<h1 id="概念"><a class="header" href="#概念">概念</a></h1>
<h2 id="梯度-gradient一阶导数"><a class="header" href="#梯度-gradient一阶导数">梯度 (Gradient)：一阶导数</a></h2>
<p>$$
f:\mathbb{R}^n\to \mathbb{R}
$$</p>
<p>$$
f=(\frac{\partial f}{\partial x_1} ,\frac{\partial f}{\partial x_2} ,\cdots ,\frac{\partial f}{\partial x_n})
$$</p>
<h2 id="jacobian-一阶导数矩阵"><a class="header" href="#jacobian-一阶导数矩阵">Jacobian: 一阶“导数”矩阵</a></h2>
<p>$$
f:\mathbb{R}^n\to \mathbb{R}^m
$$</p>
<p>$$
(D_f)_{ij}=\frac{\partial f_i}{\partial x_j} 
$$</p>
<p><img src="Optimization/../assets/%E4%BC%98%E5%8C%964.png" alt="" /></p>
<h2 id="hessian-二阶导数矩阵"><a class="header" href="#hessian-二阶导数矩阵">Hessian ：二阶“导数”矩阵</a></h2>
<p>$$
f:\mathbb{R}^n\to \mathbb{R} \to H_{ij}=\frac{\partial^2 f}{\partial x_i\partial x_j} 
$$</p>
<p><img src="Optimization/../assets/%E4%BC%98%E5%8C%965.png" alt="" /></p>
<p>$$
f(x)\approx f(x_0)+\nabla f(x_0)^\top (x-x_0)+(x-x_0)^\top Hf(x_0)(x-x_0)
$$</p>
<blockquote>
<p>[57:31] 每个分量对每个变量求导构成的矩阵<br />
H是函数的二阶项的度量</p>
</blockquote>
<h1 id="驻点critical-point"><a class="header" href="#驻点critical-point">驻点（Critical point）</a></h1>
<p>$$
\nabla f(x)=0
$$</p>
<p><img src="Optimization/../assets/%E4%BC%98%E5%8C%966.png" alt="" /></p>
<p>Critical points may not be minima.</p>
<h2 id="一般非线性函数的最小值"><a class="header" href="#一般非线性函数的最小值">一般非线性函数的最小值</a></h2>
<p>无法直接求解，可以从某初值开始，逐步找其附近的极小值</p>
<p><img src="Optimization/../assets/%E4%BC%98%E5%8C%967.png" alt="" /></p>
<h2 id="凸函数的驻点就是最小值"><a class="header" href="#凸函数的驻点就是最小值">凸函数的驻点就是最小值</a></h2>
<p><img src="Optimization/../assets/%E4%BC%98%E5%8C%968.png" alt="" /></p>
<h1 id="优化问题的类型"><a class="header" href="#优化问题的类型">优化问题的类型</a></h1>
<p>• Constrained / Unconstrained<br />
• Linear / Nonlinear<br />
• Global / Local<br />
• Convex / Nonconvex<br />
• Continuous / Discrete</p>
<blockquote>
<p>[1:03:25] Discrete:只在整数域上找最优解。</p>
</blockquote>
<p>• Stochastic / Deterministic<br />
• Single objective / Multiple objectives</p>
<blockquote>
<p>多目标常常是矛盾的，需要做权衡，找平衡点或通过权重结合成单目标问题。</p>
</blockquote>
<p>minimize \((E_1(x),E_2(x),\cdots ,E_k(x))\)</p>
<p>\(E=\lambda _1E_1+\lambda _2E_2+\cdots +\lambda _kE_k\)</p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。
https://caterpillarstudygroup.github.io/GAMES102_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="无约束的优化问题"><a class="header" href="#无约束的优化问题">无约束的优化问题</a></h1>
<h2 id="梯度下降法-gradient-descent"><a class="header" href="#梯度下降法-gradient-descent">梯度下降法 Gradient descent</a></h2>
<p><img src="Optimization/../assets/%E4%BC%98%E5%8C%9610.png" alt="" /></p>
<p>$$
x_{k+1}=x_k-\alpha _k\nabla f(x_k)
$$</p>
<h2 id="牛顿法-newtons-method"><a class="header" href="#牛顿法-newtons-method">牛顿法 (Newton’s method)</a></h2>
<p><img src="Optimization/../assets/%E4%BC%98%E5%8C%9611.png" alt="" /></p>
<h2 id="拟牛顿法-quasinewton"><a class="header" href="#拟牛顿法-quasinewton">拟牛顿法 (Quasi‐Newton)</a></h2>
<p><img src="Optimization/../assets/%E4%BC%98%E5%8C%9612.png" alt="" /></p>
<p>用一下近似但更容易计算的H来代替真实的H：BFGS、L‐BFGS</p>
<h2 id="坐标下降法-coordinate-descent"><a class="header" href="#坐标下降法-coordinate-descent">坐标下降法 (Coordinate descent)</a></h2>
<p>目标: minimize\(_{x,y},𝐸(𝑥, 𝑦)\)</p>
<p>Repeat Alternating variables</p>
<ol>
<li>\( y_{k+1}=\min_yE(x_k,y)\)</li>
<li>\(x_{k+1}=\min_xE(x,y_{k+1})\)</li>
</ol>
<blockquote>
<p>[1:09:31] 沿坐标轴下降，且每次只选一个坐标轴。</p>
</blockquote>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。
https://caterpillarstudygroup.github.io/GAMES102_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="等式约束的优化问题"><a class="header" href="#等式约束的优化问题">等式约束的优化问题</a></h1>
<table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td><img src="Optimization/../assets/%E4%BC%98%E5%8C%9613.png" alt="" /></td><td><img src="Optimization/../assets/%E4%BC%98%E5%8C%9614.png" alt="" /></td></tr>
</tbody></table>
<p>\(g(x)\)是红线，\(f(x)\)由等值线构成的曲面。满足约束的极小值点具有以下特点：</p>
<p><img src="Optimization/../assets/%E4%BC%98%E5%8C%9615.png" alt="" /></p>
<p>\(f(x)\)与\(g(x)\)在该点上梯度方向重合，可能同向或反向。</p>
<p>[1:13:26]等值约束的优化问题转化为解方程组问题</p>
<p>$$
\begin{array}{l}<br />
\nabla  \mathbf{f}(x) =\lambda \nabla g(x)  \\<br />
\mathbf{g}(x) = 0 \<br />
\end{array} 
$$</p>
<h2 id="many-options"><a class="header" href="#many-options">Many Options</a></h2>
<p>• <strong>Reparameterization</strong><br />
Eliminate constraints to reduce to unconstrained case</p>
<p>• <strong>Newton’s method</strong><br />
Approximation: quadratic function with linear constraint</p>
<p>• <strong>Penalty method</strong><br />
Augment objective with barrier term, e.g. \(f(x)+\rho |g(x)|\)</p>
<h2 id="alternating-projection"><a class="header" href="#alternating-projection">Alternating Projection</a></h2>
<p><img src="Optimization/../assets/%E4%BC%98%E5%8C%9616.png" alt="" /></p>
<blockquote>
<p>[1:14:18] \(C_1,C_2,C_3\)的代表不同的等式约束。相当于坐标法推广</p>
</blockquote>
<h2 id="augmented-lagrangians"><a class="header" href="#augmented-lagrangians">Augmented Lagrangians</a></h2>
<p><img src="Optimization/../assets/%E4%BC%98%E5%8C%9617.png" alt="" /></p>
<blockquote>
<p>[1:15:18] 把 Constrain 作为目标函数，极小划
权\(\rho \)在优化过程中会改变</p>
</blockquote>
<h2 id="alternating-direction-method-of-multipliers-admm"><a class="header" href="#alternating-direction-method-of-multipliers-admm">Alternating Direction Method of Multipliers (ADMM)</a></h2>
<blockquote>
<p>[1:15:50] ADMM.把变量分离。把问题分成若干小问题分解为：小规模局部优化问题、闭式解全局优化问题。</p>
</blockquote>
<p>$$
\begin{array}{l}<br />
\min_{x,z}&amp; f(x)+g(z)     \\<br />
s.t. &amp;Ax+Bz=c   \\<br />
\end{array} 
$$</p>
<p>$$
\wedge _\rho (x,z;\lambda )=f(x)+g(z)+\lambda ^\top (Ax+Bz-c)+\frac{\rho }{2}||Ax+Bz-c||_2^2 
$$</p>
<p><a href="https://web.stanford.edu/%7Eboyd/papers/pdf/admm_slides.pdf">https://web.stanford.edu/~boyd/papers/pdf/admm_slides.pdf</a></p>
<p><strong>The Art of ADMM “Splitting”</strong></p>
<p><img src="Optimization/../assets/%E4%BC%98%E5%8C%9618.png" alt="" /></p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。
https://caterpillarstudygroup.github.io/GAMES102_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="不等式约束的优化问题"><a class="header" href="#不等式约束的优化问题">不等式约束的优化问题</a></h1>
<h2 id="一般形式-1"><a class="header" href="#一般形式-1">一般形式</a></h2>
<p><img src="Optimization/../assets/%E4%BC%98%E5%8C%9619.png" alt="" /></p>
<h2 id="约束部分"><a class="header" href="#约束部分">约束部分</a></h2>
<p><img src="Optimization/../assets/%E4%BC%98%E5%8C%9621.png" alt="" /> </p>
<blockquote>
<p>[1:20:17] 把流形空间分成了两部分，绿色空间为可行域 feasible domain</p>
</blockquote>
<h2 id="优化部分"><a class="header" href="#优化部分">优化部分</a></h2>
<p><img src="Optimization/../assets/%E4%BC%98%E5%8C%9623.png" alt="" /> </p>
<h2 id="解优化方法"><a class="header" href="#解优化方法">解优化方法</a></h2>
<ol>
<li>把问题转化为Langrangian形式:</li>
</ol>
<p>$$
L(x,\lambda )=f(x)+\sum_{i=1}^{m} \lambda _ig_i(x)
$$</p>
<ol start="2">
<li>f(x)的约束为Karush‐Kuhn‐Tucker (KKT)</li>
</ol>
<ul>
<li>
<p>Stationarity: \(\nabla f(x^\ast )+\sum_{i=1}^{m} \lambda _i\nabla g_i(x^\ast )=0\)</p>
</li>
<li>
<p>Primal feasibility:   \(g_i(x^*)\le 0\)</p>
</li>
<li>
<p>Dual feasibility:  \(\lambda _i\ge 0\)</p>
</li>
<li>
<p>Complementary slackness:   \(\lambda _ig_i(x^*)= 0 \)</p>
</li>
</ul>
<ol start="3">
<li>具体求解过程，没有展开</li>
</ol>
<p><img src="Optimization/../assets/%E4%BC%98%E5%8C%9627.png" alt="" /></p>
<blockquote>
<p>[1:23:29]  Active set,积极集。<br />
Interior Point.内点法。</p>
</blockquote>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。
https://caterpillarstudygroup.github.io/GAMES102_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="凸函数"><a class="header" href="#凸函数">凸函数</a></h1>
<p>凸函数能保证找到全局最小值</p>
<p>[1:2:04]凸函数有很好的性质。因此都希望把问题转化为凸问题。</p>
<p><img src="Optimization/../assets/%E4%BC%98%E5%8C%9628.png" alt="" /></p>
<p>f convex if:</p>
<p>$$
f((1-t)a+tb\le (1-t)f(a)+tf(b), \qquad t\in [0,1]
$$</p>
<p>凸集：任何两点的连线都在集合内<br />
凸集最小点有非常好的性质</p>
<h1 id="凸优化问题"><a class="header" href="#凸优化问题">凸优化问题</a></h1>
<p>凸优化问题：优化函数\(f(x)\) and all 约束条件\(g_i(x)\) are convex functions</p>
<p>凸优化的主要类型</p>
<p><img src="Optimization/../assets/%E4%BC%98%E5%8C%9632.png" alt="" /></p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。
https://caterpillarstudygroup.github.io/GAMES102_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="其他优化问题"><a class="header" href="#其他优化问题">其他优化问题</a></h1>
<h2 id="nonlinear-least-squares"><a class="header" href="#nonlinear-least-squares">Nonlinear Least Squares</a></h2>
<p>目标函数:</p>
<p>$$
\sum _ie_i^2(x)
$$</p>
<p>解法：</p>
<ul>
<li>
<p>Gauss‐Newton</p>
</li>
<li>
<p>Levenberg‐Marquardt</p>
</li>
</ul>
<p>$$
\begin{array}{l} 
\nabla  ^2e_i^2\approx 2(\nabla  e_i)^T\nabla  e_i \\
\nabla^2\approx J^TJ \ 
\end{array} 
$$</p>
<h2 id="mixedinteger-optimization"><a class="header" href="#mixedinteger-optimization">Mixed‐Integer Optimization</a></h2>
<p><img src="Optimization/../assets/%E4%BC%98%E5%8C%9633.png" alt="" /></p>
<p>[1:26:57] 整型规划：部分变量只能取整数,先松驰成连续，再用稀疏方法限制在整数上。</p>
<h1 id="几何处理中的优化问题"><a class="header" href="#几何处理中的优化问题">几何处理中的优化问题</a></h1>
<ul>
<li>具有<strong>特殊的几何结构</strong>，往往能有特殊的优化方法</li>
</ul>
<blockquote>
<p>往往是多个优化目标的结合。</p>
</blockquote>
<p>$$
\mathbf{argmin} \sum _jf(A_j) 
$$</p>
<p>例如：<br />
<img src="Optimization/../assets/%E4%BC%98%E5%8C%9634.png" alt="" /></p>
<h1 id="优化相关的软件"><a class="header" href="#优化相关的软件">优化相关的软件</a></h1>
<p>• <strong>Eigen</strong> — linear algebra<br />
• <strong>IPOPT</strong> — fast opensource C++ interior point method<br />
• <strong>Mosek</strong> — commercial (convex) optimization in C, Java, Python…<br />
• <strong>Gurobi</strong> — commercial mixed‐integer optimization<br />
• <strong>CPLEX</strong> — commercial mixed‐integer optimization<br />
• <strong>Matlab</strong> — many algorithms, good for prototyping<br />
• <strong>CVX</strong> — prototyping for convex optimization<br />
• <strong>CoMISo</strong> — unified interface to above algorithms</p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。
https://caterpillarstudygroup.github.io/GAMES102_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="曲面重建-reconstruction"><a class="header" href="#曲面重建-reconstruction">曲面重建 (Reconstruction)</a></h1>
<p>存在的物体：对其采集并进行数字化构建<br />
也称为：逆向工程、扫描重、Reverse engineering, scanning</p>
<p>Outline：</p>
<p><img src="Reconstruct/../assets/22-1.png" alt="" /></p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。
https://caterpillarstudygroup.github.io/GAMES102_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="1-acquisition-数据采集"><a class="header" href="#1-acquisition-数据采集">1. Acquisition （数据采集）</a></h1>
<p><img src="Reconstruct/../assets/22-2.png" alt="" /></p>
<p>Structure of Data:</p>
<p><img src="Reconstruct/../assets/22-3.png" alt="" /></p>
<h2 id="11-volume-scanning"><a class="header" href="#11-volume-scanning">1.1 Volume Scanning</a></h2>
<ul>
<li>Input: a sequence of slice images</li>
<li>Output: 3D models of human organs </li>
</ul>
<p><img src="Reconstruct/../assets/22-4.png" alt="" /></p>
<blockquote>
<p>采集横截面序列，得到物体的空间信息对于医学图像、分割非常重要。</p>
</blockquote>
<ul>
<li>Reconstruction from 2D contours</li>
</ul>
<p><img src="Reconstruct/../assets/22-5.png" alt="" /></p>
<blockquote>
<p>Note:contour topology can change</p>
</blockquote>
<h2 id="12-shape-from-shading-sfs"><a class="header" href="#12-shape-from-shading-sfs">1.2 Shape from shading (SFS)</a></h2>
<ul>
<li>Input: a single image</li>
<li>Output: a 3D model (with albedo, normal, etc.)</li>
</ul>
<h3 id="基本方法"><a class="header" href="#基本方法">基本方法</a></h3>
<p>原理：根据 shading 估计出物体的信息相当于渲染的逆过程。[Horn 1980]</p>
<p><img src="Reconstruct/../assets/22-6.png" alt="" /></p>
<blockquote>
<p>[16:40] 不考虑全局光照，只考虑局部光照，即Phong模型</p>
</blockquote>
<p><img src="Reconstruct/../assets/22-7.png" alt="" /></p>
<h3 id="进阶方法"><a class="header" href="#进阶方法">进阶方法</a></h3>
<blockquote>
<p>[17:46] 如果输入多照图片，信息量更大，不仅能重建几何，还能重建材质、Normal。</p>
</blockquote>
<p><img src="Reconstruct/../assets/22-8.png" alt="" /></p>
<p>Jiang et al. 3D Face Reconstruction with Geometry Details from a Single Image. IEEE Transactions on Image Processing, 2018.<br />
Xu et al. Shading-based Surface Detail Recovery under General Unknown Illumination. IEEE Transactions on Pattern Analysis and Machine Intelligence, 2018.</p>
<p>Wu et al. Unsupervised learning of probably symmetric deformable 3D objects fro images in the wild. CVPR 2020. (Best paper award)</p>
<h2 id="shape-from-a-single-image--learning-based-method"><a class="header" href="#shape-from-a-single-image--learning-based-method">Shape from a single image – Learning based method</a></h2>
<blockquote>
<p>以图像中提取出置信度、深度、纹理，然后重建出原图、单张图像建3D模型，结果不唯一，需要先验知识，或者用多视角。</p>
</blockquote>
<p><img src="Reconstruct/../assets/22-9-1.png" alt="" /></p>
<p>Two confidence-adjusted reconstruction losses are minimized at the same time with asymmetric weights.</p>
<p>Wu et al. Unsupervised learning of probably symmetric deformable 3D objects fro images in the wild. CVPR 2020. (Best paper award)</p>
<h2 id="13-image-based-modeling-ibm"><a class="header" href="#13-image-based-modeling-ibm">1.3 Image based modeling (IBM)</a></h2>
<ul>
<li>Input: multiple photos from different views</li>
<li>Output: 3D models</li>
</ul>
<p><img src="Reconstruct/../assets/22-10.png" alt="" /></p>
<p><strong>原理</strong>：</p>
<p>两个相机有视角差。模型同一个点在两个相机中出现在不同的位置。<br />
用(\(R\)旋转、\( t \)位置)来描述一个相机的状态<br />
找出两个相机的对应关系</p>
<p><img src="Reconstruct/../assets/22-11.png" alt="" /></p>
<blockquote>
<p>[23：43] 已知\(x\)点在三个相机呈像中的坐标<br />
\((R、t)是相机外参， K\)(焦距)是相机内参<br />
[25:02表] 公式中\(K和R\)是未知的，所有\(x\)已知的，根据关系列出等式，得到过约束系统，通过LS，求出内参和外参。<br />
问题：怎么找到对应点？ SIFT<br />
[27:46] 多视角动捕存在同步问题</p>
</blockquote>
<h2 id="14-structured-light-结构光白光"><a class="header" href="#14-structured-light-结构光白光">1.4 Structured light （结构光/白光）</a></h2>
<blockquote>
<p>学术界上称为结构光，工业界称为白光。</p>
</blockquote>
<p><img src="Reconstruct/../assets/22-12.png" alt="" /></p>
<blockquote>
<p>[30:05] 只有一个相机，光源向对象打条纹光，找对应关系。</p>
</blockquote>
<h2 id="15-sfm--slam"><a class="header" href="#15-sfm--slam">1.5 SfM &amp; SLAM</a></h2>
<ul>
<li>SfM: Structure from Motion</li>
<li>SLAM: Simultaneous Localization and Mapping</li>
</ul>
<table><thead><tr><th>SfM</th><th>SLAM</th></tr></thead><tbody>
<tr><td>Vision</td><td>Robotics</td></tr>
<tr><td>Structure</td><td>Mapping</td></tr>
<tr><td>Camera poses</td><td>Location</td></tr>
<tr><td>3D reconstruction</td><td>Localization</td></tr>
<tr><td>Feature tracking</td><td>Prediction</td></tr>
</tbody></table>
<blockquote>
<p>输入RGB图像、内置IMU计录位置，得到点的对应关系。<br />
被动式：被动获得3D坐标<br />
常用于机器人领域。</p>
</blockquote>
<p><strong>SLAM的主要流程</strong></p>
<p><img src="Reconstruct/../assets/22-14.png" alt="" /></p>
<h2 id="16-laser-radar-激光雷达测距"><a class="header" href="#16-laser-radar-激光雷达测距">1.6 Laser Radar （激光雷达测距）</a></h2>
<p>LiDAR = Light Detection And Ranging, </p>
<p>原理：<strong>主动</strong>向目标发射探测信号（激光束）,然 后将接收到的从目标反射回来的信号（目标回波）与发射信号进行比较（三角测距）</p>
<p><img src="Reconstruct/../assets/22-15.png" alt="" /></p>
<h2 id="17-depth-images"><a class="header" href="#17-depth-images">1.7 Depth Images</a></h2>
<ul>
<li>Microsoft Kinect</li>
<li>Apple Primesense</li>
<li>Intel RealSense</li>
<li>Google Project Tango</li>
<li>Asus Xtion</li>
<li>iPhone XI/XII</li>
</ul>
<h3 id="depth-data-grid-points"><a class="header" href="#depth-data-grid-points">Depth Data: Grid Points</a></h3>
<p>2.5D image：</p>
<p><img src="Reconstruct/../assets/22-16.png" alt="" /></p>
<h3 id="深度相机原理"><a class="header" href="#深度相机原理">深度相机原理</a></h3>
<p><strong>TOF</strong> = Time of flight</p>
<p><img src="Reconstruct/../assets/22-17.png" alt="" /></p>
<blockquote>
<p>通过发射一个点计算回来的时间估计深度。<br />
只能采集小的对象</p>
</blockquote>
<p><strong>Kinect</strong></p>
<p>当激光穿透毛玻璃后形成随机衍射斑点，这些散斑（laser speckle）具有高度的随机性，而且会随着距离的不同变换图案（pattern）。空间中任意两处散斑图案都不同<br />
Light coding打出了一个具有三维纵深的“体编码”，只要看物体表面的散斑图案，就可以知道这个物体在什么位置</p>
<p><img src="Reconstruct/../assets/22-18.png" alt="" /></p>
<blockquote>
<p>Kinect Fusion [40:00]：使用CPU:通过隐函数来做实时重建</p>
</blockquote>
<h2 id="18-shape-from-silhouettecontours"><a class="header" href="#18-shape-from-silhouettecontours">1.8 Shape from Silhouette/Contours</a></h2>
<p><img src="Reconstruct/../assets/22-19.png" alt="" /></p>
<blockquote>
<p>[41:00] 扫略体形成的交集就是物体本身<br />
适用于轮廓清晰的物体</p>
</blockquote>
<blockquote>
<p>后面的机械方法都跳过</p>
</blockquote>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。
https://caterpillarstudygroup.github.io/GAMES102_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="2-registration"><a class="header" href="#2-registration">2. Registration</a></h1>
<p><img src="Reconstruct/../assets/22-20.png" alt="" /></p>
<p>要解决的问题：Reconstruction from scans</p>
<p><img src="Reconstruct/../assets/22-21.png" alt="" /></p>
<p>多个视点的扫描，每个视点得到分片3D数据，<strong>如何将这些分片数据合并成一个整体数据</strong>？</p>
<blockquote>
<p>各个角度采集到的特体是碎片的，怎么拼起来？<br />
Planing 怎么扫不同角度得到完整数据</p>
</blockquote>
<h2 id="pairwise-registration"><a class="header" href="#pairwise-registration">Pairwise Registration</a></h2>
<p>目标：<br />
Align a source model \(\chi\) onto　a target model \(y\)，find a transformation  T \(\chi\) that brings \(\chi\) into alignment with \(y\)<br />
挑战：</p>
<ul>
<li>How do we measure the quality of the alignment?</li>
<li>What transformations are acceptable?</li>
</ul>
<p><img src="Reconstruct/../assets/22-22.png" alt="" /></p>
<p><strong>基本方法</strong>：Registration as energy minimization-</p>
<p><img src="Reconstruct/../assets/22-23.png" alt="" /></p>
<blockquote>
<p>energy包含两部分：Alignment Error和Transformation Error，分别对应解决上面的两个挑战。<br />
[46:21] Ematchi ：匹配误差， Eprior:先验知识</p>
</blockquote>
<h3 id="alignment-error"><a class="header" href="#alignment-error">Alignment Error</a></h3>
<p><img src="Reconstruct/../assets/22-24.png" alt="" /></p>
<p><img src="Reconstruct/../assets/22-25-1.png" alt="" /></p>
<h3 id="prior-error--1-rigid-objects"><a class="header" href="#prior-error--1-rigid-objects">Prior Error – 1 (Rigid objects)</a></h3>
<p><img src="Reconstruct/../assets/22-26.png" alt="" /></p>
<p>$$
E_{prior}(\mathbf{Z,R,t})=\sum_{i=1}^{n} ||\mathbf{Z}_i-(\mathbf{RX}_i+\mathbf{t})||^2_2
$$</p>
<h3 id="prior-error--2-elastic-objects"><a class="header" href="#prior-error--2-elastic-objects">Prior Error – 2 (Elastic objects)</a></h3>
<blockquote>
<p>弹性物体，存在少量变形</p>
</blockquote>
<p><img src="Reconstruct/../assets/22-27.png" alt="" /></p>
<p>$$
E_{prior}(\mathbf{Z},(R_i))=\sum_{i=1}^{n} \sum_{j\in \mathcal{N}_{i}}||(\mathbf{Z}_j-\mathbf{Z}_i)-R_i(\mathbf{X}_j-\mathbf{X}_i)||^2_2
$$</p>
<h3 id="prior-error--3-articulated-objects"><a class="header" href="#prior-error--3-articulated-objects">Prior Error – 3 (Articulated objects)</a></h3>
<blockquote>
<p>分段刚性</p>
</blockquote>
<p><img src="Reconstruct/../assets/22-28.png" alt="" /></p>
<h2 id="iterative-closest-point-icp-algorithm"><a class="header" href="#iterative-closest-point-icp-algorithm">Iterative Closest Point (ICP) Algorithm</a></h2>
<p>[Besl+92]</p>
<p><img src="Reconstruct/../assets/22-29.png" alt="" /></p>
<blockquote>
<p>根据对应点求变换关系(R.t)<br />
根据变换关系就对应点</p>
</blockquote>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。
https://caterpillarstudygroup.github.io/GAMES102_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="3-consolidation"><a class="header" href="#3-consolidation">3. Consolidation</a></h1>
<p><img src="Reconstruct/../assets/22-30.png" alt="" /></p>
<blockquote>
<p>校准之后的结果还有些问题。在配准之前对物体做前处理</p>
</blockquote>
<p><img src="Reconstruct/../assets/22-31-1.png" alt="" /></p>
<p><strong>Imperfect Acquisition</strong>:</p>
<ul>
<li>Outliers --&gt; Outlier‐free</li>
<li>Noisy data --&gt; Clean</li>
<li>Orientation --&gt; Oriented</li>
<li>Large missing parts</li>
<li>Non‐uniform sampling --&gt; Uniform</li>
<li>Blurred features --&gt; Thin</li>
<li>…</li>
</ul>
<p><img src="Reconstruct/../assets/22-32.png" alt="" /></p>
<blockquote>
<p>[52:03图] Thick cloud.不是流形，怎么去掉多余点<br />
左下图，点为靠近，拓扑关系会出错。</p>
</blockquote>
<h2 id="orientation----oriented"><a class="header" href="#orientation----oriented">Orientation --&gt; Oriented</a></h2>
<p><img src="Reconstruct/../assets/22-33.png" alt="" /></p>
<blockquote>
<p>从某个非常置信的 normal 开始传播，夹角&lt;90，<br />
[37:24图] 难以处理尖锐特征 </p>
</blockquote>
<p>Zhang et al. Multi‐Normal Estimation via Pair Consistency Voting. IEEE TVCG, 2019.<br />
Liu et al. Quality Point Cloud Normal Estimation by Guided Least Squares Representation. SMI 2015.<br />
Huang et al. Consolidation of Unorganized Point Clouds for Surface Reconstruction. Siggraph Asia 2009.</p>
<p><img src="Reconstruct/../assets/22-34.png" alt="" /></p>
<blockquote>
<p>[55:30]为了保证特征点，在非特征处，法线正常传播。在特征处，特殊处理</p>
</blockquote>
<p>Huang et al. Consolidation of Unorganized Point Clouds- for Surface Reconstruction. Siggraph Asia 2009.</p>
<h2 id="nonuniform-sampling----uniform"><a class="header" href="#nonuniform-sampling----uniform">Non‐uniform sampling --&gt; Uniform</a></h2>
<blockquote>
<p>Sample 不均匀会导致很多重建算失效</p>
</blockquote>
<h3 id="方法一-3"><a class="header" href="#方法一-3">方法一</a></h3>
<p><img src="Reconstruct/../assets/22-35.png" alt="" /></p>
<p>Huang et al. Consolidation of- Unorganized Point Clouds for Surface Reconstruction. Siggraph Asia 2009.</p>
<h3 id="方法二-edgeaware-resampling-2d"><a class="header" href="#方法二-edgeaware-resampling-2d">方法二： Edge‐Aware Resampling (2D)</a></h3>
<p><img src="Reconstruct/../assets/22-36.png" alt="" /></p>
<p>Huang et al. Edge‐Aware Point Set Resampling. ACM TOG 2013.</p>
<h3 id="edgeaware-resampling-3d"><a class="header" href="#edgeaware-resampling-3d">Edge‐Aware Resampling (3D)</a></h3>
<p><img src="Reconstruct/../assets/22-37.png" alt="" /></p>
<p>Huang et al. Edge‐Aware Point Set Resampling. ACM TOG 2013.</p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。
https://caterpillarstudygroup.github.io/GAMES102_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="4-reconstruction"><a class="header" href="#4-reconstruction">4. Reconstruction</a></h1>
<p><img src="Reconstruct/../assets/22-38.png" alt="" /></p>
<h2 id="surface-reconstruction"><a class="header" href="#surface-reconstruction">Surface Reconstruction</a></h2>
<blockquote>
<p>把3D点重建成连续的或非连续的曲面</p>
</blockquote>
<ul>
<li>Input: A set of points in 3D that sampled from a model surface</li>
<li>Output: A 2D manifold mesh surface that closely approximates the surface of the original model</li>
</ul>
<p><img src="Reconstruct/../assets/22-39.png" alt="" /></p>
<h3 id="难点desirable-properties"><a class="header" href="#难点desirable-properties">难点：Desirable Properties</a></h3>
<ul>
<li>No restriction on topological type</li>
</ul>
<p><img src="Reconstruct/../assets/22-40.png" alt="" /></p>
<ul>
<li>Representation of range uncertainty</li>
<li>Utilization of all range data</li>
<li>Incremental and order independent updating</li>
<li>Time and space efficiency</li>
<li>Robustness</li>
<li>Ability to fill holes in the reconstruction</li>
</ul>
<h3 id="solutions"><a class="header" href="#solutions">Solutions</a></h3>
<ul>
<li>Approximation methods: Constructing continuous functions (Scattered data interpolation schemes)
<ul>
<li>NURBS surfaces</li>
<li>Signed distances [Hoppe et al. 1992]</li>
<li>Radial basis function reconstruction [Carr et al. 2001] </li>
<li>Poisson reconstruction [Kazhdan et al. 2006] </li>
</ul>
</li>
<li>Discrete methods: Constructing triangle meshes directly 
<ul>
<li>[Amenta &amp; Bern 1998]</li>
<li>Power‐crust [Amenda et al. 2001]</li>
<li>Cocone [Dey &amp; Giesen 2001]</li>
<li>[Cazals &amp; Giesen 2006] </li>
<li>…</li>
</ul>
</li>
</ul>
<h1 id="approximation-methods"><a class="header" href="#approximation-methods">Approximation methods</a></h1>
<h2 id="nurbs-surfaces"><a class="header" href="#nurbs-surfaces">NURBS surfaces</a></h2>
<p>[59:30] NURBS 逼近法:用一个函数逼近点云</p>
<h2 id="implicit-approximation-methods-similar-to-games-1029"><a class="header" href="#implicit-approximation-methods-similar-to-games-1029">Implicit Approximation Methods (similar to GAMES 102‐9)</a></h2>
<h3 id="第一步-convert-point-cloud-into-a-signed-distance-field"><a class="header" href="#第一步-convert-point-cloud-into-a-signed-distance-field">第一步： Convert point cloud into a signed distance field</a></h3>
<p>For every point, add two <em>off‐surface</em> points, one inside and one outside the surface in the direction of the normal<br />
Add a point only if it is closest to its source<br />
N≈3n points</p>
<blockquote>
<p>[1:01:26] \(n\)个点产生了\(3n\)个点，分别是(-1,0，1)</p>
</blockquote>
<p><img src="Reconstruct/../assets/22-41-1.png" alt="" /></p>
<h3 id="第二步construct-an-implicit-function-whose-isosurface-with-isovalue-0-to-approximate-the-field"><a class="header" href="#第二步construct-an-implicit-function-whose-isosurface-with-isovalue-0-to-approximate-the-field">第二步：Construct an implicit function whose iso‐surface with iso‐value 0 to approximate the field</a></h3>
<p>构造高维（4D）曲面，使得函数的0整面经过这些点</p>
<h3 id="第三步-extract-the-mesh-surfaces-from-the-implicit-function"><a class="header" href="#第三步-extract-the-mesh-surfaces-from-the-implicit-function">第三步： Extract the mesh surfaces from the implicit function</a></h3>
<p>Marching cube methods</p>
<h3 id="complexity"><a class="header" href="#complexity">Complexity</a></h3>
<ul>
<li>Storage O(\(N^2\))</li>
<li>Solving the \(W_i O(N^3)\)</li>
<li>Evaluating f(x) O(N)</li>
</ul>
<p>Carr et al. Reconstruction and representation of 3D objects with Radial Basis Functions, SIGGRAPH 2001.</p>
<h2 id="2-mpu-implicits"><a class="header" href="#2-mpu-implicits">(2) MPU Implicits</a></h2>
<blockquote>
<p>根据距离场自适应地剖分，一种自适应版本的Marching Cube</p>
</blockquote>
<p>MPU = Multi‐level partition of unity implicits:</p>
<ul>
<li>Given: data points with normal</li>
<li>Computes: hierarchical approximation of the signed distance function</li>
</ul>
<p><img src="Reconstruct/../assets/22-42.png" alt="" /></p>
<p>Ohtake et al. Multi‐level Partition of Unity Implicits, SIGGRAPH 2003</p>
<h2 id="3-possion-reconstruction"><a class="header" href="#3-possion-reconstruction">(3) Possion reconstruction</a></h2>
<p>Idea: fitting an indicator function</p>
<p>$$
\chi M(x)=\begin{cases}
1 &amp; \text{  } x\in M \\
0 &amp; \text{ } x\notin M
\end{cases}
$$</p>
<p><img src="Reconstruct/../assets/22-43.png" alt="" /></p>
<p>Kazhdan et al. Poisson surface reconstruction. SGP 2006.</p>
<blockquote>
<p>隐函数方法对法向非常敏感<br />
不仅逼近函数，还逼近梯度本身<br />
把重建问题变成方程求解隐函数的问题<br />
[1:08:39]隐函数求解后要找到上面的点，用 Marching Cube</p>
</blockquote>
<h2 id="4-marching-cube"><a class="header" href="#4-marching-cube">(4) Marching Cube</a></h2>
<p>method for approximating surface defined by isovalue  \(\alpha\), given by grid data</p>
<ul>
<li>Input:
<ul>
<li>Grid data (set of 2D images)</li>
<li>Threshold value (isovalue)  \(\alpha\)</li>
</ul>
</li>
<li>Output:
<ul>
<li>Triangulated surface that matches isovalue surface of  \(\alpha\)</li>
</ul>
</li>
</ul>
<p>具体步骤：</p>
<ul>
<li>First pass
<ul>
<li>Identify voxels which intersect isovalue</li>
</ul>
</li>
<li>Second pass
<ul>
<li>Examine those voxels，For each voxel produce set of triangles，approximate surface inside voxel</li>
</ul>
</li>
</ul>
<p><img src="Reconstruct/../assets/22-44.png" alt="" /></p>
<h1 id="discrete-methods"><a class="header" href="#discrete-methods">Discrete methods</a></h1>
<h2 id="curve-from-points"><a class="header" href="#curve-from-points">Curve from Points</a></h2>
<h3 id="第一步connect-the-dots"><a class="header" href="#第一步connect-the-dots">第一步：Connect the Dots</a></h3>
<p><img src="Reconstruct/../assets/22-45.png" alt="" /></p>
<p>Can be ambiguous</p>
<ul>
<li>Use Voronoi Diagram</li>
<li>Construct Delaunay triangulation</li>
</ul>
<p><img src="Reconstruct/../assets/22-46.png" alt="" /></p>
<h3 id="第二步基于字典学习的曲面重建"><a class="header" href="#第二步基于字典学习的曲面重建">第二步：基于字典学习的曲面重建</a></h3>
<p>Xiong et al. Robust Surface Reconstruction via Dictionary Learning. Siggraph Asia 2014.</p>
<p><img src="Reconstruct/../assets/22-47.png" alt="" /></p>
<ul>
<li>输入：三维点集（蓝色点）P</li>
<li>输出
<ul>
<li>采样点集（红色点）V</li>
<li>V构成的三角网格M，使得M逼近P</li>
</ul>
</li>
</ul>
<p><strong>问题</strong></p>
<ul>
<li><strong>误差度量</strong>：如何度量点集P与网格M之间的误差？<br />
答：<strong>某个点到三角形的距离</strong></li>
</ul>
<blockquote>
<p>难点:红点的位置和连接关系未知<br />
度量:蓝点到三角形面片的距离最小<br />
用交替法求解V和B,稀疏优化中的字典学习问题</p>
</blockquote>
<p>$$
d(\mathbf{p}_i,f) =|| \mathbf{p}_i-\mathbf{p}_i^{\prime} || 
$$</p>
<p>$$
\begin{aligned}
=\min _{\substack{\alpha+\beta+\gamma=1 \\
\alpha, \beta, \gamma \geq 0}}||\mathbf{p}_i-(\alpha \mathbf{v}_r+\beta \mathbf{v}_s+\gamma \mathbf{v}_t)||
\end{aligned}
$$</p>
<blockquote>
</blockquote>
<p>\({P}' _i=\alpha ^{\ast}V_r+\beta ^{\ast}V_s+\gamma ^{\ast}V_t\)</p>
<p>\((\alpha ^{\ast},\beta ^{\ast},\gamma ^{\ast})\):\({P}' _i\)相对与\(f\)的重心坐标</p>
<blockquote>
</blockquote>
<p><img src="Reconstruct/../assets/22-48-1.png" alt="" /></p>
<p><strong>某个点到三角形的距离</strong></p>
<p>$$
d(\mathbf{p}_i,f) =|| \mathbf{p}_i-\mathbf{p}_i^{\prime} || 
$$</p>
<p>$$
\begin{aligned}
=\min _{\substack{\alpha+\beta+\gamma=1 \\
\alpha, \beta, \gamma \geq 0}}||\mathbf{p}_i-(\alpha \mathbf{v}_r+\beta \mathbf{v}_s+\gamma \mathbf{v}_t)||
\end{aligned}
$$</p>
<blockquote>
</blockquote>
<p>\(\mathbf{Ｖ}=[\mathbf{Ｖ}_1,\mathbf{Ｖ}_2,\cdots ,\mathbf{Ｖ}_m] \in  \mathbb{R }^{3\times m}\)</p>
<p>Vertex matrix of <strong>M</strong></p>
<blockquote>
</blockquote>
<p><img src="Reconstruct/../assets/22-49-1.png" alt="" /></p>
<p><img src="Reconstruct/../assets/22-50.png" alt="" /></p>
<h3 id="特点-1"><a class="header" href="#特点-1">特点</a></h3>
<ul>
<li>Iterative Refinement</li>
</ul>
<p><img src="Reconstruct/../assets/22-51.png" alt="" /></p>
<ul>
<li>Resistant to Noise</li>
</ul>
<p><img src="Reconstruct/../assets/22-52.png" alt="" /></p>
<ul>
<li>Feature Preserving</li>
</ul>
<p><img src="Reconstruct/../assets/22-53.png" alt="" /></p>
<p>Implicit methods need normal information, while normal estimation is another challenging problem.</p>
<h3 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h3>
<p>Model the surface reconstruction problem via <strong>dictionary learning</strong></p>
<ul>
<li>VS Implicit method
<ul>
<li>Straightforward</li>
<li>Approximation error is considered</li>
</ul>
</li>
<li>VS Existing Explicit method
<ul>
<li>Denoising the input point cloud</li>
<li>Global approximation error</li>
</ul>
</li>
</ul>
<blockquote>
<p>dictionary learning是一种半显式的方法。</p>
</blockquote>
<h2 id="hybrid-methods"><a class="header" href="#hybrid-methods">Hybrid Methods</a></h2>
<h3 id="1-competing-fronts"><a class="header" href="#1-competing-fronts">(1) Competing Fronts</a></h3>
<p><img src="Reconstruct/../assets/22-54.png" alt="" /></p>
<blockquote>
<p>[1:21:10] 假设物体是封闭曲面。<br />
物体内的距离场不断膨胀，形成 mesh</p>
</blockquote>
<p>Sharf et al. Competing Fronts for Coarse–to–Fine Surface Reconstruction. Eurographics 2006.</p>
<h2 id="2-cooperative-evolutions"><a class="header" href="#2-cooperative-evolutions">(2) Cooperative Evolutions </a></h2>
<ul>
<li>Two deformable models 
<ul>
<li>One from interior</li>
<li>The other from exterior</li>
</ul>
</li>
<li>Alternative evolutions</li>
</ul>
<p><img src="Reconstruct/../assets/22-55.png" alt="" /></p>
<blockquote>
<p>[1:23:02] 改进版:里面的球不断膨胀。外面的球不断收缩，直到两个曲面靠近,适用于有大的空洞的物体。</p>
</blockquote>
<p>Lu and Liu. Surface Reconstruction via Cooperative Evolutions. CAGD 2020.</p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。
https://caterpillarstudygroup.github.io/GAMES102_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="5-postprocessing"><a class="header" href="#5-postprocessing">5. Post‐processing</a></h1>
<p><img src="Reconstruct/../assets/22-56.png" alt="" /></p>
<p>Repairing, denoising, smoothing, simplification…</p>
<p><img src="Reconstruct/../assets/22-57.png" alt="" /></p>
<p>Repairing (completion, hole‐filling, restoration)</p>
<h2 id="1-filling-holes-in-meshes"><a class="header" href="#1-filling-holes-in-meshes">(1) Filling Holes in Meshes </a></h2>
<p>[Liepa, SGP 2003]</p>
<h3 id="pipeline"><a class="header" href="#pipeline">Pipeline</a></h3>
<ol>
<li>Hole identification</li>
<li>Hole triangulation</li>
<li>Mesh refinement </li>
<li>Mesh fairing</li>
</ol>
<p><img src="Reconstruct/../assets/22-58.png" alt="" /></p>
<blockquote>
<p>对空洞部分三角化 ⇒ 三角形加密</p>
</blockquote>
<h3 id="summary-1"><a class="header" href="#summary-1">Summary</a></h3>
<ul>
<li>Easy to implement</li>
<li>Focus algorithm on holes</li>
<li><strong>Triangulation may self‐intersect</strong></li>
<li><strong>Can’t fill holes with islands</strong></li>
<li><strong>Fairing weaken original surface feature</strong></li>
</ul>
<h2 id="2-robust-repair-of-polygonal-models-ju-siggraph-2004"><a class="header" href="#2-robust-repair-of-polygonal-models-ju-siggraph-2004">(2) Robust Repair of Polygonal Models [Ju, Siggraph 2004]</a></h2>
<blockquote>
<p>没讲，能保证拓扑关系</p>
</blockquote>
<ul>
<li>Employ a space‐efficient octree grid</li>
<li>Produce closed, manifold surface for any input 
model</li>
</ul>
<h2 id="3-contextbased-surface-completion"><a class="header" href="#3-contextbased-surface-completion">(3) Context‐based Surface Completion</a></h2>
<p>[Sharf et al., Siggraph 2004]</p>
<h3 id="motivation"><a class="header" href="#motivation">Motivation</a></h3>
<p>Complete the missing region with patches that conform with its context </p>
<p><img src="Reconstruct/../assets/22-59.png" alt="" /></p>
<blockquote>
<p>学习周边的几何细节，再插值</p>
</blockquote>
<h3 id="method"><a class="header" href="#method">Method</a></h3>
<p>Import patches with matching context from the surface itself:</p>
<ul>
<li>Analyze surface characteristics.</li>
<li>Find best matching patch.</li>
<li>Fit imported patch to boundary.</li>
</ul>
<h3 id="limitations-semantics"><a class="header" href="#limitations-semantics">Limitations: Semantics</a></h3>
<p><img src="Reconstruct/../assets/22-60.png" alt="" /></p>
<h2 id="4-examplebased-surface-completion"><a class="header" href="#4-examplebased-surface-completion">(4) Example‐based Surface Completion</a></h2>
<p>[Pauly et al., SGP 2005]</p>
<ul>
<li>Use <strong>3D model database</strong> to provide geometric priors for shape completion</li>
<li>Apply <strong>non‐rigid transforms</strong> on the models
<ul>
<li>More deformation \(\Rightarrow \) less likely completion</li>
</ul>
</li>
<li><strong>Consistently</strong> combine geometric information from multiple context models</li>
<li>Final result comes with <strong>confidence values</strong></li>
</ul>
<blockquote>
<p>从数据库里相似的数据来修复缺失的数据</p>
</blockquote>
<h2 id="5-atomic-volumes-for-mesh-completion"><a class="header" href="#5-atomic-volumes-for-mesh-completion">(5) Atomic Volumes for Mesh Completion </a></h2>
<p>[ Podolak and Rusinkiewicz, SGP 2005]</p>
<h3 id="atomic-volumes"><a class="header" href="#atomic-volumes">Atomic Volumes</a></h3>
<p>A volume is <strong>atomic</strong> if it doesn’t intersect
the polygons of the mesh.</p>
<p><img src="Reconstruct/../assets/22-61.png" alt="" /></p>
<blockquote>
<p>利用内部信息</p>
</blockquote>
<h2 id="summary-2"><a class="header" href="#summary-2">Summary　　　</a></h2>
<ul>
<li>Avoid changing, approximating or re‐sampling the original mesh data</li>
<li>Incorporate user constraints</li>
<li><strong>Can’t process holes with islands</strong></li>
</ul>
<h2 id="6-geometry-completion-by-texture-synthesis"><a class="header" href="#6-geometry-completion-by-texture-synthesis">(6) Geometry Completion by Texture Synthesis</a></h2>
<p>[Nguyen et al., PG 2005]</p>
<blockquote>
<p>在图像空间做纹理合成，再恢复到3D空间中</p>
</blockquote>
<h2 id="7-others"><a class="header" href="#7-others">(7) Others</a></h2>
<ul>
<li>
<p>Marco Attene, Marcel Campen, Leif Kobbelt. Polygon Mesh Repairing: An Application Perspective. ACM Computing Surveys, 2012.</p>
</li>
<li>
<p>Learning based 3D data completion in recent years</p>
<ul>
<li>Han et al. High Resolution Shape Completion Using Deep Neural Networks for Global Structure and Local Geometry Inference. ICCV 2017.</li>
<li>Han et al. Deep Reinforcement Learning of Volume‐guided Progressive View Inpainting for 3D Point Scene Completion from a Single Depth Image. CVPR 2019.</li>
<li>Nie et al. Skeleton‐bridged Point Completion: From Global Inference to Local Adjustment. NeuIPS 2020.</li>
</ul>
</li>
</ul>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。
https://caterpillarstudygroup.github.io/GAMES102_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="动态物体的3d重建"><a class="header" href="#动态物体的3d重建">动态物体的3D重建 </a></h1>
<h2 id="3d动态重建的困难性"><a class="header" href="#3d动态重建的困难性">3D动态重建的困难性</a></h2>
<ul>
<li>数据量大</li>
<li>数据采集困难
<ul>
<li>Single‐Camera</li>
<li>Multi‐Camera</li>
</ul>
</li>
<li>数据结构复杂
<ul>
<li>Geometry</li>
<li>Color</li>
<li>Topology</li>
</ul>
</li>
<li>硬件需求高</li>
</ul>
<h2 id="general-pipeline"><a class="header" href="#general-pipeline">General Pipeline</a></h2>
<h3 id="数据采集"><a class="header" href="#数据采集">数据采集</a></h3>
<p><img src="Reconstruct/../assets/22-62.png" alt="" /></p>
<h3 id="生成3d-meshsurface"><a class="header" href="#生成3d-meshsurface">生成3D mesh/surface</a></h3>
<p><img src="Reconstruct/../assets/22-63.png" alt="" /></p>
<h2 id="人体动态重建-human-performance-capturing"><a class="header" href="#人体动态重建-human-performance-capturing">人体动态重建 （Human Performance Capturing）</a></h2>
<ul>
<li>离线高质量的动态重建方法</li>
<li>实时动态的人体重建方法</li>
<li>基于深度学习的人体重建方法</li>
</ul>
<h3 id="离线高质量动态重建"><a class="header" href="#离线高质量动态重建">离线高质量动态重建</a></h3>
<p>High-quality streamable free-viewpoint video (SIGGRAPH 2015)</p>
<h3 id="实时动态人体重建"><a class="header" href="#实时动态人体重建">实时动态人体重建</a></h3>
<p>[Motion2Fusion 2017]</p>
<p>CVPR 2018 [Oral]</p>
<p><strong>DoubleFusion</strong>:<em>Real-time Capture of Human Performances with Inner Body Shapes from a Single Depth Sensor</em></p>
<h3 id="基于深度学习的动态人体重建方法"><a class="header" href="#基于深度学习的动态人体重建方法">基于深度学习的动态人体重建方法</a></h3>
<p>Volumetric performance capture from minimal camera viewpoints (ECCV 2018)</p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。
https://caterpillarstudygroup.github.io/GAMES102_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<p>[1:11:23] # Modeling<br />
公式中的 a,b,c都是2D的向量。</p>
</blockquote>
<p>[1:12:38] # Modeling<br />
把三个系数 a,b,c 看作是曲线的控制顶点，发现顶点的位置与曲线没有关系,不直观,不利于设计。<br />
把幂基换成 Berstein 基，控制点与曲线的关系变得直观。 </p>
<h1 id="回顾曲面重建"><a class="header" href="#回顾曲面重建">回顾：曲面重建</a></h1>
<p><img src="Modeling/../assets/%E5%BB%BA%E6%A8%A11.png" alt="" /></p>
<h1 id="建模modeling设计与重建"><a class="header" href="#建模modeling设计与重建">建模(modeling)：设计与重建</a></h1>
<ul>
<li><strong>曲面设计</strong>(<strong>Design</strong>)
<ul>
<li>不存在的物体：通过人工交互凭空设计出新的物体
<ul>
<li>CAGD (NURBS)、mesh modeling</li>
</ul>
</li>
<li>存在的物体：通过人工交互编辑修改构建出新的物体</li>
<li>Editing, deformation</li>
</ul>
</li>
<li>曲面重建(Reconstruction)
<ul>
<li>存在的物体：对其采集并进行数字化构建</li>
<li>也称为：逆向工程、扫描重建
<ul>
<li>Reverse engineering, scanning</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="surface-editing"><a class="header" href="#surface-editing">Surface Editing</a></h1>
<h1 id="design-modeling"><a class="header" href="#design-modeling">Design Modeling</a></h1>
<ul>
<li>
<p>Design from zero<br />
• Create a shape by a set of 3D design operators such as extrusion or revolution etc.</p>
</li>
<li>
<p><strong>Design from a given shape</strong> (<strong>Mesh editing</strong>)<br />
• Select a base shape<br />
• Select editing elements and editing operators<br />
• Deform the shape to obtain a new shape</p>
</li>
</ul>
<h1 id="mesh-surface-editing"><a class="header" href="#mesh-surface-editing">Mesh Surface Editing</a></h1>
<p><img src="Modeling/../assets/%E5%BB%BA%E6%A8%A12.png" alt="" /></p>
<h1 id="interactive-shape-modeling"><a class="header" href="#interactive-shape-modeling">Interactive shape modeling</a></h1>
<ul>
<li>Modeling is an interactive, iterative process<br />
• Tools need to be intuitive (interface and outcome)<br />
• Allow quick experimentation<br />
• Preserve shape properties</li>
</ul>
<p><img src="Modeling/../assets/%E5%BB%BA%E6%A8%A13.png" alt="" /></p>
<h1 id="user-interaction-ui"><a class="header" href="#user-interaction-ui">User Interaction (UI)</a></h1>
<ul>
<li>User specifications: Intuitive, easy‐to‐use<br />
• Dragging handles ‐‐ vertices, features, ROI, …</li>
<li>Deformed shape: adapt to user intents</li>
</ul>
<p><strong>Challenges</strong>:<br />
• Operations<br />
• Preservation of properties<br />
• Semantics</p>
<p><img src="Modeling/../assets/%E5%BB%BA%E6%A8%A14.png" alt="" /></p>
<h1 id="methodology"><a class="header" href="#methodology">Methodology</a></h1>
<ul>
<li>Set a proxy P for the input shape S
<ul>
<li>P is simpler/easier/more semantic than S</li>
<li>Find a map between P and S: S=g(P)
<ul>
<li>g is also called an <strong>embedded space</strong></li>
</ul>
</li>
</ul>
</li>
<li>User interacts and deforms the proxy P to P’
<ul>
<li>Find a deformation map: P’=h(P)</li>
</ul>
</li>
<li>Compute a new shape S’ from P’: S’=g(P’)</li>
</ul>
<blockquote>
<p>Key Problem:<br />
• find a good map <em>g</em></p>
</blockquote>
<ul>
<li>第一步：Set a proxy P for the input shape S<br />
P is simpler/easier/more semantic than S</li>
<li>第二步： Find a map between P and S: S=g(P)<br />
g is also called an <strong>embedded space</strong></li>
</ul>
<blockquote>
<p>find a good map <em>g</em> 是关键</p>
</blockquote>
<ul>
<li>第三步：User interacts and deforms the proxy P to P’<br />
Find a deformation map: P’=g(P)</li>
<li>第四步：Compute a new shape S’ from P’: S’=g(P’)</li>
</ul>
<h1 id="proxy-shapes-handles"><a class="header" href="#proxy-shapes-handles">Proxy Shapes (handles)</a></h1>
<ul>
<li>Points<br />
• Points, vertices, …</li>
<li>Lines/Curves<br />
• Sketches, skeletons, silhouettes, wires, …</li>
<li>Meshes<br />
• Bezier nets, lattices, cages, …</li>
<li>Other shapes<br />
• Deformation transfer: learning deformation from other shapes</li>
</ul>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。
https://caterpillarstudygroup.github.io/GAMES102_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="point-based-editing要解决的问题"><a class="header" href="#point-based-editing要解决的问题">Point based editing要解决的问题</a></h1>
<p><img src="Modeling/../assets/%E5%BB%BA%E6%A8%A15.png" alt="" /></p>
<p>Fix 红圈上的点，Drag one or more vertices，更新红圈内的点</p>
<p>本质数学问题：数据插值问题，同时让f满足光滑、性质保持等约束。</p>
<p>$$
\begin{array}{l} 
\min E (f) \\ 
s.t. &amp;f(x_i)=y_i,i=1,2,\dots , n \\ 
\end{array} 
$$</p>
<h1 id="1-rbfbased-editing"><a class="header" href="#1-rbfbased-editing">（1） RBF‐based Editing</a></h1>
<h1 id="2-moving-least-squares-method"><a class="header" href="#2-moving-least-squares-method">（2） Moving Least Squares Method</a></h1>
<p>[Siggraph 2006]</p>
<h1 id="3-vector-field-based-deformations"><a class="header" href="#3-vector-field-based-deformations">（3） Vector Field Based Deformations</a></h1>
<p>[Siggraph 2006]</p>
<h2 id="原理-2"><a class="header" href="#原理-2">原理</a></h2>
<blockquote>
<p>在空间定义了一个连续的场，物理在场里面流动产生新的变化</p>
</blockquote>
<p>Basic model: Moving vertex along the deformation orbit – defined by the path lines of a vector field v.</p>
<p><img src="Modeling/../assets/%E5%BB%BA%E6%A8%A110.png" alt="" /></p>
<p>Given a time‐dependent vector field V(X,t), a <em>Path Line</em> X(t) in space is an integral.</p>
<p><img src="Modeling/../assets/%E5%BB%BA%E6%A8%A111.png" alt="" /></p>
<h2 id="vector-field-selection"><a class="header" href="#vector-field-selection">Vector Field Selection：</a></h2>
<ul>
<li>Deformation Request:<br />
• No self‐intersection<br />
• Volume‐preserving<br />
• Details‐preserving<br />
• Smoothness of shape in deformation</li>
<li>Divergence‐free Vector Field: \(V=(V_1, V_2, V_3)\)</li>
</ul>
<p>$$
div V=\frac{\partial V_1}{\partial x} +\frac{\partial V_2}{\partial y}+\frac{\partial V_3}{\partial z}=0
$$</p>
<blockquote>
<p>[38:39]优点:物体不会产生自交</p>
</blockquote>
<h1 id="4-laplacian-editing-sorkine-et-al-sgp-2004"><a class="header" href="#4-laplacian-editing-sorkine-et-al-sgp-2004">（4） Laplacian Editing [Sorkine et al. SGP 2004]</a></h1>
<p>优点：<br />
• Laplacian能体现局部细节，因此Laplacian 尽量不变可保证局部细节<br />
• Representation with <strong>sparse</strong> matrices<br />
• Efficient <strong>linear</strong> surface reconstruction</p>
<p><img src="Modeling/../assets/%E5%BB%BA%E6%A8%A114.png" alt="" /></p>
<p>$$
\nu _i=\sum _{j\in N(i)}w_j\nu _j+\delta _i
$$</p>
<h2 id="优化目标"><a class="header" href="#优化目标">优化目标</a></h2>
<ul>
<li>Laplacian Approximation</li>
</ul>
<p>$$
\tilde{X} =\underset{X}{argmin} \left ( ||LX-\delta ^{(x)}||^2+\sum _{j\in C}\omega ^2||x_j-c_j||^2 \right ) 
$$</p>
<blockquote>
<p>第一项：局部细节不变，第二项：满足用户要求</p>
</blockquote>
<ul>
<li>Gradient Approximation</li>
</ul>
<p>$$
\min_\phi \iint _\Omega ||\nabla \phi -W||^2dA,
$$</p>
<p><img src="Modeling/../assets/%E5%BB%BA%E6%A8%A115.png" alt="" /></p>
<h2 id="求解线性方程组"><a class="header" href="#求解线性方程组">求解线性方程组</a></h2>
<p>$$
LX=\delta\\
x_j=c_j,  \quad j\in\left \{ j_1,j_2,\dots,j_k \right \}
$$</p>
<h2 id="results-2"><a class="header" href="#results-2">Results</a></h2>
<p><img src="Modeling/../assets/%E5%BB%BA%E6%A8%A116.png" alt="" /></p>
<h2 id="detail-transfer-and-mixing-1"><a class="header" href="#detail-transfer-and-mixing-1">Detail transfer and mixing</a></h2>
<p>这是基于Laplace的point based的一个应用</p>
<p>[40:45] 把一个 mesh 的 Laplacian 细节迁移到另一个 mesh上</p>
<p><img src="Modeling/../assets/%E5%BB%BA%E6%A8%A117.png" alt="" /></p>
<blockquote>
<p>要求网格一一对应</p>
</blockquote>
<p>方法：Mixing Laplacians，即Taking weighted average of \(\delta _i\) and \(\delta '_i\)</p>
<h2 id="mesh-transplanting-1"><a class="header" href="#mesh-transplanting-1">Mesh transplanting</a></h2>
<p>这是基于Laplace的point based的一个应用<br />
[41:29] 把一个模型拼接到另一个模型上</p>
<p><img src="Modeling/../assets/%E5%BB%BA%E6%A8%A118.png" alt="" /></p>
<p>可能用[0,1]控制Laplace的混合比例，造成渐变效果。</p>
<h2 id="invariance--solutions"><a class="header" href="#invariance--solutions">Invariance – solutions</a></h2>
<ul>
<li>Explicit transformation of the differential coordinates prior to surface reconstruction
<ul>
<li>Lipman, Sorkine, Cohen‐Or, Levin, Rössl and Seidel [SMI 04], “Differential Coordinates for Interactive Mesh Editing”,
<ul>
<li>Estimation of rotations from naive reconstruction</li>
</ul>
</li>
</ul>
</li>
<li>Yu, Zhou, Xu, Shi, Bao, Guo and Shum [SIGGRAPH 04], “Mesh Editing With Poisson‐Based Gradient Field Manipulation”,
<ul>
<li>Propagation of handle transformation to the rest of the ROI using geodesic distances</li>
</ul>
</li>
<li>Zayer, Rössl, Karni and Seidel [EG 05], “Harmonic Guidance for Surface Deformation”,
<ul>
<li>Propagation of handle transformation to the rest of the ROI using harmonic functions</li>
</ul>
</li>
</ul>
<h1 id="5-poisson-mesh-editing"><a class="header" href="#5-poisson-mesh-editing">（5） Poisson Mesh Editing</a></h1>
<p>Yu et al. Mesh Editing With Poisson-Based Gradient Field Manipulation. Siggraph 2004.</p>
<blockquote>
<p>这个方法起源于一种图片算法，把图像一部分融合到另外一个图像.让边界无缝融合，用目标的颜色结合源的梯度。<br />
把这个方法用到3D图形上，源的梯度就演变为源的Laplace。</p>
</blockquote>
<p>• <strong>The representation</strong>: the <strong>gradients</strong> of the functions <strong>X, Y, Z</strong> on each triangle of the mesh<br />
• <strong>Deformation</strong>: propagate the transformation of the handle onto the ROI using <strong>geodesic distances</strong></p>
<p><img src="Modeling/../assets/%E5%BB%BA%E6%A8%A120.png" alt="" /></p>
<p>• Inspiration: <strong>Poisson Image Editing</strong> [Pérez et al. 03]</p>
<p><img src="Modeling/../assets/%E5%BB%BA%E6%A8%A121.png" alt="" /></p>
<p>• Reconstruct a function from its gradients via the Poisson equation:</p>
<p>$$
\underset{f}{\arg \min } \underset{\Omega}{\int}||\nabla f-\mathbf{w}||^{2}, \quad  s.t. \quad  f\left |_{\partial \Omega }= f^* \right | _{\partial \Omega}
$$ </p>
<p>$$
\Downarrow 
$$</p>
<p>$$
\Delta f=\operatorname{div} \mathbf{w} \quad  with  \left.\quad f \right|_{\partial \Omega}=\left.f^{*}\right| _{\partial \Omega} 
$$</p>
<h1 id="67-asrigidaspossible-deformation"><a class="header" href="#67-asrigidaspossible-deformation">（6）（7） As‐rigid‐as‐possible Deformation</a></h1>
<p>方法起源于一种2D图形算法：</p>
<p><img src="Modeling/../assets/%E5%BB%BA%E6%A8%A122.png" alt="" /></p>
<blockquote>
<p>把三角形当作刚体来形变。然后再缝合。</p>
</blockquote>
<p>后引申到3D：</p>
<p>[Sorkine and Alexa, As‐Rigid‐As‐Possible Surface Modeling. SGP 2007]</p>
<p>Ask all star edges to transform rigidly by some rotation R, then the shape of the cell is preserved</p>
<p><img src="Modeling/../assets/%E5%BB%BA%E6%A8%A123.png" alt="" /></p>
<p>$$
\min_{\mathbf{v}^{\prime}}\sum_{i=1}^{n} \sum _{j\in N(i)}||({\mathbf{v}}^{\prime}_i-{\mathbf{v}}^{\prime}_j)-R_i({\mathbf{v}}_i-{\mathbf{v}}_j)||^2
$$</p>
<p>$$
s.t.\mathbf{v}^{\prime}_j=\mathbf{c} _j,j\in C
$$</p>
<p>效果：<br />
<img src="Modeling/../assets/%E5%BB%BA%E6%A8%A124.png" alt="" /></p>
<blockquote>
<p>deformation 时保持 Laplacian 旋转<br />
优点：中间会膨胀</p>
</blockquote>
<h1 id="8-linear-rotationinvariant-coordinates"><a class="header" href="#8-linear-rotationinvariant-coordinates">（8） Linear Rotation‐invariant Coordinates</a></h1>
<p>[Lipman et al. Siggraph 05]</p>
<blockquote>
<p>保持曲面的第一形和第二形.
没听懂</p>
</blockquote>
<p>• Keep a local frame at each vertex<br />
• Prescribe changes to some selected frames</p>
<p><img src="Modeling/../assets/%E5%BB%BA%E6%A8%A125.png" alt="" /></p>
<p>Local frame:<br />
{\(\mathbf{a}_i, \mathbf{b}_i, \mathbf{n}_i\)}</p>
<p>• Encode the differences between adjacent frames<br />
• Solve for the new frames in least‐squares sense</p>
<p>$$
\begin{array}{l}
{\mathbf{a}_i}-{\mathbf{a}_j}=\alpha_1 {\mathbf{a}_i}+\alpha_2 {\mathbf{b}_i}+\alpha_3 {\mathbf{n}_i}\\
{\mathbf{b}_i}-{\mathbf{b}_j}=\beta _1 {\mathbf{a}_i}+\beta _2 {\mathbf{b}_i}+\beta _3 {\mathbf{n}_i} \\
{\mathbf{n}_i}-{\mathbf{n}_j}=\gamma  _1 {\mathbf{a}_i}+\gamma _2 {\mathbf{b}_i}+\gamma _3 {\mathbf{n}_i}
\end{array}\\
\cdots \cdots \\
constraints
$$</p>
<p><img src="Modeling/../assets/%E5%BB%BA%E6%A8%A126.png" alt="" /></p>
<ul>
<li>Reconstruction:<br />
• After having the frames, solve for positions Frame‐based deformations</li>
</ul>
<p><img src="Modeling/../assets/%E5%BB%BA%E6%A8%A127.png" alt="" /></p>
<p><img src="Modeling/../assets/%E5%BB%BA%E6%A8%A128.png" alt="" /></p>
<h2 id="results-3"><a class="header" href="#results-3">Results</a></h2>
<p><img src="Modeling/../assets/%E5%BB%BA%E6%A8%A129.png" alt="" /></p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。
https://caterpillarstudygroup.github.io/GAMES102_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="2-curve-proxy"><a class="header" href="#2-curve-proxy">2. Curve Proxy</a></h1>
<p>Curve Proxy要解决的问题<br />
<img src="Modeling/../assets/%E5%BB%BA%E6%A8%A130.png" alt="" /></p>
<h1 id="21-skeleton-based"><a class="header" href="#21-skeleton-based">2.1 Skeleton based</a></h1>
<p>Axial Deformation [1994]</p>
<p><img src="Modeling/../assets/%E5%BB%BA%E6%A8%A131.png" alt="" /></p>
<blockquote>
<p>取曲面中轴或人为标注的骨架<br />
并建立骨架上的点与边界上的点的关联</p>
</blockquote>
<p><img src="Modeling/../assets/%E5%BB%BA%E6%A8%A132.png" alt="" /></p>
<h1 id="22-skeletonbased-deformation"><a class="header" href="#22-skeletonbased-deformation">2.2 Skeleton‐based Deformation</a></h1>
<p><img src="Modeling/../assets/%E5%BB%BA%E6%A8%A135.png" alt="" /></p>
<h1 id="23-wires-based"><a class="header" href="#23-wires-based">2.3 Wires based</a></h1>
<p>[Siggraph 1999]</p>
<p><img src="Modeling/../assets/%E5%BB%BA%E6%A8%A136.png" alt="" /></p>
<blockquote>
<p>在曲面外围定义轮廓线</p>
</blockquote>
<h1 id="24-silhouette-sketching-based"><a class="header" href="#24-silhouette-sketching-based">2.4 Silhouette sketching based</a></h1>
<p>[Nealen et al. Siggraph 05]</p>
<blockquote>
<p>Silhouette （轮廓线）</p>
</blockquote>
<p>Approximate sketching: Balance weighting between detail and positional constraints</p>
<p><img src="Modeling/../assets/%E5%BB%BA%E6%A8%A138.png" alt="" /></p>
<p><img src="Modeling/../assets/%E5%BB%BA%E6%A8%A139.png" alt="" /></p>
<blockquote>
<p>实现的思想类似于Laplace，只是交互的方式变成了Stretch。</p>
</blockquote>
<h1 id="25-volumetric-graph-laplacian"><a class="header" href="#25-volumetric-graph-laplacian">2.5 Volumetric Graph Laplacian</a></h1>
<p><img src="Modeling/../assets/%E5%BB%BA%E6%A8%A141.png" alt="" /></p>
<blockquote>
<p>[55:32] 保证体里面的Laplace，相当于2D Laplacian 推广到3D。<br />
能保证体不收缩，即局部保体积。</p>
</blockquote>
<h2 id="animation-modeling-from-2d-cartoons"><a class="header" href="#animation-modeling-from-2d-cartoons">Animation Modeling from 2D Cartoons</a></h2>
<p><img src="Modeling/../assets/%E5%BB%BA%E6%A8%A142.png" alt="" /></p>
<h1 id="short-summary-curve-proxy"><a class="header" href="#short-summary-curve-proxy">Short Summary: curve proxy</a></h1>
<p>• Curve features<br />
• Skeletons<br />
• Silhouette<br />
• Free‐form sketches<br />
• Wires<br />
• 2D image contours<br />
• …</p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。
https://caterpillarstudygroup.github.io/GAMES102_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="3-mesh-proxy"><a class="header" href="#3-mesh-proxy">3. Mesh Proxy</a></h1>
<p><strong>方法</strong>：</p>
<ul>
<li>Define a mesh proxy for the shape: generally a simpler, coarse mesh which encloses the shape</li>
</ul>
<p><img src="Modeling/../assets/%E5%BB%BA%E6%A8%A143.png" alt="" /></p>
<blockquote>
<p>The shape is embedded into the mesh proxy</p>
</blockquote>
<ul>
<li>Deform the mesh proxy using point/line base methods</li>
</ul>
<p><strong>Advantages</strong>:<br />
• You can deform arbitrary objects<br />
• Independent of object representation</p>
<h1 id="31-freeform-deformation-ffd"><a class="header" href="#31-freeform-deformation-ffd">3.1 Free‐form Deformation (FFD)</a></h1>
<p>[Sederberg et al. 86]</p>
<ul>
<li>Proxy: a <strong>lattice</strong> mesh</li>
<li>more easily parametrized than the object</li>
<li>Deformation defined by the tensor Bezier solid</li>
</ul>
<p><img src="Modeling/../assets/%E5%BB%BA%E6%A8%A144.png" alt="" /></p>
<h1 id="32-cagebased-deformation"><a class="header" href="#32-cagebased-deformation">3.2 Cage‐based deformation</a></h1>
<ul>
<li>Proxy: cage</li>
<li>Barycentric coordinates</li>
</ul>
<p><img src="Modeling/../assets/%E5%BB%BA%E6%A8%A145.png" alt="" /></p>
<blockquote>
<p>怎么找 Cage?</p>
</blockquote>
<h1 id="33-multiresolution-editing"><a class="header" href="#33-multiresolution-editing">3.3 Multiresolution Editing</a></h1>
<ul>
<li>Proxy: simplified shape</li>
</ul>
<blockquote>
<p>对曲面进行光顺 (简化)，再还原细节</p>
</blockquote>
<ul>
<li>Pros<br />
• Preserving details, scalable</li>
<li>Cons<br />
• Instable reconstruction for large deformation<br />
• Resampling problem</li>
<li>Invariant variables<br />
• Detail information</li>
</ul>
<p><img src="Modeling/../assets/%E5%BB%BA%E6%A8%A146.png" alt="" /></p>
<p><img src="Modeling/../assets/%E5%BB%BA%E6%A8%A147.png" alt="" /></p>
<h1 id="short-summary-mesh-proxy"><a class="header" href="#short-summary-mesh-proxy">Short Summary: mesh proxy</a></h1>
<p>• Lattice<br />
• Cage<br />
• Simplified shape<br />
• …</p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。
https://caterpillarstudygroup.github.io/GAMES102_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="4-deformation-transfer"><a class="header" href="#4-deformation-transfer">4. Deformation Transfer</a></h1>
<p>Siggraph 2004</p>
<p><img src="Modeling/../assets/%E5%BB%BA%E6%A8%A148.png" alt="" /></p>
<blockquote>
<p>找马和骆驼的对关系、根据对应关系迁移三角形特性</p>
</blockquote>
<h1 id="editing-arbitrary-deforming-surface-animations"><a class="header" href="#editing-arbitrary-deforming-surface-animations">Editing Arbitrary Deforming Surface Animations</a></h1>
<p>Siggraph 2006</p>
<p><img src="Modeling/../assets/%E5%BB%BA%E6%A8%A149.png" alt="" /></p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。
https://caterpillarstudygroup.github.io/GAMES102_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="5-sketchbased-modeling-基于草图的建模"><a class="header" href="#5-sketchbased-modeling-基于草图的建模">5. Sketch‐based Modeling （基于草图的建模）</a></h1>
<p><img src="Modeling/../assets/%E5%BB%BA%E6%A8%A150.png" alt="" /></p>
<h1 id="an-example"><a class="header" href="#an-example">An Example</a></h1>
<p><img src="Modeling/../assets/%E5%BB%BA%E6%A8%A151.png" alt="" /></p>
<h1 id="bmesh"><a class="header" href="#bmesh">B‐Mesh</a></h1>
<p>[Ji et al. 2010]</p>
<p><img src="Modeling/../assets/%E5%BB%BA%E6%A8%A152.png" alt="" /></p>
<h1 id="sketchbased-modeling-systems"><a class="header" href="#sketchbased-modeling-systems">Sketch‐based Modeling Systems</a></h1>
<p><img src="Modeling/../assets/%E5%BB%BA%E6%A8%A153.png" alt="" /></p>
<h1 id="more-1"><a class="header" href="#more-1">More…</a></h1>
<p><img src="Modeling/../assets/%E5%BB%BA%E6%A8%A154.png" alt="" /></p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。
https://caterpillarstudygroup.github.io/GAMES102_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="6-sculpturing-modeling"><a class="header" href="#6-sculpturing-modeling">6. Sculpturing Modeling</a></h1>
<h1 id="highly-detailed-meshes"><a class="header" href="#highly-detailed-meshes">Highly Detailed Meshes</a></h1>
<p><img src="Modeling/../assets/%E5%BB%BA%E6%A8%A155.png" alt="" /></p>
<h1 id="motivation-sculpturing"><a class="header" href="#motivation-sculpturing">Motivation: Sculpturing</a></h1>
<p><img src="Modeling/../assets/%E5%BB%BA%E6%A8%A156.png" alt="" /></p>
<h1 id="sculpturing-modeling"><a class="header" href="#sculpturing-modeling">Sculpturing Modeling</a></h1>
<p>• A series of sculpting/brush operators</p>
<p><img src="Modeling/../assets/%E5%BB%BA%E6%A8%A157.png" alt="" /></p>
<h1 id="sculpting-modeling-tools"><a class="header" href="#sculpting-modeling-tools">Sculpting Modeling Tools</a></h1>
<p><img src="Modeling/../assets/%E5%BB%BA%E6%A8%A158.png" alt="" /></p>
<h1 id="3d-brushes"><a class="header" href="#3d-brushes">3D Brushes</a></h1>
<p><img src="Modeling/../assets/%E5%BB%BA%E6%A8%A159.png" alt="" /></p>
<h1 id="sculpting-modeling"><a class="header" href="#sculpting-modeling">Sculpting Modeling</a></h1>
<p><img src="Modeling/../assets/%E5%BB%BA%E6%A8%A160.png" alt="" /></p>
<h1 id="summary-shape-editing"><a class="header" href="#summary-shape-editing">Summary: Shape Editing</a></h1>
<ul>
<li>Points<br />
• Points, vertices, …</li>
<li>Lines/Curves<br />
• Sketches, skeletons, silhouettes, wires, …</li>
<li>Meshes<br />
• Bezier nets, lattices, cages, …</li>
<li>Other shapes<br />
• Deformation transfer: learning deformation from other shapes</li>
<li><strong>Physically‐based shape deformation</strong> (*)<br />
• <strong>Material‐based, FEM, simulation</strong></li>
</ul>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。
https://caterpillarstudygroup.github.io/GAMES102_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="1-modeling-by-examples"><a class="header" href="#1-modeling-by-examples">1. Modeling by Examples</a></h1>
<p>[Funkhouser et al. Siggraph 2004]</p>
<ol>
<li>Segment into parts</li>
<li>Search 3D database for parts</li>
<li>Compose parts into a model</li>
</ol>
<p><img src="DataDrivenModeling/../assets/%E5%BB%BA%E6%A8%A162.png" alt="" /></p>
<h1 id="2-probabilistic-reasoning"><a class="header" href="#2-probabilistic-reasoning">2. Probabilistic Reasoning</a></h1>
<p>[Chaudhuri et al. Siggraph 2011]</p>
<p>基于贝叶斯网络</p>
<p><img src="DataDrivenModeling/../assets/%E5%BB%BA%E6%A8%A164-1.png" alt="" /></p>
<p>$$
\mathbf{P(X)} =\prod_i\mathbf{P}\left ( x_i|\pi (x_i) \right )
$$</p>
<h1 id="3-shapesynth-exploration-as-design-tool"><a class="header" href="#3-shapesynth-exploration-as-design-tool">3. ShapeSynth: Exploration as Design Tool</a></h1>
<p>[Averkiou et al. Siggraph 2014]</p>
<p><img src="DataDrivenModeling/../assets/%E5%BB%BA%E6%A8%A166.png" alt="" /> </p>
<blockquote>
<p>把形状映射到高维空间</p>
</blockquote>
<h1 id="4-photoinspired-modeling"><a class="header" href="#4-photoinspired-modeling">4. Photo‐inspired Modeling</a></h1>
<p><img src="DataDrivenModeling/../assets/%E5%BB%BA%E6%A8%A167.png" alt="" /></p>
<blockquote>
<p>找轮廓线最相似，然后再做变形，同时结构保持椅子的语义结构</p>
</blockquote>
<h1 id="5-primitivebased-modeling"><a class="header" href="#5-primitivebased-modeling">5. Primitive‐based Modeling</a></h1>
<p><img src="DataDrivenModeling/../assets/%E5%BB%BA%E6%A8%A169.png" alt="" /></p>
<blockquote>
<p>分析primitive并fit</p>
</blockquote>
<h1 id="6-shadow-guidance"><a class="header" href="#6-shadow-guidance">6. Shadow Guidance</a></h1>
<p>Fan et al. 2013</p>
<p><img src="DataDrivenModeling/../assets/%E5%BB%BA%E6%A8%A170.png" alt="" /></p>
<blockquote>
<p>根据阴影概率</p>
</blockquote>
<h1 id="6-shadow-guidance-1"><a class="header" href="#6-shadow-guidance-1">6. Shadow Guidance</a></h1>
<p>Fan et al. 2013</p>
<p><img src="DataDrivenModeling/../assets/%E5%BB%BA%E6%A8%A171.png" alt="" /></p>
<h1 id="7-learning-generative-models-of-3d-shapes-3dgan"><a class="header" href="#7-learning-generative-models-of-3d-shapes-3dgan">7. Learning Generative Models of 3D Shapes (3D‐GAN)</a></h1>
<p>• Emergence of various 3D‐GANs for shape generation</p>
<p><img src="DataDrivenModeling/../assets/%E5%BB%BA%E6%A8%A172.png" alt="" /></p>
<p>Chinagraph 2020 Key note talk by Hao Zhang:<br />
<a href="https://www.bilibili.com/video/BV1Pa4y1x7au?p=3">https://www.bilibili.com/video/BV1Pa4y1x7au?p=3</a><br />
Chaudhuri, et al. Learning Generative Models of 3D Structures. Computer Graphics Forum (Eurographics STAR), 2020.</p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。
https://caterpillarstudygroup.github.io/GAMES102_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="shape-morphing"><a class="header" href="#shape-morphing">Shape Morphing</a></h1>
<h2 id="要解决的问题-4"><a class="header" href="#要解决的问题-4">要解决的问题</a></h2>
<p>给定头尾模型，生成中间的模型，常用于做关键帧动画。<br />
<img src="ShapeMorphing/../assets/%E5%BB%BA%E6%A8%A173.png" alt="" /></p>
<ul>
<li>Input: two meshes source &amp; target<br />
• Frames at \(t_0\) and \(t_n\)</li>
<li>Output: sequence of intermediate meshes<br />
• Frames \(t_1\) to \(t_{n‐1}\)<br />
• For each point on source/target model specify location 
at time \(t_i\) consistent with source &amp; target</li>
</ul>
<h2 id="wraping-vs-morphing"><a class="header" href="#wraping-vs-morphing">Wraping VS Morphing</a></h2>
<ul>
<li>Warping: Unary Op<br />
• Given <strong>Object A</strong> and <strong>F(t)</strong>, find <strong>Object B</strong></li>
</ul>
<p><img src="ShapeMorphing/../assets/%E5%BB%BA%E6%A8%A175.png" alt="" /></p>
<ul>
<li>Morphing: Binary Op<br />
• Given <strong>Object A</strong> and <strong>Object B</strong>, find <strong>F(t)</strong></li>
</ul>
<p><img src="ShapeMorphing/../assets/%E5%BB%BA%E6%A8%A176.png" alt="" /></p>
<h2 id="rules-for-good-morphing"><a class="header" href="#rules-for-good-morphing">Rules for Good Morphing</a></h2>
<ul>
<li>Natural
<ul>
<li>Keep as much as possible of the two shapes during the transformation
<ul>
<li>Volume, curvature, area, etc...</li>
</ul>
</li>
<li>Subjective aesthetic criteria</li>
</ul>
</li>
<li>User control
<ul>
<li>intuitive</li>
<li>not too heavy</li>
<li>can be adapted to user's knowledge</li>
</ul>
</li>
</ul>
<h2 id="two-subproblems"><a class="header" href="#two-subproblems">Two Sub‐Problems</a></h2>
<ul>
<li>
<p>Correspondence problem</p>
<ul>
<li>Compatible meshes</li>
<li>For each point on source/target meshes find corresponding point on second mesh = Parameterization</li>
</ul>
<p><img src="ShapeMorphing/../assets/%E5%BB%BA%E6%A8%A177.png" alt="" /></p>
</li>
<li>
<p>Path problem</p>
<ul>
<li>Inbetween shapes</li>
<li>Specify trajectory in time for each point
<ul>
<li>For mesh – specify vertex trajectory</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="1-vertex-correspondence"><a class="header" href="#1-vertex-correspondence">1. Vertex Correspondence</a></h1>
<h2 id="目标-2"><a class="header" href="#目标-2">目标</a></h2>
<p>Each vertex on source mesh mapped to vertex on target (and vice versa)</p>
<p><img src="ShapeMorphing/../assets/%E5%BB%BA%E6%A8%A178.png" alt="" /></p>
<h2 id="挑战"><a class="header" href="#挑战">挑战</a></h2>
<p><img src="ShapeMorphing/../assets/%E5%BB%BA%E6%A8%A179.png" alt="" /></p>
<h2 id="11-parameterization"><a class="header" href="#11-parameterization">1.1 Parameterization</a></h2>
<p>To compute map between source mesh S and  target mesh T parameterize both on common  domain D:</p>
<p>$$
F_s:S \to D\\
F_t:S \to D\\
F_{st}:F_t^{-1} F_s
$$</p>
<p>Common domain options</p>
<ul>
<li>2D patch(es) – works for genus 0 + boundary
<ul>
<li>Use convex boundary (why?)</li>
</ul>
</li>
</ul>
<table><thead><tr><th></th><th></th><th></th></tr></thead><tbody>
<tr><td><img src="ShapeMorphing/../assets/%E5%BB%BA%E6%A8%A180.png" alt="" /></td><td><img src="ShapeMorphing/../assets/%E5%BB%BA%E6%A8%A181.png" alt="" /></td><td><img src="ShapeMorphing/../assets/%E5%BB%BA%E6%A8%A182.png" alt="" /></td></tr>
</tbody></table>
<ul>
<li>Sphere
<img src="ShapeMorphing/../assets/%E5%BB%BA%E6%A8%A183.png" alt="" /></li>
<li>Base mesh</li>
</ul>
<p>Lee et al. 1999</p>
<p><img src="ShapeMorphing/../assets/%E5%BB%BA%E6%A8%A185.png" alt="" /></p>
<h2 id="14-decomposition-based"><a class="header" href="#14-decomposition-based">1.4 Decomposition Based</a></h2>
<p>[Shlafman et al. 2002]</p>
<p><img src="ShapeMorphing/../assets/%E5%BB%BA%E6%A8%A187.png" alt="" /></p>
<blockquote>
<p>分解成部分，每个部分分别对应。<br />
大问题分解成小问题</p>
</blockquote>
<h2 id="15-component-based"><a class="header" href="#15-component-based">1.5 Component Based</a></h2>
<p><img src="ShapeMorphing/../assets/%E5%BB%BA%E6%A8%A188.png" alt="" /></p>
<h2 id="16-many-recent-works"><a class="header" href="#16-many-recent-works">1.6 Many Recent Works</a></h2>
<p><img src="ShapeMorphing/../assets/%E5%BB%BA%E6%A8%A189.png" alt="" /></p>
<blockquote>
<p>mapping问题，网络A映射到网络B，使得映射后扭曲极小</p>
</blockquote>
<h2 id="17-errorbounded-compatible-remeshing"><a class="header" href="#17-errorbounded-compatible-remeshing">1.7 Error‐Bounded Compatible Remeshing</a></h2>
<p>Yang et al.  Error‐Bounded Compatible Remeshing. Siggraph 2020.</p>
<p>• Optimization based method</p>
<p><img src="ShapeMorphing/../assets/%E5%BB%BA%E6%A8%A190.png" alt="" /></p>
<h2 id="18-different-topologies"><a class="header" href="#18-different-topologies">1.8 Different Topologies</a></h2>
<p>[DeCarlo et al. 1996]</p>
<p><img src="ShapeMorphing/../assets/%E5%BB%BA%E6%A8%A193.png" alt="" /></p>
<h2 id="more-correspondences-between-planar-shapes--matching"><a class="header" href="#more-correspondences-between-planar-shapes--matching">More: Correspondences between planar shapes – Matching</a></h2>
<p>• Physically Based Method  [Sederberg et al. 1992]</p>
<p><img src="ShapeMorphing/../assets/%E5%BB%BA%E6%A8%A194.png" alt="" /></p>
<p>• Curve Aligning [Sebastian et al. 2003]</p>
<p><img src="ShapeMorphing/../assets/%E5%BB%BA%E6%A8%A195.png" alt="" /></p>
<p>$$
\mu[g]=\int_{C}\left|\frac{\partial}{\partial s}(\bar{C}(\bar{s})-C(s))\right|^{2} d s+R \int_{C}(\kappa(s)-\bar{\kappa}(\bar{s}))^{2} d s
$$</p>
<p>• Perceptually Based Method [Liu et al. 2004]</p>
<p><img src="ShapeMorphing/../assets/%E5%BB%BA%E6%A8%A196.png" alt="" /></p>
<h1 id="2-vertex-path-trajectory"><a class="header" href="#2-vertex-path-trajectory">2. Vertex Path (Trajectory)</a></h1>
<ul>
<li>
<p>Input:<br />
• All vertices on source &amp; target have one‐to‐one correspondence with each other<br />
• Each vertex has two 3D coords vFc1 (source) and vFc2 (target)</p>
</li>
<li>
<p>Output: generate the intermediate shapes from two shapes</p>
</li>
</ul>
<p><img src="ShapeMorphing/../assets/%E5%BB%BA%E6%A8%A197.png" alt="" /></p>
<h2 id="simplest-method-linear-interpolation"><a class="header" href="#simplest-method-linear-interpolation">Simplest Method: Linear Interpolation</a></h2>
<ul>
<li>Linear interpolation between corresponding points</li>
</ul>
<p><img src="ShapeMorphing/../assets/%E5%BB%BA%E6%A8%A198.png" alt="" /></p>
<p>优点：Work well for many cases，Simple and easy<br />
缺点：Shrinkage</p>
<p><img src="ShapeMorphing/../assets/%E5%BB%BA%E6%A8%A1100.png" alt="" /></p>
<h2 id="intrinsic-approach"><a class="header" href="#intrinsic-approach">Intrinsic Approach</a></h2>
<p>Sederberg et al. 1993</p>
<p>不插值顶点，而是插值多边形的<strong>边长和夹角</strong></p>
<p><img src="ShapeMorphing/../assets/%E5%BB%BA%E6%A8%A1101.png" alt="" /></p>
<h2 id="fourier-approach"><a class="header" href="#fourier-approach">Fourier Approach</a></h2>
<blockquote>
<p>插件付里叶系数</p>
</blockquote>
<p><img src="ShapeMorphing/../assets/%E5%BB%BA%E6%A8%A1102-1.png" alt="" /></p>
<p>$$
\begin{array}{l} 
\begin{bmatrix}x(t)
\\y(t)
\end{bmatrix} \\ 
=\begin{bmatrix}a_0
\\c_0
\end{bmatrix}+ {\textstyle \sum_{k=1}^{\infty }} \begin{bmatrix} a_k &amp;b_k
\\ c_k &amp;d_k
\end{bmatrix}\begin{bmatrix}\cos(2\pi kt)
\\ \sin(2\pi kt)
\end{bmatrix} \ 
\end{array} 
$$</p>
<h2 id="wavelet-approach"><a class="header" href="#wavelet-approach">Wavelet Approach</a></h2>
<p>Zhang et al. 2000</p>
<p>• Wavelet decomposition </p>
<p><img src="ShapeMorphing/../assets/%E5%BB%BA%E6%A8%A1103.png" alt="" /></p>
<h2 id="star-skeleton-representation"><a class="header" href="#star-skeleton-representation">Star Skeleton Representation</a></h2>
<p>[Shapira et al. 1995]</p>
<p><img src="ShapeMorphing/../assets/%E5%BB%BA%E6%A8%A1104.png" alt="" /></p>
<h2 id="interior-based-approach"><a class="header" href="#interior-based-approach">Interior Based Approach</a></h2>
<blockquote>
<p>不插值顶点，而是插值三角形的仿射变换（旋转和平移）<br />
好处是能同时进行纹理的插值</p>
</blockquote>
<ul>
<li>Based on compatible triangulation<br />
• [Gotsman and Surazhsky, 1999‐2001]<br />
• As‐rigid‐as‐possible [Alexa et al. 2000]</li>
</ul>
<p><img src="ShapeMorphing/../assets/%E5%BB%BA%E6%A8%A1106.png" alt="" /></p>
<h2 id="morphing-between-different-topologies"><a class="header" href="#morphing-between-different-topologies">Morphing between Different Topologies</a></h2>
<p>Liu et al. 2005</p>
<p><img src="ShapeMorphing/../assets/%E5%BB%BA%E6%A8%A1107.png" alt="" /></p>
<h2 id="implicit-approaches"><a class="header" href="#implicit-approaches">Implicit Approaches</a></h2>
<p>Construct a 4D function which interpolates two shapes (with iso‐value 0 and 1 respectively)</p>
<p><img src="ShapeMorphing/../assets/%E5%BB%BA%E6%A8%A1108.png" alt="" /></p>
<blockquote>
<p>截面就是插值结果<br />
优点是不需要找对应关系<br />
缺点是不可控制</p>
</blockquote>
<h2 id="distance-field"><a class="header" href="#distance-field">Distance Field</a></h2>
<p>[Cohen-Or et al. 1998]</p>
<p>• Distance field of a shape</p>
<p><img src="ShapeMorphing/../assets/%E5%BB%BA%E6%A8%A1109-1.png" alt="" /></p>
<h2 id="variational-implicit-function"><a class="header" href="#variational-implicit-function">Variational Implicit Function</a></h2>
<p><img src="ShapeMorphing/../assets/%E5%BB%BA%E6%A8%A1111.png" alt="" /></p>
<p>$$
f(X)=\sum_{j=1}^{n} d_j\phi (X-C_j)+P(X)
$$</p>
<blockquote>
<p>用RBF构造插值函数</p>
</blockquote>
<h1 id="polymorph-morphing-between-multiple-shapes"><a class="header" href="#polymorph-morphing-between-multiple-shapes">Polymorph: Morphing between multiple shapes</a></h1>
<p><img src="ShapeMorphing/../assets/%E5%BB%BA%E6%A8%A1113.png" alt="" /></p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。
https://caterpillarstudygroup.github.io/GAMES102_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="回顾-4"><a class="header" href="#回顾-4">回顾</a></h1>
<p>曲面重建或建模</p>
<p>Textured Surfaces</p>
<p><img src="TextureSynthesis/../assets/%E5%90%88%E6%88%902.png" alt="" /> </p>
<h1 id="texture-synthesis"><a class="header" href="#texture-synthesis">Texture Synthesis</a></h1>
<h2 id="3d纹理合成"><a class="header" href="#3d纹理合成">3D纹理合成</a></h2>
<p>目标：把一小片纹理铺满整个模型，但要注意接缝入不连续的现象</p>
<p><img src="TextureSynthesis/../assets/%E5%90%88%E6%88%904.png" alt="" /> </p>
<h2 id="2d-texture-synthesis"><a class="header" href="#2d-texture-synthesis">2D Texture Synthesis</a></h2>
<p><img src="TextureSynthesis/../assets/%E5%90%88%E6%88%905.png" alt="" /> </p>
<blockquote>
<p>Result像（<strong>度量有多像</strong>）input，但又不是简单的重复（<strong>具有随机性</strong>）</p>
</blockquote>
<p>Given a sample texture <em>I</em>, the goal is to synthesize a new texture <em>J</em> that<br />
• looks like the input sample<br />
• no part of result is the duplicate of the sampl</p>
<h2 id="applications"><a class="header" href="#applications">Applications</a></h2>
<p><img src="TextureSynthesis/../assets/%E5%90%88%E6%88%907.png" alt="" /> </p>
<h1 id="3-3d-texture-synthesis-texture-synthesis-on-surfaces"><a class="header" href="#3-3d-texture-synthesis-texture-synthesis-on-surfaces">3. 3D Texture Synthesis: Texture Synthesis on Surfaces</a></h1>
<h2 id="目标-3"><a class="header" href="#目标-3">目标</a></h2>
<p><img src="TextureSynthesis/../assets/%E5%90%88%E6%88%9040.png" alt="" /></p>
<p><img src="TextureSynthesis/../assets/%E5%90%88%E6%88%9041.png" alt="" /></p>
<p>与2D纹理合成类似</p>
<h2 id="desired-properties"><a class="header" href="#desired-properties">Desired Properties</a></h2>
<ul>
<li>Share advantages of 2D algorithm<br />
• Quality<br />
• Efficient<br />
• General<br />
• Easy to use</li>
<li>Minimum distortion</li>
<li>Minimum discontinuity</li>
</ul>
<p><img src="TextureSynthesis/../assets/%E5%90%88%E6%88%9042.png" alt="" /></p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。
https://caterpillarstudygroup.github.io/GAMES102_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="1-textures"><a class="header" href="#1-textures">1. Textures</a></h1>
<h2 id="what-is-texture"><a class="header" href="#what-is-texture">What is texture?</a></h2>
<h3 id="静态纹理"><a class="header" href="#静态纹理">静态纹理</a></h3>
<p>• <strong>Characterized</strong> by appearance：small parts look alike<br />
• Elements arranged quasi‐<strong>randomly</strong>: they never look exactly the same</p>
<p><img src="TextureSynthesis/../assets/%E5%90%88%E6%88%908.png" alt="" /> </p>
<h3 id="dynamic-textures"><a class="header" href="#dynamic-textures">Dynamic Textures</a></h3>
<p>Appearance similar even as texture evolves</p>
<p><img src="TextureSynthesis/../assets/%E5%90%88%E6%88%9011.png" alt="" /> </p>
<h2 id="classification-attribution"><a class="header" href="#classification-attribution">Classification (Attribution)</a></h2>
<p><img src="TextureSynthesis/../assets/%E5%90%88%E6%88%9012.png" alt="" /> </p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。
https://caterpillarstudygroup.github.io/GAMES102_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="2-2d-texture-synthesis"><a class="header" href="#2-2d-texture-synthesis">2. 2D Texture Synthesis</a></h1>
<h2 id="挑战-1"><a class="header" href="#挑战-1">挑战</a></h2>
<p>简单重复的效果不好：<br />
<img src="TextureSynthesis/../assets/%E5%90%88%E6%88%9013.png" alt="" /> </p>
<h3 id="desirable-properties"><a class="header" href="#desirable-properties">Desirable Properties</a></h3>
<p>• Result looks like the input<br />
• Efficient<br />
• General<br />
• Easy to use<br />
• Extensible</p>
<p><img src="TextureSynthesis/../assets/%E5%90%88%E6%88%9014.png" alt="" /> </p>
<h3 id="challenges-2"><a class="header" href="#challenges-2">Challenges</a></h3>
<p>• how to capture the essence of texture?<br />
• from repeated to stochastic texture</p>
<h2 id="方法论"><a class="header" href="#方法论">方法论</a></h2>
<ul>
<li>Parametric Techniques<br />
• Compute global statistics in feature space and sample images from texture ensemble directly</li>
<li>Non‐parametric Techniques<br />
• Estimate local conditional probability density function and synthesize pixels incrementally</li>
</ul>
<h2 id="parametric-techniques"><a class="header" href="#parametric-techniques">Parametric Techniques</a></h2>
<p>• Hypothesize a <strong>mathematical model</strong> for texture representation<br />
• <strong>Match</strong> model parameters of input and output texture</p>
<p><img src="TextureSynthesis/../assets/%E5%90%88%E6%88%9015.png" alt="" /> </p>
<blockquote>
<p>对每个分辨率，用一个函数提取它的feature，再还原出原始纹理<br />
有点像VAE </p>
</blockquote>
<h3 id="pyramidbased-texture-analysissynthesis"><a class="header" href="#pyramidbased-texture-analysissynthesis">Pyramid‐Based Texture Analysis/Synthesis</a></h3>
<p>[Heeger &amp; Bergen, Siggraph 1995]</p>
<p>• Initialize J to noise<br />
• Create multiresolution pyramids for I and J<br />
• Match the histograms of J’s pyramid levels with I’s pyramid levels<br />
• Loop until convergence<br />
• Can be generalized to 3D</p>
<table><thead><tr><th>Good Case</th><th>Bad Case</th></tr></thead><tbody>
<tr><td><img src="TextureSynthesis/../assets/%E5%90%88%E6%88%9016.png" alt="" /></td><td><img src="TextureSynthesis/../assets/%E5%90%88%E6%88%9017.png" alt="" /></td></tr>
</tbody></table>
<blockquote>
<p>只体现了分布，没有体现特征</p>
</blockquote>
<h2 id="nonparametric-techniques"><a class="header" href="#nonparametric-techniques">Non‐Parametric Techniques</a></h2>
<ul>
<li>Synthesis by <strong>copying</strong> from the input</li>
<li><strong>Markov‐Random</strong> Field Model<br />
• Pixel appearance depends only on neighborhood</li>
</ul>
<p><img src="TextureSynthesis/../assets/%E5%90%88%E6%88%9018.png" alt="" /> </p>
<blockquote>
<p>🔎 Markov Random Field</p>
</blockquote>
<h3 id="synthesizing-one-pixel"><a class="header" href="#synthesizing-one-pixel">Synthesizing One Pixel</a></h3>
<p><img src="TextureSynthesis/../assets/%E5%90%88%E6%88%9019.png" alt="" /></p>
<p>• Assuming Markov property, what is conditional probability distribution of p, given the neighbourhood window?<br />
• Instead of constructing a model, let’s directly search the input image for all such neighbourhoods to produce a histogram for p<br />
• To synthesize p,  just pick one match at random</p>
<p>例子：<br />
<img src="TextureSynthesis/../assets/%E5%90%88%E6%88%9020.png" alt="" /></p>
<blockquote>
<p>👆 Select Best Neighborhood from all Candidates</p>
</blockquote>
<h3 id="randomness-parameter"><a class="header" href="#randomness-parameter">Randomness Parameter</a></h3>
<p><img src="TextureSynthesis/../assets/%E5%90%88%E6%88%9021.png" alt="" /> </p>
<p><img src="TextureSynthesis/../assets/%E5%90%88%E6%88%9022-1.png" alt="" /></p>
<blockquote>
<p>选择不同大小的框，会得到不同的效果</p>
</blockquote>
<h3 id="patchbased-synthesis"><a class="header" href="#patchbased-synthesis">Patch‐based Synthesis</a></h3>
<p>[Liang et al. TOG 2002]</p>
<p>Copy patches instead of single pixels</p>
<p><img src="TextureSynthesis/../assets/%E5%90%88%E6%88%9024.png" alt="" /> </p>
<p><strong>Select</strong> <em><strong>Best</strong></em> <strong>Neighborhood from all Candidates</strong></p>
<h4 id="synthesis-result"><a class="header" href="#synthesis-result">Synthesis Result</a></h4>
<p><img src="TextureSynthesis/../assets/%E5%90%88%E6%88%9025.png" alt="" /></p>
<p>• Efros’ algorithm has a tendency to grow garbage and Wei’s TSVQ acceleration further aggravates this problem. In Contrast, patch‐based sampling avoids growing garbage</p>
<h4 id="优点-1"><a class="header" href="#优点-1">优点：</a></h4>
<ul>
<li>Speed<br />
• Orders of magnitude faster than existing texture synthesis algorithm<br />
• Real‐time synthesis</li>
<li>Quality<br />
• Synthesize high‐quality textures ranging from regular to stochastic<br />
• Avoid growing garbage<br />
• Synthesize subjectively better natural textures</li>
</ul>
<h4 id="mincut-graph-cut-based"><a class="header" href="#mincut-graph-cut-based">Mincut: Graph-cut based</a></h4>
<p>[Efros&amp;Freeman, Siggraph 2002]</p>
<p><img src="TextureSynthesis/../assets/%E5%90%88%E6%88%9026-1.png" alt="" /></p>
<blockquote>
<p>用动态规划减少割缝处的突变</p>
</blockquote>
<p><strong>Minimal error boundary</strong></p>
<p><img src="TextureSynthesis/../assets/%E5%90%88%E6%88%9027.png" alt="" /></p>
<p><strong>Seam Optimization</strong></p>
<blockquote>
<p>最大流最小割问题</p>
</blockquote>
<p><img src="TextureSynthesis/../assets/%E5%90%88%E6%88%9028.png" alt="" /></p>
<p>Construct graph such that:<br />
Graph Mincut \(\Leftrightarrow\) Best Seam</p>
<p><img src="TextureSynthesis/../assets/%E5%90%88%E6%88%9029.png" alt="" /></p>
<p><img src="TextureSynthesis/../assets/%E5%90%88%E6%88%9030.png" alt="" /></p>
<h4 id="results-natural-images"><a class="header" href="#results-natural-images">Results: Natural Images</a></h4>
<p><img src="TextureSynthesis/../assets/%E5%90%88%E6%88%9031.png" alt="" /></p>
<h3 id="textonbased-synthesis"><a class="header" href="#textonbased-synthesis">Texton‐based Synthesis</a></h3>
<p>[Zhang et al., Siggraph 2003]</p>
<p>• Texton: texture element / texture pattern<br />
• Texture elements don’t break apart using texton synthesis</p>
<p><img src="TextureSynthesis/../assets/%E5%90%88%E6%88%9036.png" alt="" /></p>
<h3 id="feature-map--texture-map"><a class="header" href="#feature-map--texture-map">Feature Map + Texture Map</a></h3>
<p><img src="TextureSynthesis/../assets/%E5%90%88%E6%88%9037.png" alt="" /></p>
<blockquote>
<p>寻求保持纹理的特征</p>
</blockquote>
<h3 id="synthesis-with-local-size-control"><a class="header" href="#synthesis-with-local-size-control">Synthesis with Local Size Control</a></h3>
<p><img src="TextureSynthesis/../assets/%E5%90%88%E6%88%9038.png" alt="" /></p>
<h3 id="synthesis-with-vector-field-control"><a class="header" href="#synthesis-with-vector-field-control">Synthesis with Vector Field Control</a></h3>
<p><img src="TextureSynthesis/../assets/%E5%90%88%E6%88%9039.png" alt="" /></p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。
https://caterpillarstudygroup.github.io/GAMES102_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="3d-texture-synthesis算法"><a class="header" href="#3d-texture-synthesis算法">3D Texture Synthesis算法</a></h1>
<h2 id="procedural-texture-synthesis"><a class="header" href="#procedural-texture-synthesis">Procedural texture synthesis</a></h2>
<p>Procedual：过程式，用函数表达纹理</p>
<h3 id="方法论-1"><a class="header" href="#方法论-1">方法论</a></h3>
<p>Use 3D functions to define texture properties of objects<br />
• Non‐trivial programming<br />
• Flexibility<br />
• Parametric control<br />
• Unlimited resolution, antialiasing possible<br />
• Low memory requirements<br />
• Low‐cost visual complexity<br />
• Adapts to arbitrary geometry</p>
<p><img src="TextureSynthesis/../assets/%E5%90%88%E6%88%9043.png" alt="" /></p>
<h3 id="第一步构造纹理特征"><a class="header" href="#第一步构造纹理特征">第一步：构造纹理特征</a></h3>
<ul>
<li><strong>Analytic scalar function of world coordinates</strong>  (<strong>x, y, z</strong>)</li>
<li><strong>Texturing: evaluation of function on object surface</strong>
<ul>
<li>Ray tracing: 3D intersection point with surface</li>
</ul>
</li>
<li><strong>Textures of natural objects</strong>
<ul>
<li>Similarity between different patches
<ul>
<li>Repetitiveness, coherence</li>
</ul>
</li>
<li>Similarity on different resolution scales
<ul>
<li>Self-similarity</li>
</ul>
</li>
<li>But never completely identical
<ul>
<li>Additional disturbances, turbulence, noise</li>
</ul>
</li>
</ul>
</li>
<li><strong>Procedural texture function</strong>
<ul>
<li>Mimics statistical properties of natural textures</li>
<li>Purely empirical approach
<ul>
<li>Looks convincing, but has nothing to do with material's physics</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="第二步perlins-noise生成随机纹理"><a class="header" href="#第二步perlins-noise生成随机纹理">第二步：Perlin’s Noise生成随机纹理</a></h3>
<p>[Perlin, Siggraph 1985]</p>
<ul>
<li><strong>Noise</strong>  (<strong>x,y,z</strong>)
<ul>
<li>Statistical invariance under rotation</li>
<li>Statistical invariance under translation</li>
<li>Narrow bandpass limit in frequency</li>
</ul>
</li>
<li><strong>Integer lattice</strong>  (<strong>i, j,k</strong>)
<ul>
<li>Random number at each lattice point  (i, j,k)
<ul>
<li>Look-up table or hashing function</li>
</ul>
</li>
<li>Gradient lattice noise
<ul>
<li>Random gradient vectors</li>
</ul>
</li>
</ul>
</li>
<li><strong>Evaluation at</strong> (<strong>x,y,z</strong>)
<ul>
<li>Tri-linear interpolation</li>
<li>Cubic interpolation (Hermite spline \(\to\) later)</li>
</ul>
</li>
<li><strong>Unlimited domain</strong>
<ul>
<li>Lattice replicated to fill entire space</li>
</ul>
</li>
<li><strong>Fixed fundamental frequency of \(\sim\) 1 Hz over lattice</strong></li>
<li><strong>Smooth interpolation of interim values</strong></li>
</ul>
<p><img src="TextureSynthesis/../assets/%E5%90%88%E6%88%9044.png" alt="" /></p>
<h3 id="噪声转化为纹理"><a class="header" href="#噪声转化为纹理">噪声转化为纹理</a></h3>
<ul>
<li>
<p><strong>Noise function</strong></p>
<ul>
<li>“White” frequency spectrum</li>
</ul>
</li>
<li>
<p><strong>Natural textures</strong></p>
<ul>
<li>Decreasing power spectrum towards high frequencies</li>
</ul>
</li>
<li>
<p><strong>Turbulence from noise</strong></p>
<ul>
<li>Turbulence \((x)=\sum_{i=0}^{k}\) abs ( noise \((2^i x ) / 2^{i}\))</li>
<li>Summation truncation
<ul>
<li>\(1 / 2^{k+1}\) &lt;  size of one pixel (band limit)</li>
</ul>
</li>
<li>
<ol>
<li>Term: noise  (x)</li>
</ol>
</li>
<li>
<ol start="2">
<li>Term: noise  (2 x) / 2</li>
</ol>
</li>
<li>\(\dots\)</li>
<li>Power spectrum:  1 / f</li>
<li>(Brownian motion: \(1/f^2\))</li>
</ul>
<p><img src="TextureSynthesis/../assets/%E5%90%88%E6%88%9045.png" alt="" /></p>
</li>
</ul>
<h3 id="应用"><a class="header" href="#应用">应用</a></h3>
<p>Reaction Diffusion Based Method<br />
[Turk, Siggraph 1991]</p>
<h3 id="solid-textures"><a class="header" href="#solid-textures">Solid Textures</a></h3>
<p>[Peachey, Siggraph 1985]</p>
<ul>
<li>Solid texture functions in 3D space</li>
<li>Nonhomogeneous materials<br />
• wood and stone</li>
</ul>
<p><img src="TextureSynthesis/../assets/%E5%90%88%E6%88%9052.png" alt="" /></p>
<blockquote>
<p>切开之后里面的体素也有纹理</p>
</blockquote>
<h2 id="samplebased-texture-synthesis"><a class="header" href="#samplebased-texture-synthesis">Sample‐based texture synthesis</a></h2>
<h3 id="methodology-1"><a class="header" href="#methodology-1">Methodology</a></h3>
<ul>
<li>Synthesize a surface texture by <strong>coloring mesh vertices</strong></li>
<li>Extensions from 2D texture synthesis</li>
<li>Key issues
<ul>
<li>Resampling</li>
<li>邻域信息：Size、Orientation</li>
</ul>
</li>
</ul>
<p><img src="TextureSynthesis/../assets/%E5%90%88%E6%88%9054.png" alt="" /></p>
<blockquote>
<p>纹理只定义在mesh顶点上，这种算法常于mesh加密的情况</p>
</blockquote>
<p>Vertex colors on three levels in the mesh hierarchy</p>
<h3 id="例子-2"><a class="header" href="#例子-2">例子</a></h3>
<p>以下是mesh上某个点的邻域信息</p>
<p><img src="TextureSynthesis/../assets/%E5%90%88%E6%88%9055.png" alt="" /></p>
<p>第一步：把点的邻域参数化 </p>
<p><img src="TextureSynthesis/../assets/%E5%90%88%E6%88%9056.png" alt="" /></p>
<p>第二步：采样</p>
<p><img src="TextureSynthesis/../assets/%E5%90%88%E6%88%9057.png" alt="" /></p>
<h3 id="recap-texture-synthesis-by-neighborhood-search"><a class="header" href="#recap-texture-synthesis-by-neighborhood-search">Recap: Texture Synthesis by Neighborhood Search</a></h3>
<p><img src="TextureSynthesis/../assets/%E5%90%88%E6%88%9058.png" alt="" /></p>
<blockquote>
<p>用多分辨率的方法实现上面过程，可以同时捕捉不同大小的特征</p>
</blockquote>
<p><img src="TextureSynthesis/../assets/%E5%90%88%E6%88%9067.png" alt="" /></p>
<h3 id="differences-between-2d-and-3d"><a class="header" href="#differences-between-2d-and-3d">Differences between 2D and 3D</a></h3>
<p><img src="TextureSynthesis/../assets/%E5%90%88%E6%88%9060.png" alt="" /></p>
<h3 id="texture-orientation"><a class="header" href="#texture-orientation">Texture Orientation</a></h3>
<p>Methodology中提到这类算法需要使用某点邻域的方向，获取方向的方法有：</p>
<ul>
<li>user‐specified<br />
<img src="TextureSynthesis/../assets/%E5%90%88%E6%88%9064.png" alt="" /></li>
<li>random (for isotropic textures)</li>
<li>smooth or symmetric (for anisotropic textures)
<ul>
<li>by relaxation</li>
</ul>
</li>
</ul>
<p>不同orientation对纹理结果的影响：<br />
<img src="TextureSynthesis/../assets/%E5%90%88%E6%88%9065.png" alt="" /></p>
<h2 id="patchbased-synthesis-1"><a class="header" href="#patchbased-synthesis-1">Patch‐based Synthesis</a></h2>
<p>[Praun et al., Siggraph 2001]</p>
<p><img src="TextureSynthesis/../assets/%E5%90%88%E6%88%9072.png" alt="" /></p>
<p>每贴一块就是这一块的参数化</p>
<p>大块贴完没贴满的部分，用周边的颜色产生一个patch</p>
<p><img src="TextureSynthesis/../assets/%E5%90%88%E6%88%9075.png" alt="" /></p>
<blockquote>
<p>一个patch一般不是整块，而是基于基本元素的边界，这样是为了保证纹理特征的完整性</p>
</blockquote>
<p><img src="TextureSynthesis/../assets/%E5%90%88%E6%88%9076.png" alt="" /></p>
<blockquote>
<p>如果没有结构，可以随机设置边界</p>
</blockquote>
<h3 id="patch-growth"><a class="header" href="#patch-growth">Patch Growth</a></h3>
<table><thead><tr><th></th><th></th><th></th></tr></thead><tbody>
<tr><td><img src="TextureSynthesis/../assets/%E5%90%88%E6%88%9077.png" alt="" /></td><td><img src="TextureSynthesis/../assets/%E5%90%88%E6%88%9078.png" alt="" /></td><td><img src="TextureSynthesis/../assets/%E5%90%88%E6%88%9079.png" alt="" /></td></tr>
</tbody></table>
<h3 id="results-splotches"><a class="header" href="#results-splotches">Results: Splotches</a></h3>
<p><img src="TextureSynthesis/../assets/%E5%90%88%E6%88%9081.png" alt="" /></p>
<p>(<em><strong>completely automatic: no direction field</strong></em>)</p>
<h3 id="controlling-direction-and-scale"><a class="header" href="#controlling-direction-and-scale">Controlling Direction and Scale</a></h3>
<p><img src="TextureSynthesis/../assets/%E5%90%88%E6%88%9082.png" alt="" /></p>
<blockquote>
<p>各向同性可以随机nomral，各向异性必须定义normal</p>
</blockquote>
<h3 id="controlling-direction-and-scale-1"><a class="header" href="#controlling-direction-and-scale-1">Controlling Direction and Scale</a></h3>
<table><thead><tr><th>各向同性</th><th>各向异性</th></tr></thead><tbody>
<tr><td><img src="TextureSynthesis/../assets/%E5%90%88%E6%88%9082.png" alt="" /></td><td><img src="TextureSynthesis/../assets/%E5%90%88%E6%88%9083.png" alt="" /></td></tr>
</tbody></table>
<h3 id="limitations"><a class="header" href="#limitations">Limitations</a></h3>
<p><img src="TextureSynthesis/../assets/%E5%90%88%E6%88%9085.png" alt="" /></p>
<h2 id="featurealigned-texture-synthesis"><a class="header" href="#featurealigned-texture-synthesis">Feature‐aligned Texture Synthesis</a></h2>
<p>[Xu et al., Siggraph Asia 2009]</p>
<p><img src="TextureSynthesis/../assets/%E5%90%88%E6%88%9087.png" alt="" /></p>
<p>第一步：提取边界特性和方向，把起点集中到一个不显眼的地方<br />
<img src="TextureSynthesis/../assets/%E5%90%88%E6%88%9088.png" alt="" /></p>
<p>结果对比：</p>
<table><thead><tr><th>不基于特征</th><th>基于特征</th></tr></thead><tbody>
<tr><td><img src="TextureSynthesis/../assets/%E5%90%88%E6%88%9089.png" alt="" /></td><td><img src="TextureSynthesis/../assets/%E5%90%88%E6%88%9090.png" alt="" /></td></tr>
</tbody></table>
<h3 id="progressivelyvariant-texture-synthesis"><a class="header" href="#progressivelyvariant-texture-synthesis">Progressively‐Variant Texture Synthesis</a></h3>
<p>[Zhang et al., Siggraph 2003]</p>
<p><img src="TextureSynthesis/../assets/%E5%90%88%E6%88%9091.png" alt="" /></p>
<h2 id="btf-synthesis"><a class="header" href="#btf-synthesis">BTF Synthesis</a></h2>
<p>[Tong et al., Siggraph 2002]</p>
<blockquote>
<p>纹理效果与光照方向有关，这样合成效果更有立体感</p>
</blockquote>
<p>Bidirectional Texture Functions (<strong>BTF</strong>): A collection of images of the same surface under different lighting and viewing directions.<br />
✅ 6D Function ( \(x, y, l_θ, l_φ, v_θ, v_φ\) )<br />
✅ Dense Sampling in Viewing/Lighting Directions<br />
✅ Capturing Appearance of Real World Surface</p>
<p><img src="TextureSynthesis/../assets/%E5%90%88%E6%88%9092.png" alt="" /></p>
<h3 id="real-world-texture-from-curet"><a class="header" href="#real-world-texture-from-curet"><em>Real World Texture from CuRet</em></a></h3>
<p><img src="TextureSynthesis/../assets/%E5%90%88%E6%88%9093.png" alt="" /></p>
<p>•Geometry Details (Mesostructure) on Surface<br />
•Self-Occlusion, Self-Shadow, and Specularity</p>
<h3 id="学习"><a class="header" href="#学习">学习</a></h3>
<p><em>Treating BTF as a 2D Texture Map</em></p>
<p><img src="TextureSynthesis/../assets/%E5%90%88%E6%88%9094.png" alt="" /></p>
<blockquote>
<p>一个像素有多个对应点，每个对应点是这个像素在不同光线下的特征。<br />
把左图特征转化为右图特征，用右图特征来做匹配。<br />
特征转化的过程可以用网络或传统方法，本文用的是滤波。<br />
左右维数越高，能抓到的信息的越多。❓ 上限不就是3600吗？为什么需要10800？</p>
</blockquote>
<p><strong>Surface Texton</strong></p>
<h3 id="使用"><a class="header" href="#使用">使用</a></h3>
<p>Surface Texton Map &amp; Rendering</p>
<p><img src="TextureSynthesis/../assets/%E5%90%88%E6%88%9095.png" alt="" /></p>
<p>每个点根据它的实际情况，从源里面匹配出合适的纹理效果。</p>
<blockquote>
<p>💡 需要提前采好这个兔子的各个角度的数据？</p>
</blockquote>
<p>K‐Coherent Search：通过匹配找到最好的K个，从里面随机选择一个</p>
<p><img src="TextureSynthesis/../assets/%E5%90%88%E6%88%9096.png" alt="" /></p>
<h3 id="comparison"><a class="header" href="#comparison">Comparison</a></h3>
<p><img src="TextureSynthesis/../assets/%E5%90%88%E6%88%9098.png" alt="" /></p>
<h2 id="geometry-synthesis"><a class="header" href="#geometry-synthesis">Geometry synthesis</a></h2>
<p>要解决的问题：Generating geometry over surfaces by texture (geometry) samples，例如：</p>
<table><thead><tr><th></th><th>体素合成</th><th>风格合成</th><th>基于几何匹配的拼接</th></tr></thead><tbody>
<tr><td>效果</td><td><img src="TextureSynthesis/../assets/%E5%90%88%E6%88%90100.png" alt="" /></td><td><img src="TextureSynthesis/../assets/%E5%90%88%E6%88%90101.png" alt="" /></td><td><img src="TextureSynthesis/../assets/%E5%90%88%E6%88%90103.png" alt="" /></td></tr>
<tr><td>方法</td><td><img src="TextureSynthesis/../assets/%E5%90%88%E6%88%9099.png" alt="" /> <br>[Lagae et al., TR 2004]</td><td>Laplace</td><td><img src="TextureSynthesis/../assets/%E5%90%88%E6%88%90102.png" alt="" /><br> [Zhou et al., Siggraph 2006]</td></tr>
</tbody></table>
<p>方法：<br />
• 3D distance field based method<br />
• Image analogies extended to volumes<br />
• Mesh‐based geometric texture synthesis technique</p>
<h1 id="summary-texture-synthesis"><a class="header" href="#summary-texture-synthesis">Summary: Texture Synthesis</a></h1>
<p>• An important topic on content generation (2D/3D) textures or repeated geometries<br />
• A well‐studied topic<br />
• Many applications</p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。
https://caterpillarstudygroup.github.io/GAMES102_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="recap"><a class="header" href="#recap">Recap:</a></h1>
<p>3D Content Creation的常用方法：</p>
<p>• Surface reconstruction<br />
• Geometric modeling<br />
• Geometry processing<br />
• Creative generation<br />
• …</p>
<h1 id="analyzing-and-understanding-3d-contents"><a class="header" href="#analyzing-and-understanding-3d-contents">Analyzing and Understanding 3D Contents</a></h1>
<p>对于已有的模型，如何去分析/理解它？
• Organize Geometric Data<br />
• Understand Structure and Relationships<br />
• Understand Semantics and Functionality<br />
• Synthesizing New Shapes<br />
• …</p>
<h1 id="三维几何处理从局部到全局"><a class="header" href="#三维几何处理从局部到全局">三维几何处理：从局部到<em>全局</em></a></h1>
<p><img src="ShapeAnalysis/../assets/%E7%90%86%E8%A7%A31.png" alt="" /></p>
<blockquote>
<p>102主要是讲处理局部信息，但3D内容理解是要处理全局信息</p>
</blockquote>
<ul>
<li>Local level analysis<br />
• purely geometry/content‐driven<br />
• mathematical formulation of objectives<br />
• Examples: curvature and normal estimation, mesh smoothing, simplification, remeshing, parameterization…</li>
<li>High level analysis<br />
• non‐local analysis<br />
• not easy to formulate objectives mathematically<br />
• <strong>Semantics</strong> is hard!</li>
</ul>
<h1 id="problems-of-shape-analysis"><a class="header" href="#problems-of-shape-analysis">Problems of Shape Analysis</a></h1>
<h2 id="understanding-shapes"><a class="header" href="#understanding-shapes">Understanding Shapes</a></h2>
<h3 id="shape-features"><a class="header" href="#shape-features">Shape features</a></h3>
<p>• Feature points<br />
• Feature lines<br />
• Saliency</p>
<p><img src="ShapeAnalysis/../assets/%E7%90%86%E8%A7%A32.png" alt="" /></p>
<h3 id="alignment-upright"><a class="header" href="#alignment-upright">Alignment (upright)</a></h3>
<p><img src="ShapeAnalysis/../assets/%E7%90%86%E8%A7%A33.png" alt="" /></p>
<h3 id="shape-segmentation-components"><a class="header" href="#shape-segmentation-components">Shape segmentation (components)</a></h3>
<p><img src="ShapeAnalysis/../assets/%E7%90%86%E8%A7%A34.png" alt="" /></p>
<h3 id="cosegmentation-of-a-set-of-shapes"><a class="header" href="#cosegmentation-of-a-set-of-shapes">Co‐segmentation of a set of shapes</a></h3>
<p>• More knowledge can be inferred from multiple shapes rather than an individual shape</p>
<p><img src="ShapeAnalysis/../assets/%E7%90%86%E8%A7%A35.png" alt="" /></p>
<h3 id="labeling"><a class="header" href="#labeling">Labeling</a></h3>
<p><img src="ShapeAnalysis/../assets/%E7%90%86%E8%A7%A36.png" alt="" /></p>
<h3 id="symmetries"><a class="header" href="#symmetries">Symmetries</a></h3>
<p><img src="ShapeAnalysis/../assets/%E7%90%86%E8%A7%A37.png" alt="" /></p>
<h3 id="skeleton"><a class="header" href="#skeleton">Skeleton</a></h3>
<p><img src="ShapeAnalysis/../assets/%E7%90%86%E8%A7%A38.png" alt="" /></p>
<h3 id="shape-matching"><a class="header" href="#shape-matching">Shape matching</a></h3>
<p>• Similarity<br />
• Correspondences</p>
<p><img src="ShapeAnalysis/../assets/%E7%90%86%E8%A7%A39.png" alt="" /></p>
<h3 id="shape-retrieval-检索"><a class="header" href="#shape-retrieval-检索">Shape retrieval 检索</a></h3>
<p><img src="ShapeAnalysis/../assets/%E7%90%86%E8%A7%A310.png" alt="" /></p>
<h3 id="classification"><a class="header" href="#classification">Classification</a></h3>
<p><img src="ShapeAnalysis/../assets/%E7%90%86%E8%A7%A311.png" alt="" /></p>
<h3 id="structures"><a class="header" href="#structures">Structures</a></h3>
<p>• Hierarchical structures</p>
<p><img src="ShapeAnalysis/../assets/%E7%90%86%E8%A7%A312.png" alt="" /></p>
<h3 id="functionality"><a class="header" href="#functionality">Functionality</a></h3>
<p><img src="ShapeAnalysis/../assets/%E7%90%86%E8%A7%A313.png" alt="" /></p>
<h3 id="object-affordance-交互"><a class="header" href="#object-affordance-交互">Object affordance 交互</a></h3>
<p><img src="ShapeAnalysis/../assets/%E7%90%86%E8%A7%A314.png" alt="" /></p>
<h3 id="abstraction-of-shapes"><a class="header" href="#abstraction-of-shapes">Abstraction of shapes</a></h3>
<p>• [Mehra et al. SIGAsia 2009]</p>
<p><img src="ShapeAnalysis/../assets/%E7%90%86%E8%A7%A315.png" alt="" /></p>
<h3 id="understanding-assemblies"><a class="header" href="#understanding-assemblies">Understanding assemblies</a></h3>
<p>– [Mitra et al. SIG 2010]</p>
<p><img src="ShapeAnalysis/../assets/%E7%90%86%E8%A7%A315-1.png" alt="" /></p>
<h2 id="shape-descriptors"><a class="header" href="#shape-descriptors">Shape Descriptors</a></h2>
<h3 id="核心问题形状表征描述子特征"><a class="header" href="#核心问题形状表征描述子特征">核心问题：形状表征（描述子、特征）</a></h3>
<p>(Shape representation/descriptor/feature)</p>
<p>如何<strong>度量</strong>两个三维元素的相似性？</p>
<ul>
<li>整体形状
<ul>
<li>全局描述子</li>
</ul>
</li>
<li>局部形状
<ul>
<li>局部描述</li>
</ul>
</li>
</ul>
<p><img src="ShapeAnalysis/../assets/%E7%90%86%E8%A7%A316.png" alt="" /></p>
<p>如何<strong>描述</strong>三维数据？</p>
<p><img src="ShapeAnalysis/../assets/%E7%90%86%E8%A7%A318.png" alt="" /></p>
<ul>
<li>点坐标(x,y,z)</li>
<li>几何量：长度、角度、面积、 体积</li>
<li>微分量：法向量、曲率</li>
<li>拓扑量：连接关系、Laplace谱</li>
<li>映射度量：雅可比（变形量）、共形比</li>
<li>…</li>
</ul>
<h3 id="模型分割根据特征的聚类------clusteringlabeling"><a class="header" href="#模型分割根据特征的聚类------clusteringlabeling">模型分割‐根据特征的聚类      (Clustering/Labeling)</a></h3>
<p><img src="ShapeAnalysis/../assets/%E7%90%86%E8%A7%A317.png" alt="" /></p>
<h3 id="各种人工定义的3d形状特征"><a class="header" href="#各种人工定义的3d形状特征">各种人工定义的3D形状特征</a></h3>
<p><img src="ShapeAnalysis/../assets/%E7%90%86%E8%A7%A338.png" alt="" /></p>
<h1 id="methodology-2"><a class="header" href="#methodology-2">Methodology</a></h1>
<h2 id="traditional-methods特征工程"><a class="header" href="#traditional-methods特征工程">Traditional Methods：特征工程</a></h2>
<p><img src="ShapeAnalysis/../assets/%E7%90%86%E8%A7%A339.png" alt="" /></p>
<h3 id="特征工程的两个主要问题"><a class="header" href="#特征工程的两个主要问题">特征工程的两个主要问题</a></h3>
<p><img src="ShapeAnalysis/../assets/%E7%90%86%E8%A7%A340.png" alt="" /></p>
<h3 id="如何选择合适的特征"><a class="header" href="#如何选择合适的特征">如何选择合适的特征？</a></h3>
<p><img src="ShapeAnalysis/../assets/%E7%90%86%E8%A7%A341.png" alt="" /></p>
<h3 id="handcrafted-features-are-not-enough"><a class="header" href="#handcrafted-features-are-not-enough">Hand‐crafted Features are not Enough</a></h3>
<p>• “Hand‐crafted” feature descriptor need <strong>domain knowledge</strong><br />
• Too many feature descriptor, which is the <strong>best</strong>?<br />
• Concatenation of the features may result in <strong>over‐fitting</strong> in feature space</p>
<h3 id="想法稀疏学习选择合适的特征"><a class="header" href="#想法稀疏学习选择合适的特征">想法：稀疏学习选择合适的特征</a></h3>
<p>[Hu et al. SGP 2012]</p>
<p>• 稀疏学习的本质：聚类<br />
• 子空间聚类(Subspace clustering)</p>
<p><img src="ShapeAnalysis/../assets/%E7%90%86%E8%A7%A342.png" alt="" /></p>
<h2 id="deep-learning-based-methods"><a class="header" href="#deep-learning-based-methods">Deep Learning based Methods</a></h2>
<p>深度学习方法：端到端 to extract good feature descriptors!</p>
<p><img src="ShapeAnalysis/../assets/%E7%90%86%E8%A7%A346.png" alt="" /></p>
<h3 id="三维数据的深度学习的三种方法"><a class="header" href="#三维数据的深度学习的三种方法">三维数据的深度学习的三种方法</a></h3>
<p><img src="ShapeAnalysis/../assets/%E7%90%86%E8%A7%A348.png" alt="" /></p>
<h3 id="关于深度学习"><a class="header" href="#关于深度学习">关于深度学习</a></h3>
<p><img src="ShapeAnalysis/../assets/%E7%90%86%E8%A7%A349.png" alt="" /></p>
<ul>
<li>通用拟合器（较大的逼近函数空间）
<ul>
<li>应用三部曲
<ul>
<li>在哪找（网络构造）、哪个好（损失函数）、怎么找（优化）</li>
</ul>
</li>
<li>仅拟合了大量样本：可能只是“虚假关系”</li>
<li>并没有“理解”或“认知”真正的规律</li>
<li>不可解释性</li>
</ul>
</li>
<li>性能依赖训练样本（数据集）
<ul>
<li>当数据集足够密：近似“最近邻”算法</li>
<li>训练数据集不够完备：缺乏泛化能力</li>
<li>大部分是过拟合</li>
</ul>
</li>
<li>基于深度神经网络的深度学习并不是真正的AI，离 真正的“智能”仍很遥远</li>
</ul>
<h2 id="稀疏学习与深度学习殊途同归"><a class="header" href="#稀疏学习与深度学习殊途同归">稀疏学习与深度学习：殊途同归</a></h2>
<ul>
<li>不同性<br />
• 压缩感知：基于<strong>模型</strong>的，有很好的结构和数学模型；来自于数学理论的突破<br />
• 深度学习：基于<strong>实证</strong>的，模型灵活，须通过数据进行监督学习；来自于求解速度的突破</li>
<li>一致性<br />
• 目标：高维数据的信息(特征)提取<br />
• 结果：从局部信息来处理全局信息<br />
• 类似的网络结构：求解L1优化的IST (Iterative Soft‐Thresholding)算法实质上是多层网络优化</li>
</ul>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。
https://caterpillarstudygroup.github.io/GAMES102_mdbook/</p>
</blockquote>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="theme/pagetoc.js"></script>
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
    </body>
</html>
